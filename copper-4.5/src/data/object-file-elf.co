//[of]:ObjectFile
struct ObjectFile

	// Private
	var pool	: *MemoryPool	// The memory pool to store child elements
	var constantStrings8	: String8Dictionary	// The table of global strings (8 bits)
	var constantStrings16	: String16Dictionary	// The table of global strings (16 bits)
			
	// Writer		
	var section	: *ELFData	// Writing in this section
	var object	: *ELFObject	// Writing in this object
	var dataBuffer	: Bytes	// Temporary buffer to write structures and arrays
	
	// Sections
	var null	: ELFNullSection	// The first null section
	var text	: ELFData	// The .text section
	var data	: ELFData	// The .data section
	var bss	: ELFBss	// The .bss section
	var reltext	: ELFRelocation	// The .rel.text section
	var reldata	: ELFRelocation	// The .rel.data section
	var shstrtab	: ELFStringTable	// The string table for section header
	var strtab	: ELFStringTable	// The string table
	var symtab	: ELFSymbolTable	// The symbol table

//[of]:	initialize - release
//[of]:initialize
function initialize (pool: *MemoryPool)

	self pool	= pool
	self dataBuffer	= pool allocateArray (Byte, 65536)

	self constantStrings8 initialize
	self constantStrings16 initialize
	
	self null	initialize (sndx_null)
	self shstrtab	initialize (sndx_shstrtab)
	self strtab	initialize (sndx_strtab)
	self text	initialize (sndx_text, SHF_ALLOC | SHF_EXECINSTR, 0x90, self reltext)
	self data	initialize (sndx_data, SHF_ALLOC | SHF_WRITE, 0, self reldata)
	self reltext	initialize (sndx_rel_text, sndx_symtab, sndx_text, pool)
	self reldata	initialize (sndx_rel_text, sndx_symtab, sndx_data, pool)
	self bss	initialize (sndx_bss)
	self symtab	initialize (sndx_symtab, pool, self strtab)
	
	// Give a name to sections
	var s = self shstrtab
	s	setName (s, ".shstrtab")
	self strtab	setName (s, ".strtab")
	self text	setName (s, ".text")
	self reltext	setName (s, ".rel.text")
	self data	setName (s, ".data")
	self reldata	setName (s, ".rel.data")
	self bss	setName (s, ".bss")
	self symtab	setName (s, ".symtab")

	self addSection (sndx_text)
	self addSection (sndx_data)
	self addSection (sndx_bss)

end

function addSection (ndx: Uinteger)

	var sym = self pool allocate (ELFSymbol)
	sym initializeSection (ndx)
	self symtab add (sym)

end
//[cf]
//[of]:release
function release

	self shstrtab release
	self strtab release
	self symtab release
	self constantStrings8 release
	self constantStrings16 release

end
//[cf]
//[cf]
//[of]:	accessing
//[of]:firstByte
//[c]The first position (to compute relative offset)
//[c]
var firstByte	: Bytes
//[cf]
//[of]:nextByte
//[c]The write position in the code buffer.
//[c]
var nextByte	: Bytes
//[cf]
//[of]:writtenBytes
function writtenBytes
	return sizeToUnsigned (self nextByte ~ self firstByte)
end
//[cf]
//[of]:virtualAddress
//[c]Returns the current virtual address of the next byte to be written
//[c]
function virtualAddress
	return self object offset + self writtenBytes
end
//[cf]

//[of]:textSection
function textSection
	return self text cast (*ObjectSection)
end
//[cf]
//[of]:dataSection
function dataSection
	return self data cast (*ObjectSection)
end
//[cf]
//[of]:getString8
function getString8 (string: String8)

	var object = self constantStrings8 [string]
	if object isNil
		object = self newStatic
		self data beginObject (object, align_byte)
		self data endObject (object, string cast (Bytes), sizeToUnsigned ((string size + 1) toByteSize))
		object updateSymbol
		self constantStrings8 add (string, object)
	end
	
	return object cast (*ObjectData)
end
//[cf]
//[of]:getString16
function getString16 (string: String16)

	var object = self constantStrings16 [string]
	if object isNil
		object = self newStatic
		self data beginObject (object, align_word)
		self data endObject (object, string cast (Bytes), sizeToUnsigned ((string size + 1) toByteSize))
		object updateSymbol
		self constantStrings16 add (string, object)
	end
	
	return object cast (*ObjectData)
end
//[cf]
//[cf]
//[of]:	creating
//[of]:createData
//[c]Creates a data object
//[c]
//[c]REMARKS
//[c]	The object is not added to a section yet.
//[c]
function createData (code: Bytes, size: Uinteger)
	var obj = self pool allocate (ELFObject)
	obj initializeWithCode (code, size)
	return obj cast (*ObjectData)
end
//[cf]
//[of]:createStatic
//[c]Creates a static object
//[c]
//[c]REMARKS
//[c]	The object is not added to a section yet.
//[c]
function createStatic
 	return self newStatic cast (*ObjectStatic)
end
//[cf]
//[of]:createFunction
//[c]Creates a new function
//[c]
//[c]ARGUMENTS
//[c]	f	-- the function
//[c]	section	-- the section
//[c]	debug	-- true if debug object
//[c]
//[c]REMARKS
//[c]	The object is not added to any section yet but symbols can be added to 
//[c]	the symbol table.
//[c]
function createFunction (	f	: *Function, 
	section	: *ObjectSection,
	debug	: Bool)

	var ndx = self strtab add (f publicName)
	var obj = self pool new (ELFFunction, ndx, f, self, section, debug)
	self symtab add (obj symbol)
	return obj cast (*ObjectFunction)

end
//[cf]
//[of]:createFunctionSymbol
//[c]Creates a new function symbol
//[c]
//[c]ARGUMENTS
//[c]	f -- the extern function
//[c]
//[c]RETURN VALUES
//[c]	The symbol
//[c]
//[c]REMARKS
//[c]	The symbol is added to the symbol table.
//[c]
function createFunctionSymbol (f: *ExternFunction)

	var symbol = self pool allocate (ELFSymbol)
	var ndx = self strtab add (f publicName)
	symbol initializeFunction (ndx)
	self symtab add (symbol)
	return symbol cast (*ObjectSymbol)

end
//[cf]
//[cf]
//[of]:	dumping
//[of]:dump
function dump (filename: String)

	self finalize

	var file : *File
	var err : *Error	
	file, err = File openWrite (filename)
	if err notNil
		return err
	end

	err = err | self dumpHeader (file)
	err = err | self dumpSectionHeader (file)
	err = err | self text	writePaddingTo (file)
	err = err | self text	writeTo (file)
	err = err | self reltext	writePaddingTo (file)
	err = err | self reltext	writeTo (file)
	err = err | self data	writePaddingTo (file)
	err = err | self data	writeTo (file)
	err = err | self reldata	writePaddingTo (file)
	err = err | self reldata	writeTo (file)
	err = err | self shstrtab	writePaddingTo (file)
	err = err | self shstrtab	writeTo (file)
	err = err | self symtab	writePaddingTo (file)
	err = err | self symtab	writeTo (file)
	err = err | self strtab	writePaddingTo (file)
	err = err | self strtab	writeTo (file)
	return err | file close

end
//[cf]
//[cf]
//[of]:	write primitives
//[of]:beginObject
function beginObject (	object	: *ObjectData,
	section	: *ObjectSection,
	align	: Uinteger)

	self section	= section cast (*ELFData)
	self object	= object cast (*ELFObject)
	self firstByte	= self dataBuffer
	self nextByte	= self dataBuffer

	section beginObject (object, align)

end
//[cf]
//[of]:endObject
function endObject (object: *ObjectData)

	var size	= self writtenBytes
	var buffer	= self pool allocateBytes (size cast (Size))
	copyBytes (buffer, self firstByte, size cast (Size))

	self section endObject (object cast (*ELFObject), buffer, size)
	(object cast (*ELFObject)) updateSymbol

end
//[cf]

//[of]:allocateBuffer
function allocateBuffer (T, size: Uinteger)

	var buffer = self nextByte cast (*[] T)
	self nextByte += size cast (Size) * T size
	return buffer

end
//[cf]
//[of]:writeRelativeReference
//[c]Writes a relative reference (for function calls)
//[c]
function writeRelativeReference (	base	: *ObjectSymbol,
	offset	: Uinteger)

	// Add relocation
	var location = self object offset + self writtenBytes
	self section addRelativeRelocation (location, base)

	// Write empty offset
	self writeDword (offset - 4)

end
//[cf]
//[of]:writeReference
//[c]Writes a global reference
//[c]
function writeReference (	symbol	: *ObjectSymbol,
	offset	: Uinteger)

	// Add relocation
	var location	= self object offset + self writtenBytes
	self section addDirectRelocation2 (location, symbol cast (*ELFSymbol))

	// Write empty offset
	self writeDword (offset asUnsigned)

end
//[cf]
//[of]:writeBytes
function writeBytes (buffer: Bytes, size: Integer)

	copyBytes (self nextByte, buffer, size)
	self nextByte += size

end
//[cf]
//[of]:writeByte
function writeByte (x : Byte)
	self write (x)
end
//[cf]
//[of]:writeWord
function writeWord (x : Uint16)
	self write (x)
end
//[cf]
//[of]:writeDword
function writeDword (x : Uint32)
	self write (x)
end
//[cf]
//[of]:writeQword
function writeQword (x : Uint64)
	self write (x)
end
//[cf]
//[of]:write
function write (x)
	// Get the current address
	var p = self nextByte cast (*[] @x)
	
	// Store value
	p [] = x
	
	// Advance pointer
	p ++
	
	// Save pointer
	self nextByte = p cast (Bytes)
end
//[cf]
//[cf]
//[of]:	private
//[of]:constants
static const sndx_null	= Uinteger : 0
static const sndx_text	= Uinteger : 1
static const sndx_rel_text	= Uinteger : 2
static const sndx_data	= Uinteger : 3
static const sndx_rel_data	= Uinteger : 4
static const sndx_bss	= Uinteger : 5
static const sndx_shstrtab	= Uinteger : 6
static const sndx_symtab	= Uinteger : 7
static const sndx_strtab	= Uinteger : 8
static const numSections	= Uinteger : 9
//[cf]
//[of]:newStatic
//[c]Creates a static object
//[c]
//[c]REMARKS
//[c]	The object is not added to a section yet.
//[c]
function newStatic

	var name = self symtab generateUniqueName ("S")
	var ndx = self strtab add (name)

	var obj = self pool new (ELFStatic, ndx)
	self symtab add (obj symbol)
 	return obj

end
//[cf]
//[of]:finalize
function finalize

	var offset = Uinteger : 0
	offset += sizeToUnsigned (Elf32_Ehdr size)
	offset += numSections * sizeToUnsigned (Elf32_Shdr size)
	
	offset = self text	finalize (offset)
	offset = self reltext	finalize (offset)
	offset = self data	finalize (offset)
	offset = self reldata	finalize (offset)
	offset = self bss	finalize (offset)
	offset = self shstrtab	finalize (offset)
	offset = self symtab	finalize (offset)
	offset = self strtab	finalize (offset)

end
//[cf]
//[of]:dumpHeader
function dumpHeader (file)

	var h	: Elf32_Ehdr
	var ident	= * [16] Byte : {0x7F, 0x45, 0x4C, 0x46, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}
	
	copyBytes (h ident, ident, EI_NIDENT)
	h type	= ET_REL	// File type: an object file
	h machine	= EM_386	// Machine: x86
	h version	= EV_CURRENT	// Version: must be "current"
	h entry	= 0	// 
	h phoff	= 0	// Position of the program header
	h shoff	= sizeToUnsigned (Elf32_Ehdr size)	// Position of the section header (immediately after the header)
	h flags	= 0	// Flags
	h ehsize	= Elf32_Ehdr size cast (Uint16)	// Size of the header
	h phentsize	= 0	// Size of an item in the program header
	h phnum	= 0	// Number of program header
	h shentsize	= Elf32_Shdr size cast (Uint16)	// Size of an item in the section header
	h shnum	= numSections cast (Uint16)	// Number of sections in the section header
	h shstrndx	= sndx_shstrtab cast (Uint16)	// The string table for the section header is the first section (after null)
	
	var writtern, err = file write (h cast (Bytes), Elf32_Ehdr size)
	return err

end
//[cf]
//[of]:dumpSectionHeader
function dumpSectionHeader (file: *File)

	var err = self null	writeHeaderTo (file)
	err = err | self text	writeHeaderTo (file)
	err = err | self reltext	writeHeaderTo (file)
	err = err | self data	writeHeaderTo (file)
	err = err | self reldata	writeHeaderTo (file)
	err = err | self bss	writeHeaderTo (file)
	err = err | self shstrtab	writeHeaderTo (file)
	err = err | self symtab	writeHeaderTo (file)
	err = err | self strtab	writeHeaderTo (file)
	return err

end
//[cf]
//[of]:classes
//[of]:String8Dictionary
static const String8Dictionary = SimpleDictionary (String8, *ELFObject, nil, nil)
//[cf]
//[of]:String16Dictionary
static const String16Dictionary = SimpleDictionary (String16, *ELFObject, nil, nil)
//[cf]
//[cf]
//[cf]

end
//[cf]
//[of]:ObjectSection
struct ObjectSection

	function _impl
		return self cast (*ELFData)
	end
		
//[of]:	accessing
//[of]:lineNumberOffset
function lineNumberOffset
	return self _impl lineNumberOffset
end
//[cf]
//[cf]
//[of]:	adding - removing
//[of]:addObject
//[c]Adds an object to the section
//[c]
//[c]ARGUMENTS
//[c]	object	--	the object associated to this data (its address is saved)
//[c]
function addObject (object: *ObjectData, align: Uinteger)
	self _impl addObject (object _impl, align)
end
//[cf]
//[of]:beginObject
//[c]Starts adding an object to the section: the object is assigned an offset
//[c]
//[c]ARGUMENTS
//[c]	object	--	the object associated to this data (its address is saved)
//[c]
//[c]REMARKS
//[c]	No other object can be added to the section until this one is completed.
//[c]
function beginObject (object: *ObjectData, align: Uinteger)
	self _impl beginObject (object _impl, align)
end
//[cf]
//[of]:endObject
//[c]Completes the insertion of an object into the section
//[c]
//[c]	The size of the object should be set, so the size of the section
//[c]	can be updated.
//[c]
//[c]ARGUMENTS
//[c]	object	--	the object associated to this data (its address is saved)
//[c]
function endObject (object: *ObjectData, buffer: Bytes, size: Integer)
	self _impl endObject (object _impl, buffer, size)
end
//[cf]

//[of]:addDirectRelocation
//[c]Adds a relocation
//[c]
function addDirectRelocation (base: *ObjectData, offset: Uinteger, symbol: *ObjectSymbol)
	self _impl addDirectRelocation (base _impl, offset, symbol _impl)
end

function addDirectRelocation2 (offset: Uinteger, symbol: *ObjectSymbol)
	self _impl addDirectRelocation (offset, symbol _impl)
end
//[cf]
//[of]:addRelativeRelocation
//[c]Adds a relocation
//[c]
//[c]	The offset is relative to the current object being added, so the
//[c]	RVA is this offset + the offset of the o
//[c]
function addRelativeRelocation (offset: Uint32, symbol: *ObjectSymbol)
	self _impl addRelativeRelocation (offset, symbol)
end
//[cf]
//[of]:beginLineNumber
function beginLineNumber (object: *ObjectData)
	self _impl beginLineNumber (object cast (*ELFObject))
end
//[cf]
//[of]:addLineNumber
function addLineNumber (address: Uint32, line: Uint16)
	self _impl addLineNumber (address, line)
end
//[cf]
//[cf]

end
//[cf]
//[of]:ObjectData
//[c]Base class of all objects having an address:
//[c]	- function, 
//[c]	- variable, 
//[c]	- constant structure
//[c]	- constant array
//[c]	- constant strings
//[c]
//[c]An object is a piece of data inserted into a section with an optional 
//[c]symbol to reference it.
//[c]
//[c]Any object that can be referenced must have a symbol. Only builtin
//[c]functions shouldn't require a symbol.
//[c]
//[c]All these objects can be relocated
//[c]
struct ObjectData

	function _impl
		return self cast (*ELFObject)
	end
	
//[of]:	accessing
//[of]:buffer
function buffer
	return self _impl buffer
end
//[cf]
//[of]:symbol
function symbol
	return self _impl symbol cast (*ObjectSymbol)
end
//[cf]
//[cf]
//[of]:	converting
//[of]:relative
function relative (	fromObject	: *ObjectData,
	fromOffset	: Uinteger)

	var from = fromOffset + fromObject _impl offset
	return self _impl offset - (from + 4)

end
//[cf]
//[cf]

end
//[cf]
//[of]:ObjectStatic
struct ObjectStatic : ObjectData
end
//[cf]
//[of]:ObjectFunction
struct ObjectFunction : ObjectData

	function _impl
		return self cast (*ELFFunction)
	end

//[of]:	updating
//[of]:finalize
//[c]Finalizes
//[c]
//[c]	This function is invoked when the function is fully built.
//[c]
function finalize (	debug	: Bool, 
	firstLineOffset	: Uinteger,
	lineNumberCount	: Uinteger,
	firstLineNumber	: LineNumber,
	lastLineNumber	: LineNumber)

	self _impl finalize (debug, firstLineOffset, lineNumberCount, firstLineNumber, lastLineNumber)

end
//[cf]
//[cf]

end
//[cf]
//[of]:ObjectSymbol
struct ObjectSymbol

	function _impl
		return self cast (*ELFSymbol)
	end

//[of]:	output
//[of]:addToStringBuffer
function addToStringBuffer (sb: *StringBuffer)
	self _impl addToStringBuffer (sb)
end
//[cf]
//[cf]

end
//[cf]

.private
//[of]:ELF
//[of]:ELFSection
struct ELFSection

	var header	: Elf32_Shdr
	var index	: Uinteger
	var padding	: Uinteger

//[of]:	initialize - release
//[of]:initialize
function initialize (index: Uinteger)

	self index	= index
	self padding	= 0

	var sh = self header
	sh name	= 0
	sh type	= SHT_NULL
	sh flags	= 0
	sh addr	= 0
	sh offset	= 0
	sh size	= 0
	sh link	= SHN_UNDEF cast (Uint32)
	sh info	= 0
	sh addralign	= 0
	sh entsize	= 0

end
//[cf]
//[cf]
//[of]:	accessing
//[of]:setName
function setName (strings: *ELFStringTable, name: String8)
	self header name = strings add (name)
end
//[cf]
//[of]:setRange
function setRange (o: Uinteger, size: Uinteger)
	// Align offset with addralign constraint
	var mask = self header addralign - 1
	var offset = o
	offset += mask
	offset &= not mask
	self padding = offset - o
	
	self header offset	= offset
	self header size	= size
	
	return offset + size
end
//[cf]
//[cf]
//[of]:	writing
//[of]:writeHeaderTo
function writeHeaderTo (file: *File)
	var written, err = file write (self header cast (Bytes), Elf32_Shdr size)
	return err
end
//[cf]
//[of]:writePaddingTo
function writePaddingTo (file: *File)
	if self padding == 0
		return nil
	end
	var written, err = file write (*[] Byte : {0, 0, 0}, self padding cast (Size))
	return err
end
//[cf]
//[cf]
end
//[cf]
//[of]:ELFNullSection
struct ELFNullSection : ELFSection

	function initialize (index: Uinteger)
		self super initialize (index)
	end

end
//[cf]
//[of]:ELFSymbolTable
struct ELFSymbolTable : ELFSection

	// Private
	var pool	: *MemoryPool
	var symbols	: Collection (ELFSymbol)	// The symbol table
	var nameBuffer	: MemoryBuffer	// Buffer to generate the name of symbols
	var nameIndex	: Uinteger	// Suffix to generate a unique symbol

//[of]:	initialize - release
//[of]:initialize
function initialize (index: Uinteger, pool: *MemoryPool, strings: *ELFStringTable)

	self super initialize (index)
	self pool	= pool
	self nameIndex	= 1
	self symbols	initialize
	self nameBuffer	initialize

	var sh = self header
	sh type	= SHT_SYMTAB
	sh link	= strings index asUnsigned
	sh info	= 4 // index of first GLOBAL in the table: null + 3 sections => 4
	sh addralign	= 4
	sh entsize	= sizeToUnsigned (Elf32_Sym size)

	var sym = self pool allocate (ELFSymbol)
	sym initializeNull
	self add (sym)

end
//[cf]
//[of]:release
function release
	self nameBuffer release
end
//[cf]
//[of]:finalize
function finalize (o: Uinteger)
	var n	= self symbols size asUnsigned
	var size	= n * sizeToUnsigned (Elf32_Sym size)
	return self setRange (o, size)
end
//[cf]
//[cf]
//[of]:	adding - removing
//[of]:add
function add (symbol: *ELFSymbol)
	symbol index = self symbols size asUnsigned
	self symbols add (symbol)
end
//[cf]
//[cf]
//[of]:	writing
//[of]:writeTo
function writeTo (file: *File)
	self symbols each do symbol
		var written, err = file write (symbol elfSymbol cast (Bytes), Elf32_Sym size)
		if err notNil
			return err
		end
	end
	return nil
end
//[cf]
//[cf]
//[of]:	utils
//[of]:generateUniqueName
//[c]Generates a unique name for the symbol table based on the given string
//[c]
function generateUniqueName (s: String8)

	var nameBuffer = self nameBuffer
	nameBuffer removeAll
	nameBuffer addByte ($_)
	nameBuffer addBlock (s, s size toByteSize)
	addUnsignedToBuffer (nameBuffer, self nameIndex)
	nameBuffer addByte (0)

	self nameIndex ++

	return nameBuffer base cast (String8)

end
//[cf]
//[cf]
	
end
//[cf]
//[of]:ELFStringTable
struct ELFStringTable : ELFSection

	var buffer	: MemoryBuffer

//[of]:	initialize - release
//[of]:initialize
function initialize (index: Uinteger)

	self super initialize (index)
	self buffer initialize
	self buffer addByte (0)

	var sh = self header
	sh type	= SHT_STRTAB
	sh addralign	= 1

end
//[cf]
//[of]:release
function release
	self buffer release
end
//[cf]
//[of]:finalize
function finalize (offset: Uinteger)
	return self setRange (offset, sizeToUnsigned (self buffer size))
end
//[cf]
//[cf]
//[of]:	adding - removing
//[of]:add
function add (s: String8)
	var offset = self buffer size
	self buffer addBlock (s, (s size + 1) toByteSize)
	return sizeToUnsigned (offset)
end
//[cf]
//[cf]
//[of]:	writing
//[of]:writeTo
function writeTo (file: *File)
	var written, err = file write (self buffer base, self buffer size)
	return err
end
//[cf]
//[cf]

end
//[cf]
//[of]:ELFRelocation
struct ELFRelocation : ELFSection

	static const max_relocation_numbers = Index : 10000
	
	var size	: Uinteger
	var pointer	: *[] Elf32_Rel
	var buffer	: *[] Elf32_Rel

	// Private
	var pool	: *MemoryPool
	var symbols	: Collection (ELFSymbol)	// The symbol table
	var nameBuffer	: MemoryBuffer	// Buffer to generate the name of symbols
	var nameIndex	: Uinteger	// Suffix to generate a unique symbol

//[of]:	initialize - release
//[of]:initialize
function initialize (index: Uinteger, symtab: Uinteger, section: Uinteger, pool: *MemoryPool)

	self super initialize (index)

	var sh = self header
	sh type	= SHT_REL
	sh link	= symtab
	sh info	= section
	sh addralign	= 4
	sh entsize	= sizeToUnsigned (Elf32_Rel size)

	self buffer	= pool allocateArray (Elf32_Rel, max_relocation_numbers)
	self pointer	= self buffer
	self size	= 0

end
//[cf]
//[of]:finalize
function finalize (o: Uinteger)

	var n = self size
	var size = n * sizeToUnsigned (Elf32_Rel size)
	return self setRange (o, size)

end
//[cf]
//[cf]
//[of]:	adding - removing
//[of]:add
function add (offset: Uinteger, symbol: *ELFSymbol, type: Byte)

	self pointer [0] set (offset, symbol index, type)
	self pointer ++
	self size ++

end
//[cf]
//[cf]
//[of]:	writing
//[of]:writeTo
function writeTo (file: *File)
	if self size == 0
		return nil
	end
	var written, err = file write (self buffer cast (Bytes), self size cast (Size) * Elf32_Rel size)
	return err
end
//[cf]
//[cf]

end
//[cf]
//[of]:ELFData
struct ELFData : ELFSection

	// Private
	var size	: Uinteger	// The size
	var objects	: Collection (ELFObject)	// All objects of the section
	var pad	: Byte	// Align with this value
	var relocations	: *ELFRelocation	// The associated relocation section

//[of]:	initialize - release
//[of]:initialize
//[c]Initializes a data section
//[c]
//[c]ARGUMENTS
//[c]	index	-- the index of the section in the section header
//[c]	flags	-- the flags of the section header
//[c]	pad	-- byte to fill holes between blocks (when there is an align constraint)
//[c]	relocations	-- the associated relocation section
//[c]
function initialize (	index	: Uinteger, 
	flags	: Uint32, 
	pad	: Byte,
	relocations	: *ELFRelocation)

	self super initialize (index)
	self size	= 0
	self pad	= pad
	self relocations	= relocations
	self objects	initialize

	var sh = self header
	sh type	= SHT_PROGBITS
	sh flags	= flags
	sh addralign	= 4

end
//[cf]
//[of]:finalize
function finalize (o: Uinteger)
	return self setRange (o, self size)
end
//[cf]
//[cf]
//[of]:	accessing
//[of]:lineNumberOffset
function lineNumberOffset
	// ###
	return Uinteger : 0
end
//[cf]
//[cf]
//[of]:	adding - removing
//[of]:addObject
//[c]Adds an object to the section
//[c]
//[c]ARGUMENTS
//[c]	object	--	the object associated to this data (its address is saved)
//[c]
function addObject (object: *ELFObject, align: Uinteger)

	self beginObject (object, align)
	
	// Update the size of the section	
	self size = object offset + object size

end
//[cf]
//[of]:beginObject
//[c]Starts adding an object to the section: the object is assigned an offset
//[c]
//[c]ARGUMENTS
//[c]	object	--	the object associated to this data (its address is saved)
//[c]
//[c]REMARKS
//[c]	No other object can be added to the section until this one is completed.
//[c]
function beginObject (object: *ELFObject, align: Uinteger)

	// Align the offset
	var offset	= self size
	var mask	= align - 1
	offset += mask
	offset &= not mask
	
	// Set the location of the object
	object section	= self
	object offset	= offset

	self objects add (object)

end
//[cf]
//[of]:endObject
//[c]Completes the insertion of an object into the section
//[c]
//[c]	The size of the object should be set, so the size of the section
//[c]	can be updated.
//[c]
//[c]ARGUMENTS
//[c]	object	--	the object associated to this data (its address is saved)
//[c]
function endObject (object: *ELFObject, buffer: Bytes, size: Uinteger)

	object buffer	= buffer
	object size	= size
	
	// Update the size of the section	
	self size = object offset + size

end
//[cf]

//[of]:addDirectRelocation
//[c]Adds a relocation
//[c]
function addDirectRelocation (base: *ELFObject, offset: Uinteger, symbol: *ELFSymbol)
	self relocations add (base offset + offset, symbol, R_386_32)
end

function addDirectRelocation2 (offset: Uinteger, symbol: *ELFSymbol)
	self relocations add (offset, symbol, R_386_32)
end
//[cf]
//[of]:addRelativeRelocation
//[c]Adds a relocation
//[c]
//[c]	The offset is relative to the current object being added, so the
//[c]	RVA is this offset + the offset of the o
//[c]
function addRelativeRelocation (offset: Uinteger, symbol: *ObjectSymbol)
	self relocations add (offset, symbol cast (*ELFSymbol), R_386_PC32)
end
//[cf]
//[of]:beginLineNumber
function beginLineNumber (object: *ELFObject)

//[c]	###
//[c]	self addLineNumber (object symbol _number, 0)

end
//[cf]
//[of]:addLineNumber
function addLineNumber (address: Uint32, line: Uint16)

//[c]	###
//[c]	if self _lineNumbers isNil
//[c]		self _lineNumbers = self _pool new (COFFLineBuffer)
//[c]	end
//[c]
//[c]	self _lineNumbers add (address, line)

end
//[cf]
//[cf]
//[of]:	writing
//[of]:writeTo
function writeTo (file: *File)

	var buffer = allocateBytes (self size cast (Size))

	var p = buffer
	self objects each do object
		var next = buffer + object offset
		var pad = self pad
		while p <> next
			p [] = pad
			p ++
		end
		copyBytes (p, object buffer, object size cast (Size))
		p += object size
	end

	var err = Error nil
	if self size <> 0
		var written : Size
		written, err = file write (buffer, self size cast (Size))
	end
	freeBytes (buffer, self size cast (Size))
	return err

end
//[cf]
//[cf]

end
//[cf]
//[of]:ELFBss
struct ELFBss : ELFSection
	
//[of]:	initialize - release
//[of]:initialize
//[c]Initializes a bss section
//[c]
//[c]ARGUMENTS
//[c]	index	-- the index of the section in the section header
//[c]
function initialize (index: Uinteger)

	self super initialize (index)

	var sh = self header
	sh type	= SHT_NOBITS
	sh flags	= SHF_ALLOC | SHF_WRITE
	sh addralign	= 4

end
//[cf]
//[of]:finalize
function finalize (o: Uinteger)
	return self setRange (o, 0)
end
//[cf]
//[cf]
//[of]:	writing
//[of]:writeTo
function writeTo (file: *File)
	return true
end
//[cf]
//[cf]

end
//[cf]

//[of]:ELFSymbol
struct ELFSymbol : CollectionElement (ELFSymbol)

	var index	: Uinteger
	var elfSymbol	: Elf32_Sym

//[of]:	initialize - release
//[of]:initializeNull
//[c]Initializes a null symbol
//[c]
//[c]There should be only one null symbol: the first symbol in the symbol table.
//[c]
function initializeNull

	var s = self elfSymbol
	s name	= 0
	s value	= 0
	s size	= 0
	s info	= 0
	s other	= 0
	s shndx	= SHN_UNDEF

end
//[cf]
//[of]:initializeFunction
function initializeFunction (name: Uinteger)

	var s = self elfSymbol
	s name	= name
	s value	= 0
	s size	= 0
	s info	= ELF32_ST_INFO (STB_GLOBAL, STT_FUNC)
	s other	= 0
	s shndx	= SHN_UNDEF

end
//[cf]
//[of]:initializeStatic
function initializeStatic (name: Uinteger)

	var s = self elfSymbol
	s name	= name
	s value	= 0
	s size	= 0
	s info	= ELF32_ST_INFO (STB_GLOBAL, STT_OBJECT)
	s other	= 0
	s shndx	= SHN_UNDEF

end
//[cf]
//[of]:initializeSection
function initializeSection (ndx: Uinteger)

	var s = self elfSymbol
	s name	= 0
	s value	= 0
	s size	= 0
	s info	= ELF32_ST_INFO (STB_LOCAL, STT_SECTION)
	s other	= 0
	s shndx	= ndx cast (Uint16)

end
//[cf]
//[of]:initializeFile
function initializeFile (ndx: Uinteger)

	var s = self elfSymbol
	s name	= ndx
	s value	= 0
	s size	= 0
	s info	= ELF32_ST_INFO (STB_LOCAL, STT_FILE)
	s other	= 0
	s shndx	= SHN_ABS

end
//[cf]
//[cf]
//[of]:	output
//[of]:addToStringBuffer
function addToStringBuffer (sb: *StringBuffer)
	sb << self index
end
//[cf]
//[cf]

end
//[cf]
//[of]:ELFObject
//[c]Base class of all objects having an address:
//[c]	- function, 
//[c]	- variable, 
//[c]	- constant structure
//[c]	- constant array
//[c]	- constant strings
//[c]
//[c]An object is a piece of data inserted into a section with an optional 
//[c]symbol to reference it.
//[c]
//[c]Any object that can be referenced must have a symbol. Only builtin
//[c]functions shouldn't require a symbol.
//[c]
//[c]All these objects can be relocated
//[c]
struct ELFObject : CollectionElement (ELFObject)

	var buffer	: Bytes	// The data
	var size	: Uinteger	// The size of data
	var symbol	: ELFSymbol	// Any object that can be referenced must have a symbol
			
	var section	: *ELFSection	// The section of this object
	var offset	: Uinteger	// The relative position of the object in the section

//[of]:	initialize - release
//[of]:initialize
//[c]Initialize a new object
//[c]
function initialize
	self buffer	= nil
	self size	= 0
	self section	= nil
	self offset	= 0
end
//[cf]
//[of]:initializeWithCode
function initializeWithCode (code: Bytes, size: Uinteger)
	self buffer	= code
	self size	= size
	self section	= nil
	self offset	= 0
end
//[cf]
//[cf]
//[of]:	converting
//[of]:relative
function relative (	fromObject	: *ELFObject,
	fromOffset	: Integer)

	var from = fromOffset + fromObject offset
	return self offset - (from + 4)

end
//[cf]
//[cf]
//[of]:	updating
//[of]:updateSymbol
function updateSymbol

	var s	= self symbol elfSymbol
	s value	= self offset
	s size	= self size
	s shndx	= self section index cast (Uint16)

end
//[cf]
//[cf]

end
//[cf]
//[of]:ELFStatic
struct ELFStatic : ELFObject
//[of]:	initialize - release
//[of]:initialize
function initialize (name: Uinteger)
	self super initialize
	self symbol initializeStatic (name)
end
//[cf]
//[cf]
end
//[cf]
//[of]:ELFFunction
struct ELFFunction : ELFObject
//[of]:	initialize - release
//[of]:initialize
function initialize (	name	: Uinteger,
	f	: *Function, 
	object	: *ObjectFile,
	section	: *ObjectSection,
	debug	: Bool)

	self super initialize
	self symbol initializeFunction (name)
end
//[cf]
//[cf]
//[of]:	updating
//[of]:finalize
//[c]Finalizes
//[c]
//[c]	This function is invoked when the function is fully built.
//[c]
function finalize (	debug	: Bool, 
	firstLineOffset	: Uinteger,
	lineNumberCount	: Uinteger,
	firstLineNumber	: LineNumber,
	lastLineNumber	: LineNumber)

end
//[cf]
//[cf]
end
//[cf]
//[cf]

import "elf/elf"
import "program"
import "commons"
import "std"
