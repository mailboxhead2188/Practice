//[of]:ObjectFile
struct ObjectFile

	var firstByte	: Bytes	// The first position (to compute relative offset)
	var nextByte	: Bytes	// The write position in the code buffer.
			
	// Private		
			
	var pool	: *MemoryPool	// The memory pool to store child elements
			
	var constantStrings8	: String8Dictionary	// The table of global strings (8 bits)
	var constantStrings16	: String16Dictionary	// The table of global strings (16 bits)
			
	// Writer		
	var section	: *ObjectSection	// Writing in this section
	var object	: *ObjectData	// Writing in this object
	var dataBuffer	: Bytes	// Temporary buffer to write structures and arrays
			
	// COFF Only		
	var _textSection	: ObjectSection	// The text section
	var _dataSection	: ObjectSection	// The data section			
	var _symbols	: COFFSymbolTable	// The symbol table
	var _strings	: COFFStringTable	// The strings

//[of]:	initialize - release
//[of]:initialize
function initialize (pool: *MemoryPool)

	self pool	= pool
	self dataBuffer	= pool allocateArray (Byte, 65536)
	
	self _textSection _initialize (	self pool,
		1,
		text_section_name,
	 	IMAGE_SCN_CNT_CODE	|
		IMAGE_SCN_ALIGN_4BYTES	|
		IMAGE_SCN_MEM_EXECUTE	|
		IMAGE_SCN_MEM_READ,
		0x90)
	self _dataSection _initialize (	self pool,
		2,
		data_section_name,
		IMAGE_SCN_CNT_INITIALIZED_DATA	|
		IMAGE_SCN_ALIGN_16BYTES	|
		IMAGE_SCN_MEM_READ	|
		IMAGE_SCN_MEM_WRITE,
		0)
		
	self _strings initialize
	self _symbols initialize (self pool, self _strings)
	self constantStrings8 initialize
	self constantStrings16 initialize

end
//[cf]
//[of]:release
function release

	self _strings release
	self _symbols release
	self constantStrings8 release
	self constantStrings16 release

end
//[cf]
//[cf]
//[of]:	accessing
//[of]:firstByte
//[c]The first position (to compute relative offset)
//[c]
// see attributes
//[cf]
//[of]:nextByte
//[c]The write position in the code buffer.
//[c]
// see attributes
//[cf]
//[of]:writtenBytes
function writtenBytes
	return sizeToUnsigned (self nextByte ~ self firstByte)
end
//[cf]
//[of]:virtualAddress
//[c]Returns the current virtual address of the next byte to be written
//[c]
function virtualAddress
	return self object _offset + self writtenBytes
end
//[cf]

//[of]:textSection
function textSection
	return self _textSection
end
//[cf]
//[of]:dataSection
function dataSection
	return self _dataSection
end
//[cf]
//[of]:getString8
function getString8 (string: String8)

	var object = self constantStrings8 [string]
	if object isNil
		object = self pool new (ObjectStatic, self _symbols)
		self dataSection beginObject (object, align_byte)
		self dataSection endObject (object, string cast (Bytes), sizeToUnsigned ((string size + 1) toByteSize))
		object _updateSymbol
		
		self constantStrings8 add (string, object)
	end
	
	return object

end
//[cf]
//[of]:getString16
function getString16 (string: String16)

	var object = self constantStrings16 [string]
	if object isNil
		object = self pool new (ObjectStatic, self _symbols)
		self dataSection beginObject (object, align_word)
		self dataSection endObject (object, string cast (Bytes), sizeToUnsigned ((string size + 1) toByteSize))
		object _updateSymbol
		
		self constantStrings16 add (string, object)
	end
	
	return object

end
//[cf]
//[cf]
//[of]:	creating
//[of]:createData
//[c]Creates a data object.
//[c]
//[c]REMARKS
//[c]	The object is not added to a section yet.
//[c]
function createData (code: Bytes, size: Uinteger)
	var obj = self pool allocate (ObjectData)
	obj initializeWithCode (code, size)
	return obj
end
//[cf]
//[of]:createStatic
//[c]Creates a static object.
//[c]
//[c]REMARKS
//[c]	The object is not added to a section yet.
//[c]
function createStatic
	return self pool new (ObjectStatic, self _symbols)
end
//[cf]
//[of]:createFunction
//[c]Creates a new function.
//[c]
//[c]ARGUMENTS
//[c]	f	-- The function.
//[c]	section	-- The section.
//[c]	debug	-- True if debug object.
//[c]
//[c]REMARKS
//[c]	The object is not added to any section yet but symbols can be added to 
//[c]	the symbol table.
//[c]
function createFunction (	f	: *Function, 
	section	: *ObjectSection,
	debug	: Bool)

	var obj = self pool new (ObjectFunction, f, self, section, debug)
	return obj

end
//[cf]
//[of]:createFunctionSymbol
//[c]Creates a new function symbol
//[c]
//[c]ARGUMENTS
//[c]	name	-- the name of the function
//[c]
//[c]RETURN VALUES
//[c]	The symbol
//[c]
//[c]REMARKS
//[c]	The symbol is added to the symbol table.
//[c]
function createFunctionSymbol (f: *ExternFunction)

	var symbol = self pool allocate (ObjectSymbol)
	symbol _initializeFunction (self, self _symbols generateFunctionName (f))
	return symbol

end
//[cf]
//[cf]
//[of]:	dumping
//[of]:dump
function dump (filename: String)

//[c]
//[c]	Compute the offset of each element
//[c]	
	var offset = Uinteger : 0
	offset += IMAGE_FILE_HEADER size cast (Uinteger)
	offset += IMAGE_SECTION_HEADER size cast (Uinteger)	// .text section header
	offset += IMAGE_SECTION_HEADER size cast (Uinteger)	// .data section header

	offset = self textSection _finalize (offset)
	offset = self dataSection _finalize (offset)
	
	var offsetSymbolTable = offset
	offset += self _symbols size * IMAGE_SYMBOL_size

	offset += self _strings sizeOfRawData
	var bufferSize	= offset cast (Size)

//[c]
	var buffer = allocateBytes (bufferSize)
	
	var p = buffer
	p = self dumpFileHeader (p, offsetSymbolTable)
	p = self dumpSectionHeader (p, self textSection)
	p = self dumpSectionHeader (p, self dataSection)
	p = self dumpSection (p, self textSection)
	p = self dumpSection (p, self dataSection)
	p = self dumpSymbolTable (p)
	p = self dumpStringTable (p)

	var saved = self saveBuffer (filename, buffer, bufferSize)
	freeBytes (buffer, bufferSize cast (Size))
	return saved

end
//[cf]
//[cf]
//[of]:	write primitives
//[of]:beginObject
function beginObject (	object	: *ObjectData,
	section	: *ObjectSection,
	align	: Uinteger)

	self section	= section
	self object	= object
	self firstByte	= self dataBuffer
	self nextByte	= self dataBuffer

	section beginObject (object, align)

end
//[cf]
//[of]:endObject
function endObject (object: *ObjectData)

	var size	= self writtenBytes
	var buffer	= self pool allocateBytes (size cast (Size))
	copyBytes (buffer, self firstByte, size cast (Size))

	self section endObject (object, buffer, size)
	object _updateSymbol

end
//[cf]

//[of]:allocateBuffer
function allocateBuffer (T, size: Uinteger)

	var buffer = self nextByte cast (*[] T)
	self nextByte += size cast (Size) * T size
	return buffer

end
//[cf]
//[of]:writeRelativeReference
//[c]Writes a relative reference (for function calls)
//[c]
function writeRelativeReference (	base	: *ObjectSymbol,
	offset	: Uinteger)

	// Add relocation
	var fromObject	= self object
	var fromOffset	= fromObject _offset + self writtenBytes
	self section addRelativeRelocation (fromOffset, base)

	// Write empty offset
	self writeDword (offset)

end
//[cf]
//[of]:writeReference
//[c]Writes a global reference
//[c]
function writeReference (	symbol	: *ObjectSymbol,
	offset	: Uinteger)

	// Add relocation
	var fromObject	= self object
	var fromOffset	= self writtenBytes
	self section addDirectRelocation (fromObject, fromOffset, symbol)

	// Write empty offset
	self writeDword (offset)

end
//[cf]
//[of]:writeBytes
function writeBytes (buffer: Bytes, size: Integer)

	self nextByte memoryCopy (buffer, size)
	self nextByte += size

end
//[cf]
//[of]:writeByte
function writeByte (x : Byte)
	self write (x)
end
//[cf]
//[of]:writeWord
function writeWord (x : Uint16)
	self write (x)
end
//[cf]
//[of]:writeDword
function writeDword (x : Uinteger)
	self write (x)
end
//[cf]
//[of]:writeQword
function writeQword (x : Uint64)
	self write (x)
end
//[cf]
//[of]:write
function write (x)
	
	// Get the current address
	var p = self nextByte cast (*[] @x)
	
	// Store value
	p [] = x
	
	// Advance pointer
	p ++
	
	// Save pointer
	self nextByte = p cast (Bytes)

end
//[cf]
//[cf]
//[of]:	private
//[of]:dumpFileHeader
function dumpFileHeader (	p	: Bytes, 
	offsetSymbolTable	: Uinteger)

	var header = p cast (*IMAGE_FILE_HEADER)
	
	header Machine	= IMAGE_FILE_MACHINE_I386
	header NumberOfSections	= sectionCount
	header TimeDateStamp	= 0
	header PointerToSymbolTable	= offsetSymbolTable
	header NumberOfSymbols	= self _symbols size
	header SizeOfOptionalHeader	= 0
	header Characteristics	=	IMAGE_FILE_LINE_NUMS_STRIPPED	|
			IMAGE_FILE_BYTES_REVERSED_LO	|
			IMAGE_FILE_32BIT_MACHINE

	return p + IMAGE_FILE_HEADER size

end
//[cf]
//[of]:dumpSectionHeader
function dumpSectionHeader (	p	: Bytes, 
	section	: *ObjectSection )

	var header = p cast (*IMAGE_SECTION_HEADER)
	
	copyBytes (header Name, section _name, IMAGE_SIZEOF_SHORT_NAME)
	header VirtualSize	= section _virtualSize
	header VirtualAddress	= section _virtualAddress
	header SizeOfRawData	= section _sizeOfRawData
	header PointerToRawData	= section _offsetRawData
	header PointerToRelocations	= section _offsetRelocations
	header PointerToLineNumbers	= section _offsetLineNumbers
	header NumberOfRelocations	= section _numberOfRelocations
	header NumberOfLineNumbers	= section _numberOfLineNumbers
	header Characteristics	= section _characteristics

	return p + IMAGE_SECTION_HEADER size

end
//[cf]
//[of]:dumpSection
function dumpSection (	start	: Bytes,
	section	: *ObjectSection)

	var p = start
	
	// Write raw data
	section _objects each do object
		var next = start + object _offset
		var byte = section _paddingByte
		while p <> next
			p [] = byte
			p ++
		end
		p = self dumpObject (p, object)
	end
	p = start + section _sizeOfRawData
	
	// Write relocations
	var rb = section _relocations buffer
	var rs = section _relocations size * IMAGE_RELOCATION_size
	copyBytes (p, rb, rs cast (Size))
	p += rs

	// Write line numbers
	if section _hasLineNumbers
		var b = section _lineNumbers buffer
		var s = section _lineNumbers size * IMAGE_LINENUMBER_size
		copyBytes (p, b, s cast (Size))
		p += s
	end
	
	return p

end
//[cf]
//[of]:dumpObject
function dumpObject (	base	: Bytes,
	object	: *ObjectData )

	copyBytes (base, object buffer, object size cast (Size))
	return base + object size

end
//[cf]
//[of]:dumpSymbolTable
function dumpSymbolTable (start: Bytes)

	var p = start
	self _symbols each do symbol
		// Fixup pointer to line numbers
		var section = symbol _lineNumberSection
		if section notNil
			symbol _auxSymbolFunction PointerToLinenumber	+= section _offsetLineNumbers
		end
	
		copyBytes (p, symbol _imageSymbol, IMAGE_SYMBOL_size cast (Size))
		p += IMAGE_SYMBOL_size
	end
	return p

end
//[cf]
//[of]:dumpStringTable
function dumpStringTable (start: Bytes)

	var p = start
	
	var q = p cast (*[] Uinteger)
	q[] = self _strings sizeOfRawData
	p += Uinteger size
	
	var b = self _strings base
	var s = self _strings size
	copyBytes (p, b, s cast (Size))
	p += s

	return p

end
//[cf]
//[of]:saveBuffer
function saveBuffer (outFilename: String, buffer: Bytes, size: Size)

	var file, err1 = File openWrite (outFilename)
	if err1 notNil
		return err1
	end
	var written, err2 = file write (buffer, size)
	return err2 | file close

end
//[cf]
//[of]:constants
//[c]
//[c]Number of sections
//[c]	1 for code and const data (.text)
//[c]	1 for global variables (.data)
//[c]
static const sectionCount	= Uint16 : 2

static const text_section_name	= *[] Char8 : {$., $t, $e, $x, $t, 0, 0, 0}
static const data_section_name	= *[] Char8 : {$., $d, $a, $t, $a, 0, 0, 0}
//[cf]
//[of]:classes
//[of]:String8Dictionary
static const String8Dictionary = SimpleDictionary (String8, *ObjectData, nil, nil)
//[cf]
//[of]:String16Dictionary
static const String16Dictionary = SimpleDictionary (String16, *ObjectData, nil, nil)
//[cf]
//[cf]
//[cf]

end
//[cf]
//[of]:ObjectSection
struct ObjectSection : CollectionElement (ObjectSection)
//[of]:	accessing
//[of]:lineNumberOffset
function lineNumberOffset

	if self _lineNumbers isNil
		self _lineNumbers = self _pool new (COFFLineBuffer)
	end
	
	return self _lineNumbers offset

end
//[cf]
//[cf]
//[of]:	adding - removing
//[of]:addObject
//[c]Adds an object to the section
//[c]
//[c]ARGUMENTS
//[c]	object	--	the object associated to this data (its address is saved)
//[c]
function addObject (object: *ObjectData, align: Uinteger)

	self beginObject (object, align)
	
	// Update the size of the section	
	self _size = object _offset + object size

end
//[cf]
//[of]:beginObject
//[c]Starts adding an object to the section: the object is assigned an offset
//[c]
//[c]ARGUMENTS
//[c]	object	--	the object associated to this data (its address is saved)
//[c]
//[c]REMARKS
//[c]	No other object can be added to the section until this one is completed.
//[c]
function beginObject (object: *ObjectData, align: Uinteger)

	// Align the offset
	var offset	= self _size
	var mask	= align - 1
	offset += mask
	offset &= not mask

	// Set the location of the object
	object _section	= self _number
	object _offset	= offset

	self _objects add (object)

end
//[cf]
//[of]:endObject
//[c]Completes the insertion of an object into the section
//[c]
//[c]	The size of the object should be set, so the size of the section
//[c]	can be updated.
//[c]
//[c]ARGUMENTS
//[c]	object	--	the object associated to this data (its address is saved)
//[c]
function endObject (object: *ObjectData, buffer: Bytes, size: Uinteger)

	object buffer	= buffer
	object size	= size
	
	// Update the size of the section	
	self _size = object _offset + size

end
//[cf]

//[of]:addDirectRelocation
//[c]Adds a relocation
//[c]
//[c]	The offset is relative to the given object being added, so the
//[c]	RVA is this offset + the offset of the o
//[c]
function addDirectRelocation (	object	: *ObjectData, 
	offset	: Uinteger, 
	symbol	: *ObjectSymbol)

	self _relocations add (object _offset + offset, symbol, IMAGE_REL_I386_DIR32)

end
//[cf]
//[of]:addRelativeRelocation
//[c]Adds a relocation
//[c]
//[c]	The offset is relative to the current object being added, so the
//[c]	RVA is this offset + the offset of the o
//[c]
function addRelativeRelocation (offset: Uinteger, symbol: *ObjectSymbol)

	self _relocations add (offset, symbol, IMAGE_REL_I386_REL32)

end
//[cf]
//[of]:beginLineNumber
function beginLineNumber (object: *ObjectData)
	self addLineNumber (object symbol _number, 0)
end
//[cf]
//[of]:addLineNumber
function addLineNumber (address: Uinteger, line: Uint16)

	if self _lineNumbers isNil
		self _lineNumbers = self _pool new (COFFLineBuffer)
	end

	self _lineNumbers add (address, line)

end
//[cf]
//[cf]
	
//[c]	COFF Only
//[of]:	attributes
var _pool	: * MemoryPool
var _number	: SectionNumber	
var _name	: *[] Char8
	
var _virtualSize	: Uinteger
var _virtualAddress	: Uinteger
var _size	: Uinteger
var _offsetRawData	: Uinteger
var _offsetRelocations	: Uinteger
var _offsetLineNumbers	: Uinteger
var _characteristics	: Uinteger
	
var _objects	: Collection (ObjectData)	// All objects of the section
var _relocations	: *COFFRelocationBuffer	// The buffer of relocations
var _lineNumbers	: *COFFLineBuffer	// The buffer of line numbers
var _paddingByte	: Byte	// Fill gaps with this value
//[cf]
//[of]:	initialize - release
//[of]:_initialize
function _initialize (	pool	: *MemoryPool,
	number	: SectionNumber,
	name	: *[] Char8,
	characteristics	: Uinteger,
	paddingByte	: Byte)

	self _pool	= pool
	self _number	= number
	self _name	= name
	self _virtualSize	= 0
	self _virtualAddress	= 0
	self _size	= 0
	self _offsetRawData	= 0
	self _offsetRelocations	= 0
	self _offsetLineNumbers	= 0
	self _characteristics	= characteristics
	self _relocations	= pool new (COFFRelocationBuffer)
	self _lineNumbers	= nil
	self _paddingByte	= paddingByte

	self _relocations initialize
	self _objects initialize

end
//[cf]
//[of]:_finalize
function _finalize (offset : Uinteger)

	var p = offset
	
	// offsetRawData
	self _offsetRawData = p
	p += self _sizeOfRawData
	
	// offsetRelocations
	var n = self _relocations size * IMAGE_RELOCATION_size
	if n > 0
		self _offsetRelocations = p
		p += n
	end
	
	// offsetLineNumbers
	if self _lineNumbers notNil
		var m	= self _lineNumbers size * IMAGE_LINENUMBER_size
		if m > 0
			self _offsetLineNumbers = p
			p += m
		end
	end
	
	return p

end
//[cf]
//[cf]
//[of]:	accessing
//[of]:_sizeOfRawData
function _sizeOfRawData

	var s = self _size
	var align = Uinteger : 4
	var mask = align - 1
	s += mask
	s &= not mask
	return s

end
//[cf]
//[of]:_numberOfRelocations
function _numberOfRelocations
	return self _relocations size cast (Uint16)
end
//[cf]
//[of]:_numberOfLineNumbers
function _numberOfLineNumbers : Uint16

	if not self _hasLineNumbers
		return 0
	end
	
	return self _lineNumbers size cast (Uint16)

end
//[cf]
//[cf]
//[of]:	testing
//[of]:_hasLineNumbers
function _hasLineNumbers
	return self _lineNumbers notNil
end
//[cf]
//[cf]
end
//[cf]
//[of]:ObjectData
//[c]Base class of all objects having an address:
//[c]	- function, 
//[c]	- variable, 
//[c]	- constant structure
//[c]	- constant array
//[c]	- constant strings
//[c]
//[c]An object is a piece of data inserted into a section with an optional 
//[c]symbol to reference it.
//[c]
//[c]Any object that can be referenced must have a symbol. Only builtin
//[c]functions shouldn't require a symbol.
//[c]
//[c]All these objects can be relocated
//[c]
struct ObjectData : CollectionElement (ObjectData)

	var buffer	: Bytes	// The data
	var size	: Uinteger	// The size of data
	var symbol	: ObjectSymbol	// Any object that can be referenced must have a symbol
			
	var _section	: SectionNumber	// The section of this object
	var _offset	: Uinteger	// The relative position of the object in the section

//[of]:	initialize - release
//[of]:initialize
//[c]Initialize a new object
//[c]
function initialize
	self buffer	= nil
	self size	= 0
	self _section	= 0
	self _offset	= 0
end
//[cf]
//[of]:initializeWithCode
function initializeWithCode (code: Bytes, size: Uinteger)
	self buffer	= code
	self size	= size
	self _section	= 0
	self _offset	= 0
end
//[cf]
//[cf]
//[of]:	converting
//[of]:relative
function relative (	fromObject	: *ObjectData,
	fromOffset	: Uinteger)

	var from = fromOffset + fromObject _offset
	return self _offset - (from + 4)

end
//[cf]
//[cf]
	
//[c]	COFF Only
//[of]:	updating
//[of]:_updateSymbol
function _updateSymbol

	var s	= self symbol _imageSymbol
	s Value	= self _offset
	s SectionNumber	= self _section

end
//[cf]
//[cf]

end
//[cf]
//[of]:ObjectStatic
struct ObjectStatic : ObjectData
//[of]:	initialize - release
//[of]:initialize
function initialize (symbols: *COFFSymbolTable)

	self super initialize
	self symbol _initializeStatic (symbols, "S")

end
//[cf]
//[cf]
end
//[cf]
//[of]:ObjectFunction
struct ObjectFunction : ObjectData

//[of]:	updating
//[of]:finalize
//[c]Updates the function symbols
//[c]
//[c]	Once the function is fully built, we can complete its associated symbol
//[c]	(and auxiliary debug symbols) with all missing information.
//[c]
function finalize (	debug	: Bool, 
	firstLineOffset	: Uinteger,
	lineNumberCount	: Uinteger,
	firstLineNumber	: LineNumber,
	lastLineNumber	: LineNumber)

	if debug
		var aux	= self _auxSymbol _auxSymbolFunction
		aux TotalSize	= self size
		aux PointerToLinenumber	= firstLineOffset
			
		var bf	= self _bfSymbol _imageSymbol
		bf Value	= self _offset // unused
		bf SectionNumber	= self _section
			
		var bf1	= self _bfSymbol1 _auxSymbolXF
		bf1 Linenumber	= firstLineNumber cast (Uint16)
			
		var lf	= self _lfSymbol _imageSymbol
		lf Value	= lineNumberCount
		lf SectionNumber	= self _section
			
		var ef	= self _efSymbol _imageSymbol
		ef Value	= self _offset	+ self size // end offset
		ef SectionNumber	= self _section
			
		var ef1	= self _efSymbol1 _auxSymbolXF
		ef1 Linenumber	= lastLineNumber cast (Uint16)
	end

end
//[cf]
//[cf]
	
//[c]	COFF Only

	var _auxSymbol	: ObjectSymbol	// The aux symbol. This attribute is used to link the function symbols together.
	var _bfSymbol	: ObjectSymbol	// The last .bf symbol.
	var _bfSymbol1	: ObjectSymbol	// The last .bf aux symbol. This attribute is used to link the .bf symbols together.
	var _lfSymbol	: ObjectSymbol	// The last .bf symbol.
	var _efSymbol	: ObjectSymbol	// The last .bf symbol.
	var _efSymbol1	: ObjectSymbol	// The last .bf aux symbol. This attribute is used to link the .bf symbols together.

//[of]:	initialize - release
//[of]:initialize
function initialize (	f	: *Function, 
	object	: *ObjectFile,
	section	: *ObjectSection,
	debug	: Bool)

	self super initialize

	// Create a .file symbol before the function symbol if the file
	// differs from the one of the previous function.
	if debug
		object _symbols setCurrentLocation (f module)
	end

	self symbol _initializeFunction (object, object _symbols generateFunctionName (f))

	if debug
		var symbols = object _symbols
		self symbol _imageSymbol NumberOfAuxSymbols ++
		
		self _auxSymbol	_initializeAux	(symbols, section)
		self _bfSymbol	_initializeBF	(symbols)
		self _bfSymbol1	_initializeXF1	(symbols)
		self _lfSymbol	_initializeLF	(symbols)
		self _efSymbol	_initializeEF	(symbols)
		self _efSymbol1	_initializeXF1	(symbols)

		// Link the .bf symbol to the aux symbol
		self _auxSymbol _setTagIndex	(self _bfSymbol _number)
		
		// Link symbols
		var lastFunction = symbols lastFunction
		if lastFunction notNil
			var last = lastFunction
			// Link functions
			last _auxSymbol _auxSymbolFunction PointerToNextFunction = self symbol _number
			// Link .bf symbols
			last _bfSymbol1 _auxSymbolXF PointerToNextFunction = self _bfSymbol _number
		end
		// This new function symbol becomes the last one
		symbols lastFunction = self
	end

end
//[cf]
//[cf]

end
//[cf]
//[of]:ObjectSymbol
struct ObjectSymbol : CollectionElement (ObjectSymbol)

//[of]:	output
//[of]:addToStringBuffer
function addToStringBuffer (sb: *StringBuffer)
	sb << self _number
end
//[cf]
//[cf]

//[c]	COFF Only
	var _number	: SymbolNumber	// The symbol number
	var _lineNumberSection	: *ObjectSection	// If not nil: the symbol is an auxiliary with a pointer 
			// to line numbers that must be fixed.
	var _imageSymbol	: IMAGE_SYMBOL	// The raw data

//[of]:	initialize - release
//[of]:_initializeFunction
function _initializeFunction (	object	: *ObjectFile,
	name	: String8)

	self _initializeStandard (	object _symbols, 
		name,
		DT_FUNCTION,
		IMAGE_SYM_CLASS_EXTERNAL)

end
//[cf]
//[of]:_initializeStatic
function _initializeStatic (	symbols	: *COFFSymbolTable,
	baseName	: String8)

	self _initializeStandard (	symbols,
		symbols generateUniqueName (baseName),
		0,
		IMAGE_SYM_CLASS_STATIC)

end
//[cf]
//[of]:_initializeStandard
function _initializeStandard (	symbols	: *COFFSymbolTable,
	name	: String8,
	type	: Uint16,
	storageClass	: Uint8)

	self initialize (symbols)
	
	var s = self _imageSymbol
	symbols setSymbolName (s, name)
	
	s Value	= 0
	s SectionNumber	= 0
	s Type	= type
	s StorageClass	= storageClass
	s NumberOfAuxSymbols	= 0

end
//[cf]
//[of]:_initializeAux
function _initializeAux (	symbols	: *COFFSymbolTable,
	section	: *ObjectSection)

	self initialize (symbols)

	var aux = self _auxSymbolFunction
	aux TagIndex	= 0
	aux TotalSize	= 0
	aux PointerToLinenumber	= 0
	aux PointerToNextFunction	= 0
		
	// The pointer to line number must be fixed later (when the position of
	// line numbers in the file is known)
	self _lineNumberSection = section

end
//[cf]
//[of]:_initializeBF
function _initializeBF (symbols	: *COFFSymbolTable)

	self initialize (symbols)
	
	var s = self _imageSymbol
	copyBytes (s Name, bf_symbol, IMAGE_SIZEOF_SHORT_NAME)
	s Value	= 0
	s SectionNumber	= 0
	s Type	= 0
	s StorageClass	= IMAGE_SYM_CLASS_FUNCTION
	s NumberOfAuxSymbols	= 1

end
//[cf]
//[of]:_initializeLF
function _initializeLF (symbols	: *COFFSymbolTable)

	self initialize (symbols)
	
	var s = self _imageSymbol
	copyBytes (s Name, lf_symbol, IMAGE_SIZEOF_SHORT_NAME)
	s Value	= 0
	s SectionNumber	= 0
	s Type	= 0
	s StorageClass	= IMAGE_SYM_CLASS_FUNCTION
	s NumberOfAuxSymbols	= 0

end
//[cf]
//[of]:_initializeEF
function _initializeEF (symbols	: *COFFSymbolTable)

	self initialize (symbols)
	
	var s = self _imageSymbol
	copyBytes (s Name, ef_symbol, IMAGE_SIZEOF_SHORT_NAME)
	s Value	= 0
	s SectionNumber	= 0
	s Type	= 0
	s StorageClass	= IMAGE_SYM_CLASS_FUNCTION
	s NumberOfAuxSymbols	= 1

end
//[cf]
//[of]:_initializeXF1
function _initializeXF1 (symbols	: *COFFSymbolTable)

	self initialize (symbols)
	
	var s = self _auxSymbolXF
	s unused1	= 0
	s Linenumber	= 0
	s unused2	= 0
	s unused3	= 0
	s PointerToNextFunction	= 0
	s unused4	= 0

end
//[cf]
//[of]:initialize
function initialize (symbols	: *COFFSymbolTable)

	self _number	= toSymbolNumber (symbols size)
	self _lineNumberSection	= nil

	symbols add (self)

end
//[cf]
//[cf]
//[of]:	accessing
//[of]:_auxSymbolFunction
function _auxSymbolFunction
	return self _imageSymbol cast (*IMAGE_AUX_SYMBOL_FUNCTION)
end
//[cf]
//[of]:_auxSymbolXF
function _auxSymbolXF
	return self _imageSymbol cast (*IMAGE_AUX_SYMBOL_BF_EF)
end
//[cf]

//[of]:_setTagIndex
function _setTagIndex (tagIndex: Uinteger)
	self _auxSymbolFunction TagIndex	= tagIndex
end
//[cf]
//[cf]
//[of]:	private
//[of]:constants
static const bf_symbol	= *[8] Byte : {0x2E, 0x62, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}	// .bf
static const lf_symbol	= *[8] Byte : {0x2E, 0x6C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}	// .lf
static const ef_symbol	= *[8] Byte : {0x2E, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}	// .ef
//[cf]
//[cf]

end
//[cf]

.private
//[of]:COFF
//[of]:COFFSymbolTable
struct COFFSymbolTable

	var pool	: *MemoryPool	// The pool to store new symbols
	var symbols	: Collection (ObjectSymbol)	// The symbol table
	var strings	: *COFFStringTable	// The string table to store long strings
	var nameBuffer	: MemoryBuffer	// Buffer to generate the name of symbols
	var nameIndex	: Uinteger	// Suffix to generate a unique symbol
	var location	: *Module	// When the location changes, a .file symbol is inserted into the symbol table.
	var fileSymbol	: *ObjectSymbol	// The last .file symbol. This attribute is used to link the .file symbols together.
	var lastFunction	: *ObjectFunction	// The last function. This attribute is used to link the functions symbols together.

//[of]:	initialize - release
//[of]:initialize
function initialize (pool: *MemoryPool, strings: *COFFStringTable)

	self pool	= pool
	self strings	= strings
	self nameIndex	= 1
	self location	= nil
	self fileSymbol	= nil
	self lastFunction	= nil
	self nameBuffer	initialize
	self symbols	initialize

end
//[cf]
//[of]:release
function release
	self nameBuffer release
end
//[cf]
//[cf]
//[of]:	adding - removing
//[of]:add
function add (symbol: *ObjectSymbol)
	self symbols add (symbol)
end
//[cf]
//[cf]
//[of]:	accessing
//[of]:setCurrentLocation
function setCurrentLocation (location: * Module)

	// Do nothing if the location is the same as the current one
	if location == self location
		return
	end

	// The new location becomes the current one	
	self location = location

	// Create a .file symbol
	var symbol	= self newSymbol
	var imageSymbol	= symbol _imageSymbol
	
	copyBytes (imageSymbol Name, file_symbol, IMAGE_SIZEOF_SHORT_NAME)
	imageSymbol Value	= 0	// Next symbol
	imageSymbol SectionNumber	= IMAGE_SYM_DEBUG
	imageSymbol Type	= 0
	imageSymbol StorageClass	= IMAGE_SYM_CLASS_FILE
	imageSymbol NumberOfAuxSymbols	= 0
	
	// Link the previous .file to this one
	if self fileSymbol notNil
		self fileSymbol _imageSymbol Value = symbol _number
	end
	
	// The new symbol becomes the current .file
	self fileSymbol = symbol

	// Create additional symbol to store the filename
	var n	= location filename
	var p	= nil cast (String8)
	var limit	= p
	while n [] notNul
		if p == limit
			imageSymbol NumberOfAuxSymbols ++
			var aux	= self newSymbol
			p = aux _imageSymbol cast (String8)
			limit = p + IMAGE_SYMBOL_size
		end
		p [] = n [] cast (Char8) // truncate the CodeUnit to 8 bits
		p ++
		n ++
	end

end
//[cf]
//[of]:size
function size
	return self symbols size asUnsigned
end
//[cf]
//[cf]
//[of]:	enumerating
//[of]:each
function each

	self symbols each do symbol
		yield symbol
	end

end
//[cf]
//[cf]
	
//[of]:	creating
//[of]:newSymbol
//[c]Creates a COFF symbol and add it to the symbol table
//[c]
function newSymbol
	return self pool new (ObjectSymbol, self)
end
//[cf]
//[cf]
//[of]:	utils
//[of]:generateUniqueName
//[c]Generates a unique name for the symbol table based on the given string
//[c]
function generateUniqueName (s: String8)

	var nameBuffer = self nameBuffer
	nameBuffer removeAll
	nameBuffer addByte ($_)
	nameBuffer addBlock (s, s size toByteSize)
	addUnsignedToBuffer (nameBuffer, self nameIndex)
	nameBuffer addByte (0)

	self nameIndex ++

	return nameBuffer base cast (String8)

end
//[cf]
//[of]:generateFunctionName
function generateFunctionName (f)

	var buffer = self nameBuffer
	buffer removeAll
	buffer addByte ($_)
	var name = f publicName
	buffer addBlock (name, name size toByteSize)
	
	if f callingConvention <> 'cdecl
		buffer addByte ($@)
		var size = Size : 0
		f eachParameterType do type
			if not type isMeta
				size += max (type size, 4)
			end
		end
		var n = sizeToUnsigned (size)
		addUnsignedToBuffer (buffer, n)
	end
	buffer addByte (0)

	return buffer base cast (String8)

end
//[cf]
//[of]:setSymbolName
function setSymbolName (	sym	: *IMAGE_SYMBOL,
	name	: String8)

	var size	= name size toByteSize
	if size <= IMAGE_SIZEOF_SHORT_NAME
		var p = sym Name
		var limit = p + IMAGE_SIZEOF_SHORT_NAME
		var s = name
		repeat
			var c = s []
			if c isNul
				break
			end
			p [] = c
			p ++
			s ++
		end
		while p <> limit
			p [] = 0
			p ++
		end
	else
		var long = sym long
		long Zeroes	= 0
		long Offset	= self strings add (name)
	end

end
//[cf]
//[cf]
//[of]:	private
//[of]:constants
static const file_symbol	= *[8] Byte : {0x2E, 0x66, 0x69, 0x6C, 0x65, 0x00, 0x00, 0x00}	// .file
//[cf]
//[cf]

end
//[cf]
//[of]:COFFStringTable
struct COFFStringTable
	static const size_of_size_of_string_table = Uinteger : 4
	
	var buffer	: MemoryBuffer

//[of]:	initialize - release
//[of]:initialize
function initialize
	self buffer initialize
end
//[cf]
//[of]:release
function release
	self buffer release
end
//[cf]
//[cf]
//[of]:	accessing
//[of]:base
function base
	return self buffer base
end
//[cf]
//[of]:size
function size
	return self buffer size cast (Uinteger)
end
//[cf]
//[of]:sizeOfRawData
function sizeOfRawData
	return self size + size_of_size_of_string_table
end
//[cf]
//[cf]
//[of]:	adding - removing
//[of]:add
function add (s: String8)

	var offset = sizeToUnsigned (self buffer size)
	self buffer addBlock (s, (s size + 1) toByteSize)
	return offset + size_of_size_of_string_table

end
//[cf]
//[cf]
end
//[cf]
//[of]:COFFLineBuffer
struct COFFLineBuffer

	// The number of line number in the section header is limited to 16 bits.
	// A better implementation should be to use multiple .text sections
	// And write line numbers in chunks.
	//
	// 65536 * 6 = 384Kb
	static const max_line_numbers	= Uinteger : 65535

	var size	: Uinteger
	var pointer	: Bytes
	var buffer	: [IMAGE_LINENUMBER_size * max_line_numbers] Byte

//[of]:	initialize - release
//[of]:initialize
function initialize
	self size	= 0
	self pointer	= self buffer
end
//[cf]
//[cf]
//[of]:	adding - removing
//[of]:add
function add (address: Uinteger, line)

	var p = self pointer cast (*IMAGE_LINENUMBER)
	p VirtualAddress	= address
	p Linenumber	= line
	self pointer += IMAGE_LINENUMBER_size
	self size ++

end
//[cf]
//[cf]
//[of]:	accessing
//[of]:offset
//[c]Returns the current offset in bytes relative to the beginning of the buffer
//[c]
function offset
	return self size * IMAGE_LINENUMBER_size
end
//[cf]
//[cf]

end
//[cf]
//[of]:COFFRelocationBuffer
struct COFFRelocationBuffer

	// 10000 * 10 = 10Kb
	static const max_relocation_numbers	= Uinteger : 10000

	var size	: Uinteger
	var pointer	: Bytes
	var buffer	: [IMAGE_RELOCATION_size * max_relocation_numbers] Byte

//[of]:	initialize - release
//[of]:initialize
function initialize
	self size	= 0
	self pointer	= self buffer
end
//[cf]
//[cf]
//[of]:	adding - removing
//[of]:add
function add (offset: Uinteger, symbol: *ObjectSymbol, type: Uint16)

	var p = self pointer cast (*IMAGE_RELOCATION)
	p VirtualAddress	= offset
	p SymbolTableIndex	= symbol _number
	p Type	= type
	
	self pointer += IMAGE_RELOCATION_size
	self size ++

end
//[cf]
//[cf]

end
//[cf]
//[of]:Scalar Types
//[of]:SectionNumber
const SectionNumber = Int16
//[cf]
//[of]:SymbolNumber
const SymbolNumber = Uinteger

function toSymbolNumber (x)
	return x cast (SymbolNumber)
end
//[cf]
//[cf]
//[cf]

import "coff/coff"

import "program"
import "commons"
import "std"
