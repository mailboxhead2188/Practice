//[of]:CodeGenerator
struct CodeGenerator

	var program	: *Program
	var debug	: Bool
	var dump	: Bool

//[of]:	initialize - release
//[of]:initialize
function initialize (program: *Program, debug: Bool, dump: Bool)
	self program = program
	self debug = debug
	self dump = dump
end
//[cf]
//[cf]
//[of]:	generating
//[of]:generate
function generate (filename: String)

	var generator	: Generator

	// Create the function extension (PFunction)
	self program eachFunction do f
		f generator = self program pool new (PFunction, f, self debug)
	end
	
	// Pass 1 - generate code but don't save, we just want to know
	// what functions are never called after inlining.
	generator initialize (self program)
	generator generate (self debug, self dump, false)
	generator removeDuplicateFunctions (self debug, self dump)
	generator release

	// Pass 2 - again but for real this time
	generator	initialize (self program)
	generator generate (self debug, self dump, true)
	var ok = generator dumpFile (filename)
	generator release

	return ok

end
//[cf]
//[cf]
//[of]:	Generator
static struct Generator : ObjectFile

	var program	: *Program	// The program to be generated
	var pool	: MemoryPool	// We still need to allocate stuffs
	var debug	: Bool	// Generate debug information
	var dump	: Bool	// Dump p-functions
	var functionGenerator	: FunctionGenerator	// Object to generate p-code
	var unsolvedRelatives	: Vector (*MCUnsolvedReference)	// The forwards addresses

	// Variables for function generation
	var currentObject	: *ObjectData	// The current function being generated
	var stackPointer	: StackOffset	// The relative position of the stack pointer at the current state of code generation
			// 0 is when just entered, i.e. the next value on the stack is the return address.
			// -4 is when one dword is pushed.
			// ...
			// This value is useful to compute the relative offset of a local 
			// variable or an argument on the stack.
	var localPointer	: StackOffset	// The offset of locals and variables on the stack
			// 0 means that variables are stored immediately before the return address.
			// -4 means that variables are stored 4 bytes before the returned address.
			// This variable is used because we may need to save some registers
			// on the stack in the function prologue but it is not known when
			// allocating registers.
			
	var unsolvedLabels	: Vector (*MCUnsolvedLabel)	// The forwards labels
	var firstLineOffset	: Uinteger	// Offset of the next line number record in bytes, relative to the first line number record of the section
	var lineNumber	: LineNumber	// The current line number: emit a new address/line pair when the line number changes
	var lineNumberCount	: Uinteger	// The number of line numbers: for the .lf record
	var firstLineNumber	: LineNumber	// The first line number
	var lastLineNumber	: LineNumber	// The last line number
	var loaded	: RegisterMask	// The registers currently loaded
	var storeInterval	: *PIntervalValue	// The intterval to store at the end of the assembled instruction
	
	// Register Allocator
	var instruction	: *PInstruction	// The current instruction scanned
	var lockedRegisters	: RegisterMask	// The registers to keep on the current instruction
	var actives	: [1024] *PVariable	// The list of variables having a register sorted by last index
			// This is a sliding list: the first elements are never removed as they
			// are removed in the order of the list, the activeFirst attribute is just
			// updated.
			// But it limits the total amount of local variables to 1024.
	var activeSize	: Integer	// Number of variables in the active list
	var activeFirst	: Integer	// Offset to the first variable not yet inactive
	var registers	: RegisterMask	// The mask of registers currently used.
	var usedRegisters	: RegisterMask	// The registers used at least once.

//[of]:	initialize - release
//[of]:initialize
function initialize (program: *Program)
	
	self pool	initialize
	self super initialize (self pool)
	self program	= program
	
	self functionGenerator initialize (self pool, self)
	self unsolvedRelatives initialize
	self unsolvedLabels initialize

end
//[cf]
//[of]:release
function release

	self functionGenerator release
	self unsolvedRelatives release
	self unsolvedLabels release
	self super release
	self pool release

end
//[cf]
//[cf]
//[of]:	generating
//[of]:generate
function generate (debug: Bool, dump: Bool, native: Bool)

	var program	= self program
	var modules	= program modules
	self dump	= dump
	self debug	= debug

	program prepareGlobals
	self prepareFunctions
	self prepareExternFunctions

	self generateFunctions
	if native
		self generateNatives
	end

end
//[cf]
//[of]:dumpFile
function dumpFile (filename: String)

	self addBuiltins
	self resolveRelatives
	return self super dump (filename)

end
//[cf]
//[of]:removeDuplicateFunctions
function removeDuplicateFunctions (debug: Bool, dump: Bool)

	// Don't remove duplicate as very different source code may have 
	// same code, resulting unusable source level debugging.
	if debug
		return
	end

	var buckets : FunctionBuckets
	buckets initialize

	// Divide functions up by hash value
	// This step reduce the number of comparisons as we compare
	// only functions with the same hash value.
	self program eachFunction do f
		var pf	= pfunction (f)
		if not pf ignore
			buckets add (f)
		end
	end
	
	// Compare pair of functions inside each bucket
	var count = Index : 0
	buckets each do bucket
		var n = bucket size
		if bucket size > 1
			(n - 1) each do i1
				var f1	= bucket [i1]
				var m1	= pfunction (f1)
				// Skip this one if it already matches
				if m1 equivalent isNil
					var i2 = i1 + 1
					while i2 < n
						var f2	= bucket [i2]
						var m2	= pfunction (f2)
						// Skip this one if it already matches
						if m2 equivalent isNil
							// Two functions can have identical p-code but a 
							// different calling convention. It is critical to
							// compare calling conventions first.
							if f1 callingConvention == f2 callingConvention and m1 isEqual (m2)
								m1 called |= m2 called
								m1 ignore = not m1 called
								m2 equivalent = f1
								m2 ignore = true
								m2 called = false
								count ++
//[c]								output ("\a duplicate of \a\n", f2, f1)
							end
						end
						i2 ++
					end
				end
			end
		end
	end

	if dump
		var sb : StringBuffer
		sb initialize
		sb << String : "Functions: " 
		sb << buckets count
		sb << CodeUnit : 'lf
		sb << String : "Buckets: " 
		sb << buckets buckets size
		sb << CodeUnit : 'lf
		sb << String : "Biggest bucket : " 
		sb << buckets maxCount
		sb << CodeUnit : 'lf
		sb << String : "Duplicates: " 
		sb << count
		sb << CodeUnit : 'lf
		println (sb string)
		sb release
	end
	
	buckets release

end
//[cf]
//[cf]
	
	// private
//[of]:	preparing
//[of]:prepareFunctions
function prepareFunctions

	self program eachFunction do f
		var mc	= pfunction (f)
		if not mc ignore
			mc reset (f, self pool, self, self textSection, self debug)
		end
	end

end
//[cf]
//[of]:prepareExternFunctions
function prepareExternFunctions

	self program eachExternFunction do f
		f generator = self createFunctionSymbol (f)
	end

end
//[cf]
//[cf]
//[of]:	generating
//[of]:addBuiltins
function addBuiltins

	BuiltinId : 'max each do i
		var builtin = self functionGenerator builtins [i]
		if builtin used
			self addBuiltin (builtin)
		end
	end

end
//[cf]
//[of]:addBuiltin
function addBuiltin (builtin : *PBuiltinValue)

	self textSection addObject (builtin object, align_byte)

end
//[cf]
//[of]:resolveRelatives
function resolveRelatives

	self unsolvedRelatives each do u
		var address	= (u fromObject buffer + u fromOffset) cast (*Uinteger)
		address [] = u to relative (u fromObject, u fromOffset)
	end

end
//[cf]

//[of]:generateFunctions
function generateFunctions

	self program eachFunction do f
		var pf = pfunction (f)
		if not pf ignore
			self functionGenerator generate (f, pf)
		end
	end

	self program eachFunction do f
		var pf	= pfunction (f)
		pf ignore = not pf called
	end

end
//[cf]
//[of]:generateNatives
function generateNatives

	self program eachFunction do f
		self generateNative (f)
	end

end
//[cf]
//[of]:generateNative
function generateNative (f: *Function)

	var pf = pfunction (f)
	if pf ignore
		return
	end
	
	var object	= pf object
	var line	= f line
	var cc	= f callingConvention

	pf computeIntervals
	self allocateRegisters (pf)

	// Debug
	if self dump
		var sb : StringBuffer
		sb initialize
		sb << f << CodeUnit : 'lf
		sb << pf
		println (sb string)
		sb release
	end
	
	self prepareStack (pf)
	pf prepareVariables
	pf prepareParameters
	
	// The function becomes the current object	
	self currentObject = object
	
	// Initialize the stack pointer
	self stackPointer	= 0	
	
	// Reset unsolved labels
	self unsolvedLabels removeAll

	self beginObject (object, self textSection, align_byte)
	self initializeLineNumbers (line)
	self generateFunctionPrologue (pf)
	self generateInstructions (pf)
	self generateFunctionEpilogue (pf, cc)
	self resolveLabels
	self resolveExternLabels (pf, object)
	self endObject (object)

	pf object finalize (self debug, self firstLineOffset, self lineNumberCount, self firstLineNumber, self lastLineNumber)

end
//[cf]
//[of]:prepareStack
function prepareStack (pfunction: *PFunction)

	// Compute the size on stack to save register
	var n = stackOrigin
	// In debug mode, save the stack pointer into ebp
	if self debug
		n -= 4
	end
	var u = self usedRegisters
	if (u & 'ebx) <> 'none
		n -= 4
	end
	if (u & 'esi) <> 'none
		n -= 4
	end
	if (u & 'edi) <> 'none
		n -= 4
	end
	if (u & 'ebp) <> 'none
		n -= 4
	end

	// Save the offset
	self localPointer = n

end
//[cf]
//[of]:generateFunctionPrologue
//[c]Generates the function prologue
//[c]
//[c]	The prologue looks like
//[c]	
//[c]		push	ebp	; In debug mode only, ebp is not used
//[c]		mov	ebp, esp	;
//[c]		push	reg	; Save all registers used in this function (ebp, esi, edi, ebx)
//[c]		...		;
//[c]		mov	reg, [esp + nn]	; Load parameters into registers (if any)
//[c]		...		;
//[c]
function generateFunctionPrologue (pfunction: *PFunction)

	// In debug mode, save the stack pointer into ebp to help
	// the debugger showing the call stack
	if self debug
		// PUSH EBP
		self writeByte (0x50 + Register : 'ebp)
		self stackPointer -= 4
		// MOV EBP, ESP
		self writeModrm (Register : 'esp, 3, Register : 'ebp, 0x89)
	end

	var u = self usedRegisters
	if (u & 'ebx) <> 'none
		self writeByte (0x50 + Register : 'ebx)
		self stackPointer -= 4
	end
	if (u & 'esi) <> 'none
		self writeByte (0x50 + Register : 'esi)
		self stackPointer -= 4
	end
	if (u & 'edi) <> 'none
		self writeByte (0x50 + Register : 'edi)
		self stackPointer -= 4
	end
	if (u & 'ebp) <> 'none
		self writeByte (0x50 + Register : 'ebp)
		self stackPointer -= 4
	end
	
	self subEspImm (- pfunction localStackOffset)

	// Load parameters into registers if applicable
	pfunction parameters each do p
		if not p spilled and p interval notNil
			var rid = p interval register
			self movRegisterValue (rid registerValue, p value)
		end
	end

end
//[cf]
//[of]:generateFunctionEpilogue
//[c]Generates the function epilogue
//[c]
//[c]	The epilogue looks like
//[c]	
//[c]		pop	reg	; Save all registers used in this function (ebp, esi, edi, ebx)
//[c]		...		;
//[c]		pop	ebp	; In debug mode only, ebp is not used
//[c]		ret	<nn>	; Return and remove arguments from stack (if stdcall or fastcall)
//[c]
function generateFunctionEpilogue (pfunction: *PFunction, callingConvention: CallingConvention)

	if self debug
		// Get the relative line number of the last line number + 1
		var lineNumber	= (self lineNumber + 1 - self firstLineNumber) cast (Uint16)
		self addLineNumber (self virtualAddress, lineNumber)
	end
	
	// Free local variables
	self addEspImm (- pfunction localStackOffset)

	var u = self usedRegisters
	if (u & 'ebp) <> 'none
		self writeByte (0x58 + Register : 'ebp)
	end
	if (u & 'edi) <> 'none
		self writeByte (0x58 + Register : 'edi)
	end
	if (u & 'esi) <> 'none
		self writeByte (0x58 + Register : 'esi)
	end
	if (u & 'ebx) <> 'none
		self writeByte (0x58 + Register : 'ebx)
	end
	
	// In debug mode, save the stack pointer into ebp to help
	// the debugger showing the call stack
	if self debug
		// POP EBP
		self writeByte (0x58 + Register : 'ebp)
	end
	
	// RET NEAR
	if callingConvention == 'cdecl
		self writeByte (0xC3)
	else // stdcall, fastcall
		self writeByte (0xC2)
		self writeWord (pfunction parameterStackSize cast (Uint16))
	end

end
//[cf]
//[of]:generateInstructions
function generateInstructions (pfunction: *PFunction)

	pfunction instructions each do i
		self generateInstruction (i)
	end

end
//[cf]
//[of]:generateInstruction
function generateInstruction (instruction: *PInstruction)

	self locateInstruction (instruction)
	self loaded = 'none
	self storeInterval = nil
	
	switch instruction code
//[of]:	load
	case	'load, 
		'lda, 
		'ldc, 
		'ldd
	
		var i = instruction binary
		var value1 = i value1
		var value2 = i value2
		
		if value2 isX
			// mov rm, x
			var index = value2 index
			// Check if no scale and no offset (it is a simple addition)

			// Default : LEA R, [...]
			value1 = self reduceWriteR (value1)
			value2 = self reduceRM (value2)
			self movRegisterIndex (value1 register, value2 index)

		elsif value2 isI
			// mov rm, i
			value1 = self reduceRM (value1)
			self movValueValue (value1, value2)

		elsif value2 reduceableToRegister
			// mov rm, r
			value1 = self reduceRM (value1)
			value2 = self reduceReadR (value2)
			self movValueValue (value1, value2)
			
		else
			// mov r, rm
			var value1 = self reduceWriteR (i value1)
			var value2 = self reduceRM (i value2)
			self movRegisterValue (value1 register, value2)
		end
//[cf]
//[of]:	store
	case 'store
		var i = instruction binary
		var v1 = i value1
		var v2 = i value2
		
		if v2 isI
			// mov rm, i
			v1 = self reduceRM (v1)
			self movValueValue (v1, v2)

		elsif v1 reduceableToRegister
			// mov r, rm
			v1 = self reduceWriteR (v1)
			v2 = self reduceRM (v2)
			self movRegisterValue (v1 register, v2)
			
		else
			// mov rm, r
			v1 = self reduceRM (v1)
			v2 = self reduceReadR (v2)
			self movValueValue (v1, v2)
		end
//[cf]
//[of]:	truncate
	case 'truncate
	
		var i	= instruction binary
		var v1	= self reduceWriteR (i value1)
		var v2	= self reduceRM (i value2)
		var reg1	= v1 number

		switch v2 code
		case 'memory
			if v1 size == 'byte
				self writeMemory1 (v2 memory, reg1, 0x8A)
			else // 'word
				self writeMemory2 (v2 memory, reg1, 0x66, 0x8B)
			end
			
		case 'register
			var r : *PRegisterValue
			if v1 size == 'byte
				r = v2 register register8
			else
				r = v2 register register16
			end
			
			if r notNil
				self movRegisterRegister (v1, r)
			else
				self pushRegister (v2 register)
				self popRegister (v1)
			end
		else
			assertFailure ("truncate: invalid value", v2 code cast (Integer))
		end
//[cf]
//[of]:	movsx
	case 'movsx
		self generateExt (instruction binary, 0xBE)
//[cf]
//[of]:	movzx
	case 'movzx
		self generateExt (instruction binary, 0xB6)
//[cf]
//[of]:	cbw
	case 'cbw
		self writeByte (0x66)
		self writeByte (0x98)
//[cf]
//[of]:	cwd
	case 'cwd
		self writeByte (0x66)
		self writeByte (0x99)
//[cf]
//[of]:	cdq
	case 'cdq
		self writeByte (0x99)
//[cf]
//[of]:	add
	case 'add
		self generateOp (instruction binary, add_operation)
//[cf]
//[of]:	sub
	case 'sub
		self generateOp (instruction binary, sub_operation)
//[cf]
//[of]:	adc
	case 'adc
		self generateOp (instruction binary, adc_operation)
//[cf]
//[of]:	sbb
	case 'sbb
		self generateOp (instruction binary, sbb_operation)
//[cf]
//[of]:	smul
	case 'smul
		self generateScale (instruction unary, 5)
//[cf]
//[of]:	smul2
	case 'smul2
		var i	= instruction binary
		var v1	= self reduceReadWriteR (i value1)
		var v2	= self reduceRM (i value2)
		
		if v1 size == 'word
			self writeByte (0x66)
		end
		
		if v2 isI
			self writeRM (v1, v1 number, 0x69)
			self writeImmediate (v2)
		else
			self writeRM2 (v2, v1 number, 0x0F, 0xAF)
		end
//[cf]
//[of]:	smul3
	case 'smul3
		var i	= instruction ternary
		var v1	= self reduceWriteR (i value1)
		var v2	= self reduceRM (i value2)
		var v3	= i value3 // immediate value
		
		if v1 size == 'word
			self writeByte (0x66)
		end

		if v3 isInteger
			var nn = v3 integer dword
			if isShortDisplacement (nn)
				self writeRM (v2, v1 number, 0x6B)
				self writeByte (nn cast (Byte))
			else
				self writeRM (v2, v1 number, 0x69)
				self writeImmediate (v3)
			end
		else
			self writeRM (v2, v1 number, 0x69)
			self writeImmediate (v3)
		end
//[cf]
//[of]:	umul
	case 'umul
		self generateScale (instruction unary, 4)
//[cf]
//[of]:	sdiv
	case 'sdiv
		self generateScale (instruction unary, 7)
//[cf]
//[of]:	udiv
	case 'udiv
		self generateScale (instruction unary, 6)
//[cf]
//[of]:	shli
	case 'shli
		self generateShiftImm (instruction shift, 4)
//[cf]
//[of]:	sshri
	case 'sshri
		self generateShiftImm (instruction shift, 7)
//[cf]
//[of]:	ushri
	case 'ushri
		self generateShiftImm (instruction shift, 5)
//[cf]
//[of]:	shlc
	case 'shlc
		self generateShiftc (instruction shift, 4)
//[cf]
//[of]:	sshrc
	case 'sshrc
		self generateShiftc (instruction shift, 7)
//[cf]
//[of]:	ushrc
	case 'ushrc
		self generateShiftc (instruction shift, 5)
//[cf]
//[of]:	and
	case 'and
		self generateOp (instruction binary, and_operation)
//[cf]
//[of]:	or
	case 'or
		self generateOp (instruction binary, or_operation)
//[cf]
//[of]:	xor
	case 'xor
		self generateOp (instruction binary, xor_operation)
//[cf]
//[of]:	cmp
	case 'cmp
		var i = instruction binary
		var v1 = i value1
		var v2 = i value2
	
		if v2 isI
			// op rm, i
			v1 = self reduceRM (v1)
		elsif v2 reduceableToRegister
			// op rm, r
			v1 = self reduceRM (v1)
			v2 = self reduceReadR (v2)
		elsif v1 reduceableToRegister
			// op r, rm
			v1 = self reduceReadR (v1)
			v2 = self reduceRM (v2)
		elsif v2 code == 'interval
			// op rm, r
			v1 = self reduceRM (v1)
			v2 = self reduceReadR (v2)
		else
			// op r, rm
			v1 = self reduceReadR (v1)
			v2 = self reduceRM (v2)
		end
		self opValueValue (cmp_operation, v1, v2)
//[cf]
//[of]:	test
	case 'test
		var i	= instruction binary
		var v1 = self reduceRM (i value1)
		var v2 = i value2
	
		if v2 isI
			// test rm, i
			var opcode1 = Byte : 0xA8
			var opcode2 = Byte : 0xF6
			switch v1 size
			case 'word
				opcode1 ++
				opcode2 ++
				self writeByte (0x66)
			case 'dword
				opcode1 ++
				opcode2 ++
			end
			
			if v1 register isAccumulator
				// test accumulator, imm8
				self writeByte (opcode1)
			else
				// test rm, imm8
				self writeRM (v1, 0, opcode2)
			end
			self writeImmediate (v2)
		else
			// test rm, r
			var r2 = self reduceReadR (v2)
			
			// A common case is to test the variable with itself
			// let's use the same register in such a case
			if v2 code == 'interval and i value1 == v2 interval variable
				v1 = r2
			end

			var opcode = Byte : 0x84
			switch v1 size
			case 'word
				opcode ++
				self writeByte (0x66)
			case 'dword
				opcode ++
			end
			self writeRM (v1, r2 number, opcode)
		end
//[cf]
//[of]:	not
	case 'not
		self generateUnary (instruction unary, 2)
//[cf]
//[of]:	neg
	case 'neg
		self generateUnary (instruction unary, 3)
//[cf]
//[of]:	set
	case 'set
		var i	= instruction set
		var v	= self reduceRM (i value1)
		var c	= i condition code
	
		self writeRM2 (v, 0, 0x0F, c + 0x90)
//[cf]
//[of]:	push
	case 'push
		var i = instruction unary
		var v = self reduceRM (i value1)
		self pushValue (v)
//[cf]
//[of]:	pop
	case 'pop
		var i = instruction unary
		var v = self reduceRM (i value1)
		self popValue (v)
//[cf]
//[of]:	subsp
	case 'subsp
		var i = instruction stack
		self subEspImm (i offset)
//[cf]
//[of]:	label
	case 'label
		instruction label label offset = self writtenBytes
//[cf]
//[of]:	call
	case 'call
		var i	= instruction call
		var address = self reduceRM (i value1)
		
		switch address code
		case 'function
			self writeByte (0xE8)
			self writeRelative (address func pfunction object)
		case 'global
			self writeByte (0xE8)
			self writeRelativeReference (address glob symbol, address glob offset)
		case 'builtin
			self writeByte (0xE8)
			self writeRelative (address builtin object)
		case 'register, 'memory
			// call rm
			self writeRM (address, 2, 0xFF)
		else
			assertFailure ("call: invalid value")
		end
		
		if i callingConvention == 'cdecl
			// Restore the stack pointer (cdecl arguments and return values)
			self addEspImm (i argumentStackSize)
		else
			// Update the stack pointer
			self stackPointer += i argumentStackSize
		end
//[cf]
//[of]:	jumpi
	case 'jumpi
		var i = instruction unary
		var address = self reduceRM (i value1)

		switch address code
		case 'function
			self writeByte (0xE9)
			self writeRelative (address func pfunction object)
		case 'global
			self writeByte (0xE9)
			self writeRelativeReference (address glob symbol, address glob offset)
		case 'builtin
			self writeByte (0xE9)
			self writeRelative (address builtin object)
		case 'register, 'memory
			// jump rm
			self writeRM (address, 4, 0xFF)
		else
			assertFailure ("jump: invalid value")
		end
//[cf]
//[of]:	jump
	case 'jump
		var label = instruction jump label
		if not instruction isFollowedByLabel (label)
			self jump (label)
		end
//[cf]
//[of]:	jumpc
	case 'jumpc
		var i	= instruction jumpc
		self jcc (i condition code, i label)
//[cf]
	end

	var interval = self storeInterval
	if interval notNil
		self movMemoryRegister (interval variable value, interval register registerValue)
	end

end
//[cf]
//[of]:generateOp
function generateOp (i: *PBinaryInstruction, operation: *BinaryOperation)

	var v1 = i value1
	var v2 = i value2

	if v2 isI
		// op rm, i
		v1 = self reduceRM (v1)
	elsif v2 reduceableToRegister
		// op rm, r
		v1 = self reduceRM (v1)
		v2 = self reduceReadR (v2)
	elsif v1 reduceableToRegister
		// op r, rm
		v1 = self reduceReadWriteR (v1)
		v2 = self reduceRM (v2)
	elsif v2 code == 'interval
		// op rm, r
		v1 = self reduceRM (v1)
		v2 = self reduceReadR (v2)
	else
		// op r, rm
		v1 = self reduceReadWriteR (v1)
		v2 = self reduceRM (v2)
	end
	self opValueValue (operation, v1, v2)

end
//[cf]
//[of]:generateExt
function generateExt (i: *PBinaryInstruction, opcode: Byte)

	var v1	= self reduceWriteR (i value1)
	var v2	= self reduceRM (i value2)
	var reg1	= v1 number

	if v2 size == 'byte
		if v1 size == 'word
			self writeByte (0x66)
			self writeRM2 (v2, reg1, 0x0F, opcode)
		else // dword
			self writeRM2 (v2, reg1, 0x0F, opcode)
		end
	else // 'word
		self writeRM2 (v2, reg1, 0x0F, opcode + 1)
	end

end
//[cf]
//[of]:generateScale
function generateScale (i: *PUnaryInstruction, code: Byte)

	var v	= self reduceRM (i value1)
	switch v size
	case 'byte
		self writeRM (v, code, 0xF6)
	case 'word
		self writeRM2 (v, code, 0x66, 0xF7)
	else
		self writeRM (v, code, 0xF7)
	end

end
//[cf]
//[of]:generateShiftImm
function generateShiftImm (i: *PShiftInstruction, code: Byte)

	var value	= self reduceRM (i value1)
	var opcode = Byte : 0xC0
	switch value size
	case 'word
		opcode ++
		self writeByte (0x66)
	case 'dword
		opcode ++
	end
	
	var shift	= i shift
	if shift == 1
		// shift [x]
		self writeRM (value, code, opcode + 0x10)
	else
		// shift [x], imm8
		self writeRM (value, code, opcode)
		self writeByte (shift)
	end

end
//[cf]
//[of]:generateShiftc
function generateShiftc (i: *PUnaryInstruction, code: Byte)

	var value	= self reduceRM (i value1)
	var opcode = Byte : 0xD2
	switch value size
	case 'word
		opcode ++
		self writeByte (0x66)
	case 'dword
		opcode ++
	end

	self writeRM (value, code, opcode)

end
//[cf]
//[of]:generateUnary
function generateUnary (i: *PUnaryInstruction, code: Byte)

	var v	= self reduceRM (i value1)

	var opcode = Byte : 0xF6
	if v size == 'word
		opcode ++
		self writeByte (0x66)
	elsif v size == 'dword
		opcode ++
	end

	self writeRM (v, code, opcode)

end
//[cf]
//[of]:locateInstruction
function locateInstruction (pinstruction: *PInstruction)

	if self debug
		var line	= pinstruction line
		self lastLineNumber = line
		if line <> self lineNumber
			self lineNumber = line
			var lineNumber	= (line - self firstLineNumber) cast (Uint16)
			self addLineNumber (self virtualAddress, lineNumber)
		end
	end

end
//[cf]
//[of]:initializeLineNumbers
function initializeLineNumbers (line: LineNumber)

	self firstLineNumber	= line
	self lastLineNumber	= line

	if self debug
		self firstLineOffset	= self lineNumberOffset
		self lineNumber	= line
		self lineNumberCount	= 0
		self beginLineNumber (self currentObject)
	end

end
//[cf]
//[of]:resolveLabels
function resolveLabels

	self unsolvedLabels each do u
		var position	= u offset
		var address	= (self firstByte + position) cast (*Uinteger)
		address [] = u label relativeOffset (position)
	end

end
//[cf]
//[of]:resolveExternLabels
function resolveExternLabels (pfunction: *PFunction, object: *ObjectData)

	pfunction references each do reference
		// Patch the reference with the distance between the label and 
		// the beginning of the function
		var p = (reference object buffer + reference offset) cast (*Uinteger)
		p [] = reference label offset
	
		// Add a relocation
		self dataSection addDirectRelocation (reference object, reference offset, object symbol)
	end

end
//[cf]
//[cf]
//[of]:	register allocation
//[of]:allocateRegisters
//[c]Allocate registers for local variables and parameters
//[c]
function allocateRegisters (pfunction: *PFunction)

	// Free all registers
	self registers = 'none
	self usedRegisters = 'none

	// In debug mode, ebp is used to point to the stack frame
	// so it can not be used
	if self debug
		self registers |= 'ebp
		self usedRegisters |= 'ebp
	end

	// Initialize the list of actives
	self activeFirst = 0
	self activeSize = 0

	// Allocate a register for the parameter if the parameter
	// is referenced at least 3 times (there is a cost of using a
	// register for arguments: push, pop and initial mov).
	// Otherwise the parameter is spilled: it will be read from
	// the stack when needed.
	pfunction parameters each do p
		if p referenceCount >= 3
			self lockedRegisters = 'none
			self instruction = pfunction instructions firstElement
			self allocateRegister (p)
		else
			p spilled = true
		end
	end
	
	// Scan all instructions
	var index = InstructionIndex : 0
	pfunction instructions each do instr
	
		// Save the current instruction for the allocation
		self instruction = instr
		
		// Lock registers for this instruction:
		// Registers that are read in this instruction must be preserved
		self lockedRegisters = 'none
		self lock (instr)
		
		// Allocate registers for all read values
		self allocateRead (instr)
		
		// Advance the index before processing
		// the write-only values
		index ++
		
		// Expire old intervals
		var i	= self activeFirst
		var n	= self activeSize
		while i < n
			var v	= self actives [i]
			var last	= v lastIndex
			if last >= index
				break
			end
			self freeRegister (v)
			i ++
		end
		self activeFirst = i

		// Spill scratch registers here
		var scratched = instruction_registers [instr code] downcast (RegisterMask)
		if (scratched & self registers) <> 'none
			self spillRegisters (scratched)
		end
		
		// We can now spill a register for the write only part if needed
		self lockedRegisters = 'none
		
		// Allocate registers for all defines
		self allocateWrite (instr)
	end

end
//[cf]
//[of]:lock
function lock (instruction: *PInstruction)

	switch instruction code
	
	case	'load, 'lda, 'ldd, 'ldc, 'store, 'truncate, 'movsx, 'movzx
	
		var i = instruction binary
		self lockWrite (i value1)
		self lockRead (i value2)
	
	case	'add, 'sub, 'adc, 'sbb, 'smul2, 'and, 'or, 'xor, 'cmp, 'test
	
		var i = instruction binary
		self lockRead (i value1)
		self lockRead (i value2)
	
	case	'smul, 'umul, 'sdiv, 'udiv,
		'not, 'neg, 
		'push, 'pop,
		'shli, 'sshri, 'ushri, 'shlc, 'sshrc, 'ushrc,
		'call, 'jumpi
	
		var i = instruction unary
		self lockRead (i value1)

	case	'set
	
		var i = instruction unary
		self lockWrite (i value1)

	case 'smul3

		var i = instruction ternary
		self lockWrite (i value1)
		self lockRead (i value2)
		self lockRead (i value3)
	end

end
//[cf]
//[of]:lockRead
function lockRead (value: *PValue) :

	switch value code
	case 'memory
		self lockRead (value memory address)
	case 'index
		var base = value index base
		if base notNil
			self lockRead (base)
		end
		var index = value index index
		if index notNil
			self lockRead (index)
		end
	case 'variable, 'parameter
		var v = value variable
		if v interval notNil
			self lockedRegisters |= v interval register mask
		end
	end

end
//[cf]
//[of]:lockWrite
function lockWrite (value: *PValue)

	switch value code
	case 'memory
		self lockRead (value memory address)
	case 'index
		var base = value index base
		if base notNil
			self lockRead (base)
		end
		var index = value index index
		if index notNil
			self lockRead (index)
		end
	end

end
//[cf]
//[of]:allocateRead
//[c]Allocates a register in a read or read/write access
//[c]
function allocateRead (instruction: *PInstruction)

	switch instruction code

	// load	r, rmix
	// truncate	r, rm
	// movsx	r, rm
	// movzx	r, rm
	case 'load, 'lda, 'ldd, 'ldc, 'truncate, 'movsx, 'movzx
	
		var i = instruction binary
		i value1 = self allocateReadD (i value1)
		i value2 = self allocateReadRM (i value2)
	
	// store rm, ri
	case 'store
	
		var i = instruction binary
		i value1 = self allocateReadD (i value1)
		i value2 = self allocateReadR (i value2)
	
	// op r, rmi
	// op rm, ri
	case	'add, 'sub, 'adc, 'sbb, 'and, 'or, 'xor, 'cmp
	
		var i = instruction binary
		if i value1 isR
			i value1 = self allocateReadR (i value1)
			i value2 = self allocateReadRM (i value2)
		else
			i value1 = self allocateReadRM (i value1)
			i value2 = self allocateReadR (i value2)
		end
	
	// smul r, rmi
	case	'smul2
	
		var i = instruction binary
		i value1 = self allocateReadR (i value1)
		i value2 = self allocateReadRM (i value2)

	// smul r, rm, i
	case	'smul3
	
		var i = instruction binary
		i value1 = self allocateReadD (i value1)
		i value2 = self allocateReadRM (i value2)

	// test rm, ri
	case	'test
	
		var i = instruction binary
		i value1 = self allocateReadRM (i value1)
		i value2 = self allocateReadR (i value2)

	// op rm
	case	'smul, 'umul, 'sdiv, 'udiv,
		'not, 'neg, 
		'push, 'pop,
		'shli, 'sshri, 'ushri, 'shlc, 'sshrc, 'ushrc,
		'call, 'jumpi
	
		var i = instruction unary
		i value1 = self allocateReadRM (i value1)

	// set rm
	case	'set
	
		var i = instruction unary
		i value1 = self allocateReadD (i value1)
	end

end
//[cf]
//[of]:allocateReadR
function allocateReadR (value: *PValue) : *PValue

	switch value code
	case 'memory
		var m = value memory
		m address = self allocateReadR (m address)
	case 'index
		var i = value index
		var base = i base
		if base notNil
			i base = self allocateReadR (base)
		end
		var index = i index
		if index notNil
			i index = self allocateReadR (index)
		end
	case 'variable, 'parameter
		var v = value variable
		
		// Use the existing interval if any
		if v interval notNil
			return v interval
		end
		
		// Allocate a register
		return self allocateRegister (v)
	end
	return value

end
//[cf]
//[of]:allocateReadRM
function allocateReadRM (value: *PValue)

	switch value code
	case 'memory
		var m = value memory
		m address = self allocateReadR (m address)
	case 'index
		var i = value index
		var base = i base
		if base notNil
			i base = self allocateReadR (base)
		end
		var index = i index
		if index notNil
			i index = self allocateReadR (index)
		end
	case 'variable, 'parameter
		var v = value variable
		
		// Spilled and rm : we can skip allocation
		if v spilled
			return v
		end
			
		// Use the existing interval if any
		if v interval notNil
			return v interval
		end
		
		// Allocate a register
		return self allocateRegister (v)
	end
	return value

end
//[cf]
//[of]:allocateReadD
function allocateReadD (value: *PValue)

	switch value code
	case 'memory
		var m = value memory
		m address = self allocateReadR (m address)
	end
	return value

end
//[cf]
//[of]:allocateWrite
//[c]Allocates a register in a write access
//[c]
//[c]	The read and read/write have already been processed :
//[c]	- the source operand
//[c]	- the target operand when the target is also read (add, sub, ...)
//[c]	- the base and index value of the target operand (it is always a read access)
//[c]	
//[c]	Only the target operand of movs to a register are still concerned.
//[c]	
function allocateWrite (instruction: *PInstruction)

	switch instruction code
	// load	r, rmix
	// truncate	r, rm
	// movsx	r, rm
	// movzx	r, rm
	case 'load, 'lda, 'ldd, 'ldc, 'truncate, 'movsx, 'movzx
	
		var i = instruction binary
		i value1 = self allocateWriteR (i value1)
	
	// store rm, ri
	case 'store
	
		var i = instruction binary
		i value1 = self allocateWriteRM (i value1)

	// smul r, rm, i
	case 'smul3
	
		var i = instruction ternary
		i value1 = self allocateWriteR (i value1)

	// set rm
	case 'set
	
		var i = instruction unary
		i value1 = self allocateWriteRM (i value1)
	end

end
//[cf]
//[of]:allocateWriteR
function allocateWriteR (value: *PValue)

	if value code <> 'variable
		return value
	end
	
	var v = value variable
	
	// Use the existing interval if any
	if v interval notNil
		return v interval
	end
		
	// Allocate a register
	return self allocateRegister (v)

end
//[cf]
//[of]:allocateWriteRM
function allocateWriteRM (value: *PValue)

	if value code <> 'variable
		return value
	end
	
	var v = value variable
	
	// Spilled and rm : we can skip allocation and use the [esp + k] value instead
	if v spilled
		return v
	end
		
	// Use the existing interval if any
	if v interval notNil
		return v interval
	end
		
	// Allocate a register
	return self allocateRegister (v)

end
//[cf]
//[of]:allocateRegister
function allocateRegister (variable: *PVariable)

	var rid = self getFreeRegister (variable)
	if rid == 'none
		return self spillAtInterval (variable)
	else
		return self createInterval (variable, rid)
	end

end
//[cf]

//[of]:spillAtInterval
//[c]The variable 'steals' the register of the last active variable
//[c]
//[c]	This algorithm is a bit more complex than the linear scan as there
//[c]	is constraints on size of registers: the last active variable may not be 
//[c]	compatible with the new variable so we search other candidates
//[c]	in the stack of active variables.
//[c]
function spillAtInterval (variable: *PVariable)

	// Scan all active variables (i.e. variables having a register)
	// from the last to die to the first
	var index	= self activeSize
	var first = self activeFirst
	while index <> first
		index --
		var spill	= self actives [index]
		var rid = spill interval register
		// Never spill a locked register
		if (rid mask & self lockedRegisters) == 'none
			if variable size == spill size
				// 'spill' moved to stack
				spill spilled = true
				spill interval = nil
				
				// Remove spill from the list of actives
				var lastIndex = self activeSize - 1
				while index <> lastIndex
					self actives [index] = self actives [index + 1]
					index ++
				end
				self activeSize --
				return self createInterval (variable, rid)
			else
				// Try with size conversion
				rid = rid_convert_table [rid cast (Uinteger) * 3 + variable size cast (Uinteger)]
				if rid <> 'none
					self spillRegisters (rid mask)
					return self createInterval (variable, rid)
				end
			end
		end
	end

	// No candidate found: try any unlocked register
	var rid = self getUnlockedRegister (variable size)
	if rid <> 'none
		// Spill all registers that intersects with this one
		self spillRegisters (rid mask)
		return self createInterval (variable, rid)
	end

	// Internal error: there is not enough register
	assertFailure ("There is not enough register")
	return nil

end

static const rid_convert_table = *[]RegisterId : {
	'al,	// 'al	byte
	'ax,	// 'al	word
	'eax,	// 'al	dword
			
	'ah,	// 'ah	byte
	'ax,	// 'ah	word
	'eax,	// 'ah	dword
			
	'bl,	// 'bl	byte
	'bx,	// 'bl	word
	'ebx,	// 'bl	dword
			
	'bh,	// 'bh	byte
	'bx,	// 'bh	word
	'ebx,	// 'bh	dword
			
	'cl,	// 'cl	byte
	'cx,	// 'cl	word
	'ecx,	// 'cl	dword
			
	'ch,	// 'ch	byte
	'cx,	// 'ch	word
	'ecx,	// 'ch	dword
			
	'dl,	// 'dl	byte
	'dx,	// 'dl	word
	'edx,	// 'dl	dword
			
	'dh,	// 'dh	byte
	'dx,	// 'dh	word
	'edx,	// 'dh	dword
			
	'al,	// 'ax	byte
	'ax,	// 'ax	word
	'eax,	// 'ax	dword
			
	'bl,	// 'bx	byte
	'bx,	// 'bx	word
	'ebx,	// 'bx	dword
			
	'cl,	// 'cx	byte
	'cx,	// 'cx	word
	'ecx,	// 'cx	dword
			
	'dl,	// 'dx	byte
	'dx,	// 'dx	word
	'edx,	// 'dx	dword
			
	'none,	// 'si	byte
	'si,	// 'si	word
	'esi,	// 'si	dword
			
	'none,	// 'di	byte
	'di,	// 'di	word
	'edi,	// 'di	dword
			
	'none,	// 'bp	byte
	'bp,	// 'bp	word
	'ebp,	// 'bp	dword
			
	'al,	// 'eax	byte
	'ax,	// 'eax	word
	'eax,	// 'eax	dword
			
	'bl,	// 'ebx	byte
	'bx,	// 'ebx	word
	'ebx,	// 'ebx	dword
			
	'cl,	// 'ecx	byte
	'cx,	// 'ecx	word
	'ecx,	// 'ecx	dword
			
	'dl,	// 'edx	byte
	'dx,	// 'edx	word
	'edx,	// 'edx	dword
			
	'none,	// 'esi	byte
	'si,	// 'esi	word
	'esi,	// 'esi	dword
			
	'none,	// 'edi	byte
	'di,	// 'edi	word
	'edi,	// 'edi	dword
			
	'none,	// 'ebp	byte
	'bp,	// 'ebp	word
	'ebp}	// 'ebp	dword
//[cf]
//[of]:spillRegisters
//[c]If there are active variables using registers that are going to be scratched, 
//[c]the associated variable(s) must be flagged as spilled and removed from 
//[c]the list of actives.
//[c]
//[c]ARGUMENTS
//[c]	scratched	--	the mask of registers being scratched
//[c]
function spillRegisters (scratched: RegisterMask)

	// i is the index of the next active to scan, 
	// j is the write index, so the algorithm is linear
	var i	= self activeFirst
	var j = i
	var n	= self activeSize
	while i < n
		var v	= self actives [i]
		var rid = v interval register
		if (rid mask & scratched) <> 'none
			self registers &= rid clearMask
			v spilled = true
			v interval = nil
		else
			if i <> j
				self actives [j] = v
			end
			j ++
		end
		i ++
	end
	self activeSize = j

end
//[cf]
//[of]:insertToActives
function insertToActives (pvariable: *PVariable)

	var i	= self activeSize
	var first	= self activeFirst
	var actives	= self actives
	while i > first
		var v = actives [i - 1]
		if pvariable lastIndex >= v lastIndex
			break
		end
		actives [i] = v
		i --
	end
	actives [i] = pvariable
	self activeSize ++

end
//[cf]
//[of]:getFreeRegister
//[c]Finds a free register
//[c]
//[c]RETURN VALUES
//[c]	The register or 'none.
//[c]	
function getFreeRegister (variable: *PVariable) : RegisterId

	const short_range = InstructionIndex : 10

	var size	= variable size
	var r	= self registers
	var range	= variable lastIndex - variable firstIndex + 1
	switch size
	case 'byte
		// If it is a short range and one register of al, ah, dl, dh, cl, ch is available
		// we can try to use it (it requires a scan of the next instructions)
		if range < short_range and (r & ('ax|'dx|'cx)) <> ('ax|'dx|'cx)
			r |= self scanRegisters (range)
			if (r & 'al) == 'none
				return 'al
			elsif (r & 'ah) == 'none
				return 'ah
			elsif (r & 'dl) == 'none
				return 'dl
			elsif (r & 'dh) == 'none
				return 'dh
			elsif (r & 'cl) == 'none
				return 'cl
			elsif (r & 'ch) == 'none
				return 'ch
			end
		end
		if (r & 'bl) == 'none
			return 'bl
		elsif (r & 'bh) == 'none
			return 'bh
		end
	case 'word
		// If it is a short range and one register of ax, dx, cx is available
		// we can try to use it (it requires a scan of the next instructions)
		if range < short_range and (r & ('ax|'dx|'cx)) <> ('ax|'dx|'cx)
			r |= self scanRegisters (range)
			if (r & 'ax) == 'none
				return 'ax
			elsif (r & 'dx) == 'none
				return 'dx
			elsif (r & 'cx) == 'none
				return 'cx
			end
		end
		if (r & 'si) == 'none
			return 'si
		elsif (r & 'di) == 'none
			return 'di
		elsif (r & 'bp) == 'none
			return 'bp
		elsif (r & 'bx) == 'none
			return 'bx
		end
	case 'dword
		// If it is a short range and one register of eax, edx, ecx is available
		// we can try to use it (it requires a scan of the next instructions)
		if range < short_range and (r & ('eax|'edx|'ecx)) <> ('eax|'edx|'ecx)
			r |= self scanRegisters (range)
			if (r & 'eax) == 'none
				return 'eax
			elsif (r & 'edx) == 'none
				return 'edx
			elsif (r & 'ecx) == 'none
				return 'ecx
			end
		end
		if (r & 'esi) == 'none
			return 'esi
		elsif (r & 'edi) == 'none
			return 'edi
		elsif (r & 'ebp) == 'none
			return 'ebp
		elsif (r & 'ebx) == 'none
			return 'ebx
		end
	end
	
	return 'none

end
//[cf]
//[of]:getUnlockedRegister
//[c]Finds an unlocked register.
//[c]
//[c]RETURN VALUES
//[c]	The register or 'none.
//[c]	
function getUnlockedRegister (size: PValueSize) : RegisterId

	var r	= self lockedRegisters
	switch size
	case 'byte
		if (r & 'bl) == 'none
			return 'bl
		elsif (r & 'bh) == 'none
			return 'bh
		elsif (r & 'al) == 'none
			return 'al
		elsif (r & 'ah) == 'none
			return 'ah
		elsif (r & 'dl) == 'none
			return 'dl
		elsif (r & 'dh) == 'none
			return 'dh
		elsif (r & 'cl) == 'none
			return 'cl
		elsif (r & 'ch) == 'none
			return 'ch
		end
	case 'word
		if (r & 'si) == 'none
			return 'si
		elsif (r & 'di) == 'none
			return 'di
		elsif (r & 'bp) == 'none
			return 'bp
		elsif (r & 'bx) == 'none
			return 'bx
		elsif (r & 'ax) == 'none
			return 'ax
		elsif (r & 'dx) == 'none
			return 'dx
		elsif (r & 'cx) == 'none
			return 'cx
		end
	case 'dword
		if (r & 'esi) == 'none
			return 'esi
		elsif (r & 'edi) == 'none
			return 'edi
		elsif (r & 'ebp) == 'none
			return 'ebp
		elsif (r & 'ebx) == 'none
			return 'ebx
		elsif (r & 'eax) == 'none
			return 'eax
		elsif (r & 'edx) == 'none
			return 'edx
		elsif (r & 'ecx) == 'none
			return 'ecx
		end
	end
	
	return 'none

end
//[cf]
//[of]:freeRegister
function freeRegister (variable: *PVariable)

	var interval = variable interval
	self registers &= interval register clearMask
	
	// This instruction is useless as we are not accessing the interval from 
	// the variable anymore.
	//variable interval = nil

end
//[cf]
//[of]:scanRegisters
//[c]Scans the next instruction in a short range to check if the register is used or not
//[c]
function scanRegisters (range: Uinteger)

	var i = self instruction
	var n = range
	var uses = RegisterMask : 'none
	while i notNil and n > 0
		uses |=  instruction_registers [i code]
		i = i nextSibling
		n --
	end
	return uses

end
//[cf]
//[of]:createInterval
function createInterval (variable: *PVariable, rid: RegisterId)

	var interval = self fpool new (PIntervalValue, variable, rid)
	variable interval = interval

	var mask = rid mask
	self lockedRegisters	|= mask
	self registers	|= mask
	self usedRegisters	|= mask
	
	self insertToActives (variable)

	return interval

end
//[cf]
//[cf]
//[of]:	utils
//[of]:allocate
function allocate (size: Integer)
	return self pool allocateArray (Byte, size)
end
//[cf]
//[of]:fpool
//[c]Returns the pool for data needed only when generating a function
//[c]
function fpool
	return self pool
end
//[cf]
//[of]:reduceRM
//[c]Reduces the value to have something compatible with rmi (register, memory 
//[c]or immediate)
//[c]
function reduceRM (value: *PValue)

	switch value code
	case 'memory
		// IMPORTANT: we assume here that a memory value is never shared
		// between instructions as we are doing in-place reductions.
		//
		// Memory values are re-used in intervals but they won't be processed 
		// here (they are already reduced).
		// 
		var address = value memory address
		if address code == 'index
			var i = address index
			if i base notNil
				i base = self reduceReadR (i base)
			end
			if i index notNil
				i index = self reduceReadR (i index)
			end
		elsif address code == 'interval
			var i = address interval
			value memory address = self reduceReadR (i)
		end
		return value

	case 'index
		// IMPORTANT: we assume here that an index value is never shared
		// between instructions as we are doing in-place reductions.
		//
		// Index values are re-used in intervals but they won't be processed 
		// here (they are already reduced).
		// 
		var i = value index
		if i base notNil
			i base = self reduceReadR (i base)
		end
		if i index notNil
			i index = self reduceReadR (i index)
		end
		return value

	case 'interval
		var i = value interval
		var variable = i variable
		if variable spilled
			return i variable value
		end
		return i register registerValue

	case 'variable, 'parameter
		return value variable value

	else
		return value
	end

end
//[cf]
//[of]:reduceReadR
//[c]Reduces a read value to have something compatible with a register
//[c]
//[c]REMARKS
//[c]	There can not be a variable or parameter value here, it should
//[c]	have been transformed to an interval as a register is required.
//[c]
function reduceReadR (value: *PValue)

	switch value code
	case 'register
		return value register
	case 'interval
		var i = value interval
		var variable = i variable
		if variable spilled
			var mask = i register mask
			if (self loaded & mask) == 'none
				self movRegisterValue (i register registerValue, variable value)
				self loaded |= mask
			end
		end
		return i register registerValue
	else
		assertFailure ("reduceReadR: invalid value")
		return nil
	end

end
//[cf]
//[of]:reduceReadWriteR
//[c]Reduces a read/write value to have something compatible with a register
//[c]
//[c]REMARKS
//[c]	There can not be a variable or parameter value here, it should
//[c]	have been transformed to an interval as a register is required.
//[c]
function reduceReadWriteR (value: *PValue)

	switch value code
	case 'register
		return value register
	case 'interval
		var i = value interval
		var variable = i variable
		if variable spilled
			var mask = i register mask
			if (self loaded & mask) == 'none
				self movRegisterValue (i register registerValue, variable value)
				self loaded |= mask
			end
			self storeInterval = i
		end
		return i register registerValue
	else
		assertFailure ("reduceReadWriteR: invalid value")
		return nil
	end

end
//[cf]
//[of]:reduceWriteR
function reduceWriteR (value: *PValue)

	switch value code
	case 'register
		return value register
	case 'interval
		var i = value interval
		var variable = i variable
		if variable spilled
			self storeInterval = i
		end
		return i register registerValue
	else
		assertFailure ("reduceWriteR: invalid value")
		return nil
	end
	
end
//[cf]
//[cf]
//[of]:	line number
//[of]:lineNumberOffset
function lineNumberOffset
	return self textSection lineNumberOffset
end
//[cf]
//[of]:beginLineNumber
function beginLineNumber (object: *ObjectData)

	self textSection beginLineNumber (object)
	self lineNumberCount	++

end
//[cf]
//[of]:addLineNumber
function addLineNumber (address: Uinteger, line: Uint16)

	self textSection addLineNumber (address, line)
	self lineNumberCount	++

end
//[cf]
//[cf]
	
//[of]:	jmp
//[of]:jump
function jump (label: *PLabel)

	if label isDefined
		var position = self writtenBytes + 2
		var offset = label offset - position
		if offset >= 0 - 128
			// JMP rel8
			self writeByte (0xEB)
			self writeByte (offset cast (Byte))
			return
		end
	end
	
	// JMP rel32
	self writeByte (0xE9)
	self writeLabel (label)

end
//[cf]
//[of]:jcc
function jcc (condition: Byte, label: *PLabel)

	if label isDefined
		var position = self writtenBytes + 2
		var offset = label offset - position
		if offset >= 0 - 128
			self writeByte (condition + 0x70)
			self writeByte (offset cast (Byte))
			return
		end
	end

	// Jcc rel32
	self writeByte (0x0F)
	self writeByte (condition + 0x80)
	self writeLabel (label)	

end
//[cf]
//[cf]
//[of]:	mov
//[of]:movValueValue
function movValueValue (	left	: *PValue,
	right	: *PValue )

	switch left code
	case 'register
		self movRegisterValue (left register, right)
	case 'memory
		self movMemoryValue (left memory, right)
	else
		assertFailure ("mov: invalid left value")
	end

end
//[cf]
//[of]:movRegisterValue
function movRegisterValue (left: *PRegisterValue, right: *PValue)

	switch right code
	case 'register
		self movRegisterRegister (left, right register)
	case 'integer
		self movRegisterInteger (left, right integer)
	case 'memory
		self movRegisterMemory (left, right memory)
	case 'index
		self movRegisterIndex (left, right index)
	case 'undefined
		// Do nothing: moving an undefined value into a register
		// does not require any instruction.
	case 'global, 'function, 'builtin
		// MOV r32, imm32
		self writeByte (left number + 0xB8)
		self writeImmediate (right)
	else
		assertFailure ("mov reg value: unknown value", right code cast (Integer))
	end

end
//[cf]
//[of]:movRegisterRegister
function movRegisterRegister (left: *PRegisterValue, right: *PRegisterValue)

	var registerSrc	= right number
	var register	= left number
	
	// Nothing to do if src is same as dst
	if registerSrc == register
		return
	end
	
	switch left size
	case 'byte
		// MOV r8, r8
		self writeModrm (registerSrc, 3, register, 0x88)
	case 'word
		// MOV r16, r16
		self writeModrm2 (registerSrc, 3, register, 0x66, 0x89)
	else // 'dword
		// MOV r32, r32
		self writeModrm (registerSrc, 3, register, 0x89)
	end

end
//[cf]
//[of]:movRegisterInteger
function movRegisterInteger (left: *PRegisterValue, constant: *PIntegerValue)

	var register = left number
	
	if constant isNull
		switch constant size
		case 'byte
			// XOR r8, r8
			self writeModrm (register, 3, register, 0x32)
		case 'word
			// XOR r16, r16
			self writeModrm2 (register, 3, register, 0x66, 0x33)
		else // 'dword
			// XOR r32, r32
			self writeModrm (register, 3, register, 0x33)
		end
	else
		switch constant size
		case 'byte
			// MOV r8, imm32
			self writeByte (register + 0xB0)
			self write (constant byte)
		case 'word
			// MOV r16, imm32
			self writeByte (0x66)
			self writeByte (register + 0xB8)
			self write (constant word)
		else // 'dword
			// MOV r32, imm32
			self writeByte (register + 0xB8)
			self write (constant dword)
		end
	end

end
//[cf]
//[of]:movRegisterMemory
function movRegisterMemory (left: *PRegisterValue, value: *PMemoryValue )

	var register = left number
	
	switch value size
	case 'byte
		self writeMemory1 (value, register, 0x8A)
	case 'word
		self writeMemory2 (value, register, 0x66, 0x8B)
	else // 'dword
		self writeMemory1 (value, register, 0x8B)
	end

end
//[cf]
//[of]:movRegisterIndex
function movRegisterIndex (left: *PRegisterValue, right: *PIndexValue)

	var i	= right index register
	var b	= right base register
	var offset	= right offset
	
	// Translate base to esp
	if b == 'base
		offset	-= self stackPointer
		b = 'esp
	// Translate local to esp
	elsif b == 'local
		offset += self localPointer
		offset	-= self stackPointer
		b = 'esp
	end

	if i isNil
		// add register, offset
		if left == b
			var i : PIntegerValue
			i code = 'integer
			i size = 'dword
			i value = offset cast (Uint64)
			self addRI32 (add_operation, left, i)
			return
		end
		
		// Simple mov
		if offset == 0
			self movRegisterRegister (left, b)
			return
		end
	end
	
	if right scale == 1 and offset == 0
		if left == b
			if i notNil
				// add left, index
				self opValueValue (add_operation, left, i)
			end
			return
		end
		if left == i
			if b notNil
				// add left, base
				self opValueValue (add_operation, left, b)
			end
			return
		end
	end
	
	var info : MemoryInfo
	self getMemory (right, info)
	self writeByte (0x8D)
	self writeMemoryInfo (info, left number)

end
//[cf]
//[of]:movMemoryValue
function movMemoryValue (	left	: *PMemoryValue,
	right	: *PValue )

	switch right code
	case 'register
		self movMemoryRegister (left, right register)
	case 'integer
		self movMemoryInteger (left, right integer)
	case 'undefined
		// Do nothing
	case 'global, 'function, 'builtin
		// MOV [addr], imm32
		self writeMemory1 (left, 0, 0xC7)
		self writeImmediate (right)
	else
		assertFailure ("mov memory value: invalide value")
	end

end
//[cf]
//[of]:movMemoryInteger
function movMemoryInteger (	value	: *PMemoryValue,
	constant	: *PIntegerValue )

	switch value size
	case 'byte
		self writeMemory1 (value, 0, 0xC6)
		self writeByte (constant byte)
	case 'word
		self writeMemory2 (value, 0, 0x66, 0xC7)
		self write (constant word)
	case 'dword
		self writeMemory1 (value, 0, 0xC7)
		self write (constant dword)
	end

end
//[cf]
//[of]:movMemoryRegister
function movMemoryRegister (	left	: *PMemoryValue,
	right	: *PRegisterValue)

	switch left size
	case 'byte
		self writeMemory1 (left, right number, 0x88)
	case 'word
		self writeMemory2 (left, right number, 0x66, 0x89)
	else // 'dword
		self writeMemory1 (left, right number, 0x89)
	end

end
//[cf]
//[cf]
//[of]:	binary operations
//[of]:opValueValue
//[c]Functions Suffix Conventions
//[c]
//[c]	R	- register value
//[c]	X	- register or memory value
//[c]	I	- immediate value
//[c]
function opValueValue (op: *BinaryOperation, left: *PValue, right: *PValue)
	op call (self, left, right)
end
//[cf]
//[of]:opRX
function opRX8 (op: *BinaryOperation, left: *PRegisterValue, right: *PValue)
	self writeRM (right, left number, op regRm)
end

function opRX16 (op: *BinaryOperation, left: *PRegisterValue, right: *PValue)
	self writeRM2 (right, left number, 0x66, op regRm + 1)
end

function opRX32 (op: *BinaryOperation, left: *PRegisterValue, right: *PValue)
	self writeRM (right, left number, op regRm + 1)
end
//[cf]
//[of]:opRI
function opRI8 (op: *BinaryOperation, left: *PRegisterValue, right: *PValue)

	if right isInteger
		if left == 'al
			// op AL, imm8
			self writeByte (op accImm)
			self writeByte (right integer byte)
		else
			// op r8, imm8
			self writeModrm (op rmImmm, 3, left number, op rmImm)
			self writeByte (right integer byte)
		end
	else
		// op r8, imm8
		self writeModrm (op rmImmm, 3, left number, op rmImm)
		self writeImmediate (right)
	end

end

function opRI16 (op: *BinaryOperation, left: *PRegisterValue, right: *PValue)

	if right isInteger
		var nn = right integer word
		if isShortDisplacement (nn)
			// op r16, imm8
			self writeModrm2 (op rmImmm, 3, left number, 0x66, op rmImm + 3)
			self writeByte (nn cast (Byte))
		else
			if left == 'ax
				// op AX, imm16
				self writeByte (0x66)
				self writeByte (op accImm + 1)
			else
				// op r16, imm16
				self writeModrm2 (op rmImmm, 3, left number, 0x66, op rmImm + 1)
			end
			self write (nn)
		end
	else
		// op r16, imm16
		self writeModrm2 (op rmImmm, 3, left number, 0x66, op rmImm + 1)
		self writeImmediate (right)
	end

end

function opRI32 (op: *BinaryOperation, left: *PRegisterValue, right: *PValue)

	if right isInteger
		var nn = right integer dword
		if isShortDisplacement (nn)
			// op r32, imm8
			self writeModrm (op rmImmm, 3, left number, op rmImm + 3)
			self writeByte (nn cast (Byte))
		else
			if left == 'eax
				// op EAX, imm32
				self writeByte (op accImm + 1)
			else
				// op r32, imm32
				self writeModrm (op rmImmm, 3, left number, op rmImm + 1)
			end
			self write (nn)
		end
	else
		// op r32, imm32
		self writeModrm (op rmImmm, 3, left number, op rmImm + 1)
		self writeImmediate (right)
	end

end
//[cf]
//[of]:opXR
function opXR8 (op: *BinaryOperation, left: *PValue, right: *PRegisterValue)
	self writeRM (left, right number, op rmReg)
end

function opXR16 (op: *BinaryOperation, left: *PValue, right: *PRegisterValue)
	self writeRM2 (left, right number, 0x66, op rmReg + 1)
end

function opXR32 (op: *BinaryOperation, left: *PValue, right: *PRegisterValue)
	self writeRM (left, right number, op rmReg + 1)
end
//[cf]
//[of]:opXI
function opXI8 (op: *BinaryOperation, left: *PValue, right: *PValue)

	self writeRM (left, op rmImmm, op rmImm)
	self writeImmediate (right)

end

function opXI16 (op: *BinaryOperation, left: *PValue, right: *PValue)

	if right isInteger
		var nn = right integer word
		if isShortDisplacement (nn)
			// op word ptr [x], imm8
			self writeRM2 (left, op rmImmm, 0x66, op rmImm + 3)
			self writeByte (nn cast (Byte))
		else
			// op word ptr [x], imm16
			self writeRM2 (left, op rmImmm, 0x66, op rmImm + 1)
			self writeWord (nn)
		end
	else
		self writeRM2 (left, op rmImmm, 0x66, op rmImm + 1)
		self writeImmediate (right)
	end

end

function opXI32 (op: *BinaryOperation, left: *PValue, right: *PValue)

	if right isInteger
		var nn = right integer dword
		if isShortDisplacement (nn)
			// op dword ptr [x], imm8
			self writeRM (left, op rmImmm, op rmImm + 3)
			self writeByte (nn cast (Byte))
		else
			// op dword ptr [x], imm32
			self writeRM (left, op rmImmm, op rmImm + 1)
			self writeDword (nn)
		end
	else
		self writeRM (left, op rmImmm, op rmImm + 1)
		self writeImmediate (right)
	end

end
//[cf]
//[of]:addRI
function .public addRI8 (op: *BinaryOperation, left: *PRegisterValue, right: *PValue)

	if right isInteger
		var i = right integer
		if i isNull
			// Do nothing
			return
		elsif i isUnit
			// INC/DEC r8
			self writeModrm (op unitRmm, 3, left number, 0xFE)
			return
		end
	end
	self opRI8 (op, left, right)

end

function .public addRI16 (op: *BinaryOperation, left: *PRegisterValue, right: *PValue)

	if right isInteger
		var i = right integer
		if i isNull
			// Do nothing
			return
		elsif i isUnit
			// INC/DEC r16
			self writeByte (0x66)
			self writeByte (op unitReg + left number)
			return
		end
	end
	self opRI16 (op, left, right)

end

function .public addRI32 (op: *BinaryOperation, left: *PRegisterValue, right: *PValue)

	if right isInteger
		var i = right integer
		if i isNull
			// Do nothing
			return
		// Commented out: do not use inc/dec because it does not update
		// the carry flag and it is required when incrementing a 64 bit value:
		//	add eax, 1
		//	adc edx, 0
		// To fix it cleanly, the code generator should generate a special
		// operation saying that CF must be updated.
		//
		//elsif i isUnit
		//	// INC/DEC r32
		//	self writeByte (op unitReg + left number)
		//	return
		end
	end
	self opRI32 (op, left, right)

end
//[cf]
//[cf]
//[of]:	push / pop
//[of]:pushValue
function pushValue (value: *PValue)

	switch value code
	case 'register
		self pushRegister (value register)
	case 'memory
		self pushMemory (value memory)
	case 'integer
		self pushInteger (value integer)
	else // 'undefined, 'global, 'function, 'builtin
		// PUSH imm32
		self writeByte (0x68)
		self writeImmediate (value)
		self stackPointer -= 4
	end

end
//[cf]
//[of]:pushInteger
function pushInteger (value: *PIntegerValue)

	var nn = value dword
	if isShortDisplacement (nn)
		// PUSH imm8
		self writeByte (0x6A)
		self writeByte (nn cast (Byte))
	else
		// PUSH imm32
		self writeByte (0x68)
		self writeDword (nn)
	end
	self stackPointer -= 4

end
//[cf]
//[of]:pushRegister
function pushRegister (register: *PRegisterValue)

	var r32 = register register32
	if r32 notNil
		// PUSH reg32
		self writeByte (r32 number + 0x50)
	else
		// Some 8 bit registers don't have a 32 bit register
		
		// SUB ESP, 4
		self writeModrm (5, 3, Register : 'esp, 0x83)
		self writeByte (4)
	
		// MOV [ESP], reg8
		self writeEspBase (register number, 0, 0x88)
	end
	self stackPointer -= 4

end
//[cf]
//[of]:pushMemory
function pushMemory (value: *PMemoryValue)

	// For DWORD, it is easy to read value and push it on stack
	self writeMemory1 (value, 6, 0xFF)
	self stackPointer -= 4

end
//[cf]

//[of]:popValue
function popValue (value: *PValue)

	if value code == 'register
		self popRegister (value register)
	else // 'memory
		self popMemory (value memory)
	end

end
//[cf]
//[of]:popRegister
function popRegister (register: *PRegisterValue)

	self stackPointer += 4
	switch register size
	case 'byte
		// MOV reg8, [ESP]
		self writeEspBase (register number, 0, 0x8A)
		
		// ADD ESP, 4
		self writeModrm (0, 3, Register : 'esp, 0x83)
		self writeByte (4)
	
	else // 'word, 'dword
		// POP reg32
		self writeByte (register number + 0x58)
	end

end
//[cf]
//[of]:popMemory
function popMemory (value: *PMemoryValue)

	self stackPointer += 4
	// For DWORD, it is easy to read value and push it on stack
	self writeMemory1 (value, 0, 0x8F)

end
//[cf]
//[cf]
//[of]:	stack
//[of]:addEspImm
function addEspImm (offset: StackOffset)

	if offset == 0
		// Do nothing
	elsif isShortDisplacement (offset)
		// ADD ESP, imm8
		self writeModrm (0, 3, Register : 'esp, 0x83)
		self writeByte (offset cast (Byte))
	else
		// ADD ESP, imm32
		self writeModrm (0, 3, Register : 'esp, 0x81)
		self write (offset)
	end
	
	// Update the stack pointer
	self stackPointer += offset

end
//[cf]
//[of]:subEspImm
function subEspImm (offset: StackOffset)

	if offset == 0
		// Do nothing
	elsif isShortDisplacement (offset)
		// SUB ESP, imm8
		self writeModrm (5, 3, Register : 'esp, 0x83)
		self writeByte (offset cast (Byte))
	else
		// SUB ESP, imm32
		self writeModrm (5, 3, Register : 'esp, 0x81)
		self write (offset)
	end

	// Update the stack pointer
	self stackPointer -= offset

end
//[cf]
//[cf]
//[of]:	writing
//[of]:writeLabel
function writeLabel (label: *PLabel)

	var position = self writtenBytes
	
	if label isDefined
		// Write relative offset
		self writeDword (label relativeOffset (position))
	else
		// Add an unresolved label
		var unsolved = self fpool new (MCUnsolvedLabel, label, position)
		self unsolvedLabels add (unsolved)
		
		// Write empty offset
		self writeDword (0)
	end

end
//[cf]
//[of]:writeRelative
//[c]Writes a relative address (for function calls)
//[c]
//[c]REMARKS
//[c]	A relative address is always unsolved because the source offset can not
//[c]	be computed yet: the object is inserted into the section only when
//[c]	completed, therefore its offset in the section is unknown (other objects
//[c]	could be inserted into the section before it is completed).
//[c]
function writeRelative (toObject: *ObjectData)

	var fromObject	= self currentObject
	var fromOffset	= self writtenBytes
		
	var unsolved	= self fpool new (	MCUnsolvedReference, 
			fromObject,
			fromOffset,
			toObject)
	
	self unsolvedRelatives add (unsolved)
	
	// Write empty offset
	self writeDword (0)

end
//[cf]
//[of]:writeRM
function writeRM (	value	: *PValue,
	register	: Byte,
	opcode1	: Byte)

	switch value code
	case 'register
		self writeModrm (register, 3, value register number, opcode1)
	case 'memory
		self writeMemory1 (value memory, register, opcode1)
	else
		assertFailure ("writeRM: invalid value")
	end

end

function writeRM2 (	value	: *PValue, 
	register	: Byte, 
	opcode1	: Byte, 
	opcode2	: Byte)

	switch value code
	case 'register
		self writeModrm2 (register, 3, value register number, opcode1, opcode2)
	case 'memory
		self writeMemory2 (value memory, register, opcode1, opcode2)
	else
		assertFailure ("writeRM: invalid value")
	end

end
//[cf]
//[of]:writeMemory
function writeMemory0 (	value	: *PMemoryValue,
	register	: Byte)

	var info : MemoryInfo
	self getMemory (value address, info)
	self writeMemoryInfo (info, register)

end

function writeMemory1 (	value	: *PMemoryValue,
	register	: Byte,
	byte1	: Byte)

	var info : MemoryInfo
	self getMemory (value address, info)
	self writeByte (byte1)
	self writeMemoryInfo (info, register)

end

function writeMemory2 (	value	: *PMemoryValue,
	register	: Byte,
	byte1	: Byte,
	byte2	: Byte)

	var info : MemoryInfo
	self getMemory (value address, info)
	self writeByte (byte1)
	self writeByte (byte2)
	self writeMemoryInfo (info, register)

end
//[cf]
//[of]:getMemory
function getMemory (value: *PValue, info: *MemoryInfo)

	// Initialize memory info
	info flags = 0
	
	switch value code
	case 'undefined
		info setAddress (0)
	
	case 'integer
		info setAddress (value integer dword)
		
	case 'register
		info setIndex (value register number, 0)
	
	case 'global
		var glob = value glob
		info setReference (glob symbol, glob offset)

	case 'index
		var v	= value index
		var i	= v index register
		var b	= v base register
		var offset	= v offset
		
		// Translate base to esp
		if b == 'base
			offset	-= self stackPointer
			b = 'esp
		// Translate local to esp
		elsif b == 'local
			offset += self localPointer
			offset	-= self stackPointer
			b = 'esp
		end
		
		if i isNil
			info setIndex (b number, offset)
		else
			var scale = v scale
			var ss = Byte : (	scale == 1 cond 0 else
				scale == 2 cond 1 else
				scale == 4 cond 2 else
				3)
			if b isNil
				info setIndexAndScale (offset, i number, ss)
			else
				info setIndexAndScale2 (offset, b number, i number, ss)
			end
		end
		
	// These ones are non-sense but could happen with a cast
	// 'function
	// 'builtin
	else
		assertFailure ("memory: invalid address type")
	end

end
//[cf]
//[of]:writeMemoryInfo
function writeMemoryInfo (	info	: *MemoryInfo,
	register	: Byte)

	self writeByte (info modrm | (register << 3))
	if info hasSib
		self writeByte (info sib)
	end
		
	if info hasOffset8
		self writeByte (info offset8)
	elsif info hasOffset32
		self writeDword (info offset32)
	elsif info hasReference
		self writeReference (info symbol, info offset)
	end

end
//[cf]
//[of]:writeImmediate
//[c]Writes any immediate value (constant, global, function reference or builtin)
//[c]
function writeImmediate (value: *PValue)

	switch value code
	case 'integer
		var i = value integer
		switch value size
		case 'byte
			self writeByte (i byte)
		case 'word
			self writeWord (i word)
		else // 'dword
			self writeDword (i dword)
		end
	
	case 'undefined
		switch value size
		case 'byte
			self writeByte (0)
		case 'word
			self writeWord (0)
		else // 'dword
			self writeDword (0)
		end
	
	case 'global
		var g = value glob
		self writeReference (g symbol, g offset)
		
	case 'function
		var f = value func pfunction
		self writeReference (f object symbol, 0)

	case 'builtin
		var f = value builtin
		self writeReference (f object symbol, 0)
		
	else
		assertFailure ("Invalid immediate value")
	end

end
//[cf]
//[of]:writeEspBase
function writeEspBase (r: Byte, offset: StackOffset, opcode1: Byte)
	self writeEspBaseV (r, offset, opcode1)
end

function writeEspBase2 (r: Byte, offset: StackOffset, opcode1: Byte, opcode2: Byte)
	self writeEspBaseV (r, offset, opcode1, opcode2)
end

function writeEspBaseV (r: Byte, offset: StackOffset, ...)

	if offset == 0
		// modr/m: /r, mode=0, r/m=4
		self writeModrm (r, 0, 4, ...)
		
		// sib: base=esp, scale=*1, index = none
		self writeByte (Register : 'esp + (4 << 3))
		
	elsif isShortDisplacement (offset)
		// modr/m: /r, mode=1, r/m=4
		self writeModrm (r, 1, 4, ...)
		
		// sib: base=esp, scale=*1, index = none
		self writeByte (Register : 'esp + (4 << 3))
		
		// disp8
		self writeByte (offset cast (Byte))
	
	else
		// modr/m: /r, mode=2, r/m=4
		self writeModrm (r, 2,  4, ...)
		
		// sib: base=esp, scale=*1, index = none
		self writeByte (Register : 'esp + (4 << 3))
		
		// disp32
		self write (offset)
	end

end
//[cf]
//[of]:writeModrm
//[c]
//[c]REMARKS: do not use the variadic arguments to prevent
//[c]too many instanciated functions (opcodes could be integers or bytes)
//[c]
function writeModrm (r: Byte, mod: Byte, rm: Byte, opcode1: Byte)

	self writeByte (opcode1)
	self writeByte (modrm (r, mod, rm))

end

function writeModrm2 (r: Byte, mod: Byte, rm: Byte, opcode1: Byte, opcode2: Byte)

	self writeByte (opcode1)
	self writeByte (opcode2)
	self writeByte (modrm (r, mod, rm))

end
//[cf]
//[cf]

//[of]:	binary operations
static struct BinaryOperation

	var functions	: [2 * 3 * 3] & (*Generator, *BinaryOperation, *PValue, *PValue)
	var regRm	: Byte	// op reg, r/m
	var rmReg	: Byte	// op r/m, reg
	var accImm	: Byte	// op al/ax/eax, imm
	var rmImm	: Byte	// op r/m, imm
	var rmImmm	: Byte	// op r/m, imm (/reg)
	var unitReg	: Byte	// inc/dec reg (add/sub only)
	var unitRmm	: Byte	// inc/dec rm (/reg) (add/sub only)

	function call (generator, left, right)
		var index = (((left leftIndex * 3 ) + right rightIndex) * 3) cast (Integer) + left size cast (Integer)
		self functions [index] call (generator, self, left, right)
	end

end

//[of]:aliases
static const opRX8	= ref (*Generator)	opRX8	(*BinaryOperation,	*PRegisterValue,	*PValue)
static const opRX16	= ref (*Generator)	opRX16	(*BinaryOperation,	*PRegisterValue,	*PValue)
static const opRX32	= ref (*Generator)	opRX32	(*BinaryOperation,	*PRegisterValue,	*PValue)
static const opRI8	= ref (*Generator)	opRI8	(*BinaryOperation,	*PRegisterValue,	*PValue)
static const opRI16	= ref (*Generator)	opRI16	(*BinaryOperation,	*PRegisterValue,	*PValue)
static const opRI32	= ref (*Generator)	opRI32	(*BinaryOperation,	*PRegisterValue,	*PValue)
static const opXR8	= ref (*Generator)	opXR8	(*BinaryOperation,	*PValue,	*PRegisterValue)
static const opXR16	= ref (*Generator)	opXR16	(*BinaryOperation,	*PValue,	*PRegisterValue)
static const opXR32	= ref (*Generator)	opXR32	(*BinaryOperation,	*PValue,	*PRegisterValue)
static const opXI8	= ref (*Generator)	opXI8	(*BinaryOperation,	*PValue,	*PValue)
static const opXI16	= ref (*Generator)	opXI16	(*BinaryOperation,	*PValue,	*PValue)
static const opXI32	= ref (*Generator)	opXI32	(*BinaryOperation,	*PValue,	*PValue)
static const addRI8	= ref (*Generator)	addRI8	(*BinaryOperation,	*PRegisterValue,	*PValue)
static const addRI16	= ref (*Generator)	addRI16	(*BinaryOperation,	*PRegisterValue,	*PValue)
static const addRI32	= ref (*Generator)	addRI32	(*BinaryOperation,	*PRegisterValue,	*PValue)
//[cf]
//[of]:cmp
static const cmp_operation = *BinaryOperation : {
	opRX8,	opRX16,	opRX32,	// reg	reg
	opRX8,	opRX16,	opRX32,	// reg	memory
	opRI8,	opRI16,	opRI32,	// reg	imm
	opXR8,	opXR16,	opXR32,	// memory	reg
	nil,	nil,	nil,	// memory	memory
	opXI8,	opXI16,	opXI32,	// memory	imm
	
	0x3A,	// op reg, r/m
	0x38,	// op r/m, reg
	0x3C,	// op al/ax/eax, imm
	0x80,	// op r/m, imm
	0x07,	// op r/m, imm (/reg)
	0,	// inc/dec reg16/32 (add/sub only)
	0}	// inc/dec rm (add/sub only)
//[cf]
//[of]:add
static const add_operation = *BinaryOperation : {
	opRX8,	opRX16,	opRX32,	// reg	reg
	opRX8,	opRX16,	opRX32,	// reg	memory
	addRI8,	addRI16,	addRI32,	// reg	imm
	opXR8,	opXR16,	opXR32,	// memory	reg
	nil,	nil,	nil,	// memory	memory
	opXI8,	opXI16,	opXI32,	// memory	imm
	
	0x02,	// op reg, r/m
	0x00,	// op r/m, reg
	0x04,	// op al/ax/eax, imm
	0x80,	// op r/m, imm
	0x00,	// op r/m, imm (/reg)
	0x40,	// inc/dec reg16/32 (add/sub only)
	0x00}	// inc/dec rm (/reg) (add/sub only)
//[cf]
//[of]:sub
static const sub_operation = *BinaryOperation : {
	opRX8,	opRX16,	opRX32,	// reg	reg
	opRX8,	opRX16,	opRX32,	// reg	memory
	addRI8,	addRI16,	addRI32,	// reg	imm
	opXR8,	opXR16,	opXR32,	// memory	reg
	nil,	nil,	nil,	// memory	memory
	opXI8,	opXI16,	opXI32,	// memory	imm
	
	0x2A,	// op reg, r/m
	0x28,	// op r/m, reg
	0x2C,	// op al/ax/eax, imm
	0x80,	// op r/m, imm
	0x05,	// op r/m, imm (/reg)
	0x48,	// inc/dec reg16/32 (add/sub only)
	0x01}	// inc/dec rm (/reg) (add/sub only)
//[cf]
//[of]:adc
static const adc_operation = *BinaryOperation : {
	opRX8,	opRX16,	opRX32,	// reg	reg
	opRX8,	opRX16,	opRX32,	// reg	memory
	opRI8,	opRI16,	opRI32,	// reg	imm
	opXR8,	opXR16,	opXR32,	// memory	reg
	nil,	nil,	nil,	// memory	memory
	opXI8,	opXI16,	opXI32,	// memory	imm
	
	0x12,	// op reg, r/m
	0x10,	// op r/m, reg
	0x14,	// op al/ax/eax, imm
	0x80,	// op r/m, imm
	0x02,	// op r/m, imm (/reg)
	0,	// inc/dec reg16/32 (add/sub only)
	0}	// inc/dec rm (/reg) (add/sub only)
//[cf]
//[of]:sbb
static const sbb_operation = *BinaryOperation : {
	opRX8,	opRX16,	opRX32,	// reg	reg
	opRX8,	opRX16,	opRX32,	// reg	memory
	opRI8,	opRI16,	opRI32,	// reg	imm
	opXR8,	opXR16,	opXR32,	// memory	reg
	nil,	nil,	nil,	// memory	memory
	opXI8,	opXI16,	opXI32,	// memory	imm
	
	0x1A,	// op reg, r/m
	0x18,	// op r/m, reg
	0x1C,	// op al/ax/eax, imm
	0x80,	// op r/m, imm
	0x03,	// op r/m, imm (/reg)
	0,	// inc/dec reg16/32 (add/sub only)
	0}	// inc/dec rm (/reg) (add/sub only)
//[cf]
//[of]:and
static const and_operation = *BinaryOperation : {
	opRX8,	opRX16,	opRX32,	// reg	reg
	opRX8,	opRX16,	opRX32,	// reg	memory
	opRI8,	opRI16,	opRI32,	// reg	imm
	opXR8,	opXR16,	opXR32,	// memory	reg
	nil,	nil,	nil,	// memory	memory
	opXI8,	opXI16,	opXI32,	// memory	imm
	
	0x22,	// op reg, r/m
	0x20,	// op r/m, reg
	0x24,	// op al/ax/eax, imm
	0x80,	// op r/m, imm
	0x04,	// op r/m, imm (/reg)
	0,	// inc/dec reg16/32 (add/sub only)
	0}	// inc/dec rm (/reg) (add/sub only)
//[cf]
//[of]:or
static const or_operation = *BinaryOperation : {
	opRX8,	opRX16,	opRX32,	// reg	reg
	opRX8,	opRX16,	opRX32,	// reg	memory
	opRI8,	opRI16,	opRI32,	// reg	imm
	opXR8,	opXR16,	opXR32,	// memory	reg
	nil,	nil,	nil,	// memory	memory
	opXI8,	opXI16,	opXI32,	// memory	imm
	
	0x0A,	// op reg, r/m
	0x08,	// op r/m, reg
	0x0C,	// op al/ax/eax, imm
	0x80,	// op r/m, imm
	0x01,	// op r/m, imm (/reg)
	0,	// inc/dec reg16/32 (add/sub only)
	0}	// inc/dec rm (/reg) (add/sub only)
//[cf]
//[of]:xor
static const xor_operation = *BinaryOperation : {
	opRX8,	opRX16,	opRX32,	// reg	reg
	opRX8,	opRX16,	opRX32,	// reg	memory
	opRI8,	opRI16,	opRI32,	// reg	imm
	opXR8,	opXR16,	opXR32,	// memory	reg
	nil,	nil,	nil,	// memory	memory
	opXI8,	opXI16,	opXI32,	// memory	imm
	
	0x32,	// op reg, r/m
	0x30,	// op r/m, reg
	0x34,	// op al/ax/eax, imm
	0x80,	// op r/m, imm
	0x06,	// op r/m, imm (/reg)
	0,	// inc/dec reg16/32 (add/sub only)
	0}	// inc/dec rm (/reg) (add/sub only)
//[cf]
//[cf]
//[of]:	FunctionBuckets
static const FunctionBucket = Vector (*Function)

static struct FunctionBuckets
	var buckets	: SimpleDictionary (Size, *FunctionBucket, Size : 0, nil)
	var count	: Integer
	var maxKey	: Size
	var maxCount	: Integer
	
	function initialize
		self buckets initialize
		self count	= 0
		self maxCount = 0
		self maxKey = 0
	end
	
	function release
		self buckets eachValue do bucket
			bucket delete
		end
		self buckets release
	end
		
	function add (f: *Function)
		var pf = pfunction (f)
		var key = pf hash | 1
		var bucket = self buckets [key]
		if bucket isNil
			bucket = FunctionBucket new
			self buckets add (key, bucket)
		end
		bucket add (f)

		if bucket size > self maxCount
			self maxKey = key
			self maxCount = bucket size
		end
		self count ++
	end
	
	function each
		self buckets eachValue do b
			yield b
		end
	end

end
//[cf]
//[of]:	MCUnsolvedLabel
static struct MCUnsolvedLabel

	var label	: *PLabel	// The label
	var offset	: Uinteger	// Position relative to the beginning of the function where to write the value

//[of]:	initialize - release
//[of]:initialize
function initialize (label: *PLabel, offset: Uinteger)
	self label	= label
	self offset	= offset
end
//[cf]
//[cf]
end
//[cf]
//[of]:	MCUnsolvedReference
static struct MCUnsolvedReference

	var fromObject	: *ObjectData	// The object containing the reference
	var fromOffset	: Uinteger	// Position relative to the beginning of the object where to write the value
	var to	: *ObjectData	// The address

//[of]:	initialize - release
//[of]:initialize
function initialize (	fromObject	: *ObjectData,
	fromOffset	: Uinteger,
	to	: *ObjectData)

	self fromObject	= fromObject
	self fromOffset	= fromOffset
	self to	= to

end
//[cf]
//[cf]

end
//[cf]
//[of]:	MemoryInfo
//[c]Stores parameters to encode an effective address.
//[c]
static struct MemoryInfo

	var flags	: Flags
	var modrm	: Byte
	var sib	: Byte
	var offset	: Uinteger
	var symbol	: *ObjectSymbol

	static stype Flags : Byte
		'sib	= 1
		'offset8	= 2
		'offset32	= 4
		'reference	= 8
	end

//[of]:	accessing
//[of]:offset8
function offset8
	return self offset cast (Byte)
end
//[cf]
//[of]:offset32
function offset32
	return self offset
end
//[cf]

//[of]:setSib
function setSib (sib: Byte)
	self sib = sib
	self flags |= 'sib
end
//[cf]
//[of]:setOffset8
function setOffset8 (offset: Byte)
	self offset = offset cast (Uinteger)
	self flags |= 'offset8
end
//[cf]
//[of]:setOffset32
function setOffset32 (offset: Uinteger)
	self offset = offset
	self flags |= 'offset32
end
//[cf]

//[of]:setReference
function setReference (	symbol	: *ObjectSymbol,
	offset	: Uinteger)

	self modrm	= modrm (0, 0, 5)
	self offset	= offset
	self symbol	= symbol
	self flags |= 'reference

end
//[cf]
//[of]:setAddress
function setAddress (address: Uinteger)
	self modrm = modrm (0, 0, 5)
	self setOffset32 (address)
end
//[cf]
//[of]:setIndex
function setIndex (	register	: Register,
	offset	: Uinteger)

	if register == 'esp
		self setIndexAndScale2 (offset, register, 4, 0)
	// Remark: [ebp] must be coded as [ebp + 0]
	elsif offset == 0 and register <> Register : 'ebp
		self modrm = modrm (0, 0, register)
	elsif isShortDisplacement (offset)
		self modrm = modrm (0, 1, register)
		self setOffset8 (offset cast (Byte))
	else
		self modrm = modrm (0, 2, register)
		self setOffset32 (offset)
	end

end
//[cf]
//[of]:setIndexAndScale
function setIndexAndScale2 (	offset	: Uinteger,
	baseRegister	: Byte,
	indexRegister	: Byte,
	ss	: Byte)

	// Remark: [ebp + scaled] must be coded as [ebp + scaled + 0]
	if offset == 0 and baseRegister <> Register : 'ebp
		self modrm = modrm (0, 0, 4)
		self setSib (baseRegister + (indexRegister << 3) + (ss << 6))
	elsif isShortDisplacement (offset)
		self modrm = modrm (0, 1, 4)
		self setSib (baseRegister + (indexRegister << 3) + (ss << 6))
		self setOffset8 (offset cast (Byte))
	else
		self modrm = modrm (0, 2, 4)
		self setSib (baseRegister + (indexRegister << 3) + (ss << 6))
		self setOffset32 (offset)
	end

end

function setIndexAndScale (	offset	: Uinteger,
	indexRegister	: Byte,
	ss	: Byte)

	self modrm = modrm (0, 0, 4)
	self setSib (5 + (indexRegister << 3) + (ss << 6))
	self setOffset32 (offset)

end
//[cf]
//[cf]
//[of]:	testing
//[of]:hasSib
function hasSib
	return (self flags & 'sib) <> 0
end
//[cf]
//[of]:hasOffset8
function hasOffset8
	return (self flags & 'offset8) <> 0
end
//[cf]
//[of]:hasOffset32
function hasOffset32
	return (self flags & 'offset32) <> 0
end
//[cf]
//[of]:hasReference
function hasReference
	return (self flags & 'reference) <> 0
end
//[cf]
//[cf]

end
//[cf]

end
//[cf]

end
//[cf]
//[of]:P-Code Generator
//[of]:FunctionGenerator
//[c]The function generator builds a PFunction from a Function.
//[c]
//[c]Constants found in the functions are added to the object file.
//[c]
struct FunctionGenerator

	var pool	: *MemoryPool	// The memory pool to store mc-instructions
	var objectFile	: *ObjectFile	// The object file to store constants (strings, structs, ...)
			
	var pfunction	: *PFunction	// The p-function to generate
	var line	: LineNumber	// The current line number
	var exitLabel	: *PLabel	// Return instructions jump to this label
	var inlineContext	: *InlineContext	// The current inline context
	var instructions	: *Collection (PInstruction)	// The current list of instruction to fill (if nil, we are starting a new list: a new one is created)
	var builtins	: [BuiltinId : 'max] PBuiltinValue	// The builtin functions
	var unwindItem	: *UnwindItem	// The top of the stacked unwind-items

	static const max_values	= Size : 256
	static const oneValues	= *[4]*PValue : {oneValue8,	oneValue16,	oneValue32,	oneValue64}
	static const zeroValues	= *[4]*PValue : {zeroValue8,	zeroValue16,	zeroValue32,	zeroValue64}

//[of]:	initialize - release
//[of]:initialize
function initialize (	pool	: *MemoryPool, 
	obj	: *ObjectFile)

	self pool	= pool
	self objectFile	= obj
	self initializeBuiltinFunctions

end
//[cf]

//[c].private
//[of]:initializeBuiltinFunctions
function initializeBuiltinFunctions

	var p = builtin_table
	var q = self builtins
	while p [] code notNil
		q [] initialize (self objectFile, p [] name, p [] code, p [] size, p [] stackOffset)
		p ++
		q ++
	end

end
//[cf]
//[cf]
//[of]:	generating
//[of]:generate
function generate (f: *Function, pf: *PFunction)

	self pfunction	= pf
	self instructions	= pf instructions

	// Create a PParameter for each parameter of the function
	f eachParameter do p
		if not p type isMeta
			p generator = self newParameter (p name string, sizeCode (p type))
		end
	end

	// Reset the generator value for all composites of the function
	f prepareLocals
	
	// Create the exit label
	self exitLabel	= self newLabel
	
	// Set the initial location
	self line = f line
	
	// Reset the inline context
	self inlineContext = nil
	
	// Reset the unwind stack pointer
	self unwindItem	= nil
	
	// Generate the body
	self generateBlock (f body)
	
	// Add the exit label
	self emitLabel (self exitLabel)
	
end
//[cf]
//[cf]
	
	// private
//[of]:	generating instructions
//[of]:generateBlock
function generateBlock (block: *Block) :

	// Save the unwind pointer at the beginning of the block
	var startUnwind = self unwindItem
	
	block variables each do variable
		var storageType = variable storageType
		if storageType isSimple
			// Create the p-variable and attach it to the variable
			var size = sizeCode (storageType)
			variable generator = self newVariable (variable name string, size)
		else
			// Create a local on stack
			var local = self newLocal (sizeToUnsigned (storageType size))
			// The code generator does not support direct evaluation of the 
			// local: we must store the address into a local variable
			variable generator = self emitLoadAuto (local)
		end
	end
	
	block instructions each do i
		self generateInstruction (i)
	end

	// Unwind
	if not block terminated
		self generateUnwindTo (startUnwind)
	end
	
	// Restore the unwind pointer
	self unwindItem = startUnwind
	
end
//[cf]
//[of]:generateInstruction
function generateInstruction (instruction: *Instruction)

	// Do not changes the line number if we are expanding
	// a function or an iterator call
	if self inlineContext isNil and instruction line <> 'none
		self line = instruction line
	end
	
	switch instruction code
	case 'evaluate
		self generateEvaluate (instruction asEvaluate)
	case 'variable
		self generateVariable (instruction asVariable)
	case 'assign
		self generateAssign (instruction asAssign)
	case 'if
		self generateIf (instruction asIf)
	case 'while
		self generateWhile (instruction asWhile)
	case 'break
		self generateBreak (instruction asBreak)
	case 'continue
		self generateContinue (instruction asBreak)
	case 'return
		self generateReturn (instruction asReturn)
	case 'leave
		self generateLeave (instruction asLeave)
	case 'switch
		self generateSwitch (instruction asSwitch)
	case 'block
		self generateBlock (instruction asBlock block)
	case 'defer
		self generateDefer (instruction asDefer)
	else
		assertFailure ("Generating unknown instruction")
	end

end
//[cf]
//[of]:generateEvaluate
function generateEvaluate (instruction: *EvaluateInstruction)

	instruction values each do e
		self generateExpression (e)
	end

end
//[cf]
//[of]:generateAssign
function generateAssign (instruction: *AssignInstruction)
	
	// All variables but the last must be copied to temporary values
	// because some lvalues may depends on previous assigned values.
	//	a1, a2, ..., an = v1, v2, ..., vn
	// becomes
	//	t1 = e1
	//	t2 = e2
	//	...
	//	an = en
	//	a1 = t1
	//	a2 = t2
	//
	var rvalues = instruction right
	var tvalues : [max_values] *PValue
	var n = rvalues size - 1
	var i = Index : 0
	var iter = rvalues firstElement
	while i < n
		var e = iter object
 		tvalues [i] = self emitLoadAuto (self generateExpression (e))
		iter = iter nextSibling
		i ++
	end

	var lvalues = instruction left
	var rvalue = self generateExpression (rvalues last)
	var lvalue = self generateExpression (lvalues last)
	self emitAssign (lvalue, rvalue)

	i = 0
	iter = lvalues firstElement
	while i < n
		var e = iter object
		self emitAssign (self generateExpression (e), tvalues [i])
		iter = iter nextSibling
		i ++
	end

end
//[cf]
//[of]:generateVariable
function generateVariable (instruction: *VariableInstruction)

	var src = self generateExpression (instruction value)
	self emitAssign (pvalue (instruction variable), src)

end
//[cf]
//[of]:generateIf
function generateIf (instruction: *IfInstruction)
	
	// Pass 1 - Create the labels
	var lastLabel = PLabel nil
	instruction rules each do rule
		lastLabel	= self newLabel
		rule generator = lastLabel
	end
	if instruction elseBlock notNil
		lastLabel	= self newLabel
	end

	// Pass 2 - Generate code
	var needLastLabel = false
	instruction rules each do rule
		var condition	= rule condition
		var elseLabel	= plabel (rule)
		
		self line = rule line
		self generateJumpUnless (condition, elseLabel)
		
		// Generate the block
		self generateBlock (rule block)
			
		// Jump to the last block if the block is not terminated and
		// it is not the last block.
		if not rule block terminated and elseLabel <> lastLabel
			self emitJump (lastLabel)
			needLastLabel = true
		end

		// The current position is the label else of the rule
		self emitLabel (elseLabel)
	end

	if instruction elseBlock notNil
		self generateBlock (instruction elseBlock)
		if needLastLabel
			self emitLabel (lastLabel)
		end
	end

end
//[cf]
//[of]:generateWhile
function generateWhile (instruction: *WhileInstruction)

	var loopLabel	= self newLabel
	var exitLabel = self newLabel
	var continueLabel = instruction condition notNil cond self newLabel else loopLabel

	var info : PWhile
	info exitLabel = exitLabel
	info continueLabel = continueLabel
	info startUnwind = self unwindItem
	instruction generator = info
	
	if instruction condition notNil
		self emitJump (continueLabel)
		self emitLabel (loopLabel)
		self generateBlock (instruction block)
		self emitLabel (continueLabel)
		
		// Do not use the line of the test as COFF does not accept line
		// above the previous ones. Use the successor of the last line 
		// instead (it could the end or a blank line).
		//self line = instruction line
		self line ++	
		
		self generateJumpIf (instruction condition, loopLabel)
	else
		self emitLabel (loopLabel)
		self generateBlock (instruction block)
		self emitJump (loopLabel)
	end
	self emitLabel (exitLabel)

end
//[cf]
//[of]:generateBreak
function generateBreak (instruction: *BreakInstruction)

	var info = instruction instruction generator downcast (*PWhile)
	self generateUnwindTo (info startUnwind)
	self emitJump (info exitLabel)

end
//[cf]
//[of]:generateContinue
function generateContinue (instruction: *BreakInstruction)

	var info = instruction instruction generator downcast (*PWhile)
	self generateUnwindTo (info startUnwind)
	self emitJump (info continueLabel)

end
//[cf]
//[of]:generateReturn
function generateReturn (instruction: *ReturnInstruction)

	if self inlineContext notNil
		// Inline return
		var info = self inlineContext
		
		// Copy result to return values
		var i = Index : 0
		instruction expressions each do e
			var v = self generateExpression (e)
			if info singleReturn
				info returnValues [i] = v
			else
				self emitAssign (info returnValues [i], v)
			end
			i ++
		end
		
		// Unwind the stack up to the beginning of the function
		self generateUnwindTo (info startUnwind)
		
		if not info singleReturn
			self emitJump (info exitLabel)
		end
	
	else
		// Regular return
		
		// Initialize the offset: skip parameters and return address
		var offset = (self pfunction parameterStackSize + 4)
		
		var e0	= Expression nil
		instruction expressions each do e
			if e0 isNil
				e0	= e
			else
				var v = self generateExpression (e)
				var size = v size
				var out = self newBase (size, offset)
				offset += size toStackSize
				self emitAssign (out, v)
			end
		end
		
		// The first return value is the accumulator, is must be processed as 
		// the last instruction, so the accumulator won't be modified (unless 
		// unwinding)
		var v0 = PValue nil
		if e0 notNil
			v0 = self generateExpression (e0)
		end

		// Unwind the stack up to the beginning of the function
		self generateUnwindTo (nil)
		
		if v0 notNil
			if v0 size == 'qword
				self emitLda (v0 low)
				self emitLdd (v0 high)
			else
				self emitLda (v0)
			end
		end
		
		self emitJump (self exitLabel)
	end

end
//[cf]
//[of]:generateLeave
function generateLeave (instruction: *LeaveInstruction)

	var block = instruction block
	var info	= block generator downcast (*LeaveContext)

	// Copy result to return values
	var i = Index : 0
	instruction arguments each do e
		var v = self generateExpression (e)
		self emitAssign (info returnValues [i], v)
		i ++
	end
	
	// Unwind the stack up to the beginning of the function
	self generateUnwindTo (info startUnwind)
	
	var exitLabel = info exitLabel
	if exitLabel isNil
		exitLabel = self newLabel
		info exitLabel = exitLabel
	end
	self emitJump (exitLabel)
	
end
//[cf]
//[of]:generateSwitch
function generateSwitch (instruction: *SwitchInstruction)

	// Evaluate the value
	var v = self generateExpression (instruction value)
	
	// Create the exit label if required
	var exitLabel	= PLabel nil
	var defaultLabel	= PLabel nil
	if not instruction terminated
		exitLabel	= self newLabel
		defaultLabel	= exitLabel
	end
	
	// Create a label for each case
	var caseCount = Uinteger : 0
	instruction eachChoice do choice
		var label = self newLabel
		choice generator = label
		caseCount += choice values size asUnsigned
	end
	if instruction elseBlock notNil
		defaultLabel = self newLabel
	end
	
	// Create the switch table
	var table = self newSwitchTable32 (caseCount)
	var i = Index : 0
	instruction eachChoice do choice
		choice values each do e
			var constant = e asConstantInteger value cast (Integer)
			table setCase (i, constant, plabel (choice))
			i ++
		end
	end

//[c]
//[c]	Create the switch instructions
//[c]
	// Compute density
	var low =  Integer : 0x7FFFFFFF
	var high = Integer : 0 - 0x7FFFFFFF
	table each do value, label
		low = min (low, value)
		high = max (high, value)
	end
	var range = (high - low + 1) asUnsigned
	
	if table size * 2 >= range
	
		// The values are compact: use a direct table
		var object = self getDirectTable (table, low, high, defaultLabel)

		// Extend to 32 bits
		var tmp = self getResize (v, instruction value type, 'dword)

		// Sub min
		if low <> 0
			var constant = self newInteger ('dword, low asUnsigned)
			tmp = self buildSub (tmp, constant)
		end
		
		// The value must be a register because it is used as an index
		tmp = self forceR (tmp)
		
		// Compare to high - low (unsigned!)
		var cc = self emitCmp ('a, tmp, self newInteger ('dword, (high - low) asUnsigned))
			
		// Jump to default if above
		self emitJumpC (cc, defaultLabel)
		
		// Jump to table
		var table	= self emitLoadAuto (self newGlobal (object symbol)) // the table should be loaded as the offset of the index
		var index	= self newIndex3 (table, tmp, 4, 0)
		var memory	= self newMemory ('dword, index)
		self emitJumpi (memory)
		
	else
		// The values are sparse: use a lookup table
		var object = self getLookupTable (table, defaultLabel)

		// Extend to 32 bits
		var value32 = self getResize (v, instruction value type, 'dword)

		self emitLda (value32)
		self emitLdc (self newGlobal (object symbol))
		self emitBuiltinJmp ('lookup)
	end
	
//[c]	
//[c]	Build the blocks
//[c]	
	instruction eachChoice do choice
		var block = choice block
		var label = plabel (choice)
		
		self emitLabel (label)
		self generateBlock (block)
			
		// Jump to the last block if the block is not terminated
		if not block terminated
			self emitJump (exitLabel)
		end
	end
	if instruction elseBlock notNil
		self emitLabel (defaultLabel)
		self generateBlock (instruction elseBlock)
	end
	
	if not instruction terminated
		self emitLabel (exitLabel)
	end

end
//[cf]
//[of]:generateDefer
function generateDefer (i: *DeferInstruction)

	// Push an unwind-item
	var item = self pool allocate (UnwindItem)
	item next = self unwindItem
	item block = i block
	self unwindItem = item

end
//[cf]

//[of]:generateJumpIf
function generateJumpIf (c: *Expression, label: *PLabel) :

	switch c code
	case 'booleanNot
		self generateJumpUnless (c asUnary argument, label)
	case 'minimalAnd
		var b = c asBinary
		var elseLabel = self newLabel
		self generateJumpUnless (b argument1, elseLabel)
		self generateJumpIf (b argument2, label)
		self emitLabel (elseLabel)
	case 'minimalOr
		var b = c asBinary
		self generateJumpIf (b argument1, label)
		self generateJumpIf (b argument2, label)
	else
		var cc = self generateCondition (c)
		self emitJumpC (cc, label)
	end

end
//[cf]
//[of]:generateJumpUnless
function generateJumpUnless (c: *Expression, label: *PLabel) :

	switch c code
	case 'booleanNot
		self generateJumpIf (c asUnary argument, label)
	case 'minimalAnd
		var b = c asBinary
		self generateJumpUnless (b argument1, label)
		self generateJumpUnless (b argument2, label)
	case 'minimalOr
		var b = c asBinary
		var elseLabel = self newLabel
		self generateJumpIf (b argument1, elseLabel)
		self generateJumpUnless (b argument2, label)
		self emitLabel (elseLabel)
	else
		var cc = self generateCondition (c)
		self emitJumpC (cc invert, label)
	end

end
//[cf]
//[of]:generateUnwindTo
//[c]Emits the code to unwind up to the given item
//[c]
function generateUnwindTo (limit: *UnwindItem)

	var u = self unwindItem
	while u <> limit
		self generateUnwind (u)
		u = u next
	end

end
//[cf]
//[of]:generateUnwind
//[c]Emits the code to unwind the given item
//[c]
function generateUnwind (item: *UnwindItem)
	self generateBlock (item block)
end
//[cf]
//[cf]
//[of]:	generating expressions
//[of]:generateExpression
function generateExpression (e: *Expression) : *PValue

	switch e code
//[of]:	select
	case 'select

		var select = e asSelect
		var composite = select argument
		var pcomposite = pcomposite (composite)
		if pcomposite isNil
			pcomposite = self generateExpression (composite) downcast (*PCompositeValue)
			composite generator = pcomposite
		end
		return pcomposite [select index]
//[cf]
//[of]:	constants
	case 'constantInteger
		return self newInteger64 (sizeCode (e type), e asConstantInteger value)
	
	case 'constantString8
		return self getString8 (e asConstantString8)

	case 'constantString16
		return self getString16 (e asConstantString16)

	case 'constantStructure
		return self getStructure (e asConstantStructure)
		
	case 'constantArray
		return self getArray (e asConstantArray)
		
	case 'constantFunction
		return self getFunction (e asConstantFunction)
	
	case 'constantGlobal
		return self getGlobal (e asConstantGlobal)
//[cf]
//[of]:	minimal and
	case 'minimalAnd
	
		var pair	= e asBinary
		var label	= self newLabel
		var t	= self newVariable (nil, 'byte)
		
		self emitLoad (t, self generateExpression (pair argument1))
		self emitTest (t, t)
		self emitJumpC ('z, label)
		self emitLoad (t, self generateExpression (pair argument2))
		self emitLabel (label)
		
		return t
//[cf]
//[of]:	minimal or
	case 'minimalOr
	
		var pair	= e asBinary
		var label	= self newLabel
		var t	= self newVariable (nil, 'byte)
		
		self emitLoad (t, self generateExpression (pair argument1))
		self emitTest (t, t)
		self emitJumpC ('nz, label)
		self emitLoad (t, self generateExpression (pair argument2))
		self emitLabel (label)
		
		return t
//[cf]
//[of]:	cond
	case 'cond
	
		var c	= e asCond
		var elseLabel	= self newLabel
		var commonLabel	= self newLabel

		self generateJumpUnless (c condition, elseLabel)

		// Assign first values to temporaries
		var t : [max_values] *PValue
		var i = Index : 0
		c argument1 each do e
			t [i] = self emitLoadAuto (self generateExpression (e))
			i ++
		end

		self emitJump (commonLabel)
		self emitLabel (elseLabel)
		
		// Assign second values to temporaries
		i = 0
		c argument2 each do e
			self emitAssign (t [i], self generateExpression (e))
			i ++
		end

		self emitLabel (commonLabel)
		return self singleton (t, i)
//[cf]
//[of]:	function call
	case 'functionCall
	
		var call	= e asFunctionCall	
		var f	= call func
		var mc	= pfunction (f)
		
		if mc inline and not mc inlining
		
			// The function is inlinable: let's inline it instead of calling it
			mc inlining = true
			var value = self generateInlineCall (call)
			mc inlining = false
			return value
			
		else
			mc = mc master
			
			// Get the address to call
			var address	= self newFunction (f name string, mc)
			var callingConvention	= f callingConvention
			
			// Mark the function as called (the body must be generated)
			mc called = true
			
			return self generateCall (callingConvention, address, call arguments, f returnTypes)
		end
//[cf]
//[of]:	extern function call
	case 'externFunctionCall

		var call	= e asExternFunctionCall
		var f	= call func
		var symbol	= f generator downcast (*ObjectSymbol)
		var address	= self newGlobal (symbol)
		
		return self generateCall (f callingConvention, address, call arguments, f returnTypes)
//[cf]
//[of]:	pointer call
	case 'pointerCall

		var call	= e asPointerCall
		var pointerType	= call func type asPointer
		var functionType	= pointerType target asFunction
		var callingConvention	= functionType callingConvention
		var returnTypes	= functionType returnTypes
		var address	= self generateExpression (call func)
		
		return self generateCall (callingConvention, address, call arguments, returnTypes)
//[cf]
//[of]:	function parameter
	case 'functionParameter
		var parameter = e asParameter parameter
		return pvariable (parameter)
//[cf]
//[of]:	local variable
	case 'localVariable
		var variable	= e asLocalVariable variable
		return pvalue (variable)
//[cf]
//[of]:	global variable
	case 'globalVariable
		return self getGlobalVariable (e asGlobalVariable variable)
//[cf]
//[of]:	attribute
	case 'attribute
	
		var ae	= e asAttribute
		var attribute	= ae attribute
		var type	= attribute storageType
		var offset	= Uinteger : 0
		var addr	: *Expression
		
		// Merge all offsets of nested structures
		repeat
			offset += sizeToUnsigned (attribute offset)
			addr	= ae argument
			if addr code <> 'attribute
				break
			end
			ae = addr asAttribute
			attribute = ae attribute
			if attribute storageType isSimple
				break
			end
		end

		// Compute the effective address 
		var base	= self generateExpression (addr)
		var value	= self buildIndex (base, offset)
		
		if type isSimple
			value = self buildMemory (sizeCode (type), value)
		end

		return value
//[cf]
//[of]:	each extra
	case 'vargsEach
		self generateBlock (e asVargsEach block)
		return nil
//[cf]
//[of]:	cast
	case 'cast

		var c	= e asUnary
		var newType	= c type
		var oldType	= c argument type
		var arg	= self generateExpression (c argument)
		
		if arg isInteger
			var size = sizeCode (newType)
			return self newInteger64 (size, arg integer qword)
		elsif oldType isInteger and newType isInteger
			var size = sizeCode (newType)
			return self getResize (arg, oldType, size)
		else
			return arg
		end
//[cf]
//[of]:	macro call
	case 'macroCall

		var call = e asMacroCall

		// Create the return values
		var returnValues : [max_values] *PValue
		var i = Index : 0
		call types each do type
			var size = sizeCode (type)
			returnValues [i] = self newVariable (nil, size)
			i ++
		end
	
		// Create a context with information and assign it to the block of the macro
		var info : LeaveContext
		info exitLabel = nil
		info startUnwind = self unwindItem
		info returnValues = returnValues
		call block generator = info
	
		// Generate the block
		self generateBlock (call block)

		// Insert the label
		if info exitLabel notNil
			self emitLabel (info exitLabel)
		end
	
		// Retrieve the return values
		return self singleton (returnValues, call types size)
//[cf]
//[of]:	super
	case 'super
		var argument = e asUnary argument
		return self generateExpression (argument)
//[cf]

//[of]:	integer add
	case 'integerAdd
		return self buildAdd (self generatePair (e asBinary))
//[cf]
//[of]:	integer sub
	case 'integerSub
		return self buildSub (self generatePair (e asBinary))
//[cf]
//[of]:	integer smul
	case 'integerSmul
		return self buildMul (self generatePair (e asBinary))
//[cf]
//[of]:	integer umul
	case 'integerUmul
		return self buildMul (self generatePair (e asBinary))
//[cf]
//[of]:	integer sdiv
	case 'integerSdiv
		return self buildSdiv (self generatePair (e asBinary))
//[cf]
//[of]:	integer udiv
	case 'integerUdiv
		var v1, v2	= self generatePair (e asBinary)
		var t	= self newVariable (nil, v1 size)
		self emitUdiv (t, v1, v2)
		return t
//[cf]
//[of]:	integer smod
	case 'integerSmod
		var v1, v2	= self generatePair (e asBinary)
		var t	= self newVariable (nil, v1 size)
		self emitSmod (t, v1, v2)
		return t
//[cf]
//[of]:	integer umod
	case 'integerUmod
		var v1, v2	= self generatePair (e asBinary)
		var t	= self newVariable (nil, v1 size)
		self emitUmod (t, v1, v2)
		return t
//[cf]
//[of]:	integer shl
	case 'integerShl
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitShl (t, v2)
		return t
//[cf]
//[of]:	integer sshr
	case 'integerSshr
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitSshr (t, v2)
		return t
//[cf]
//[of]:	integer ushr
	case 'integerUshr
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitUshr (t, v2)
		return t
//[cf]
//[of]:	integer and
	case 'integerAnd
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitAnd (t, v2)
		return t
//[cf]
//[of]:	integer or
	case 'integerOr
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitOr (t, v2)
		return t
//[cf]
//[of]:	integer xor
	case 'integerXor
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitXor (t, v2)
		return t
//[cf]

//[of]:	integer not
	case 'integerNot
		var v	= self generateExpression (e asUnary argument)
		var t	= self emitLoadAuto (v)
		self emitNot (t)
		return t
//[cf]
//[of]:	integer pos
	case 'integerPos
		return self generateExpression (e asUnary argument)
//[cf]
//[of]:	integer neg
	case 'integerNeg
		var v	= self generateExpression (e asUnary argument)
		var t	= self emitLoadAuto (v)
		self emitNeg (t)
		return t
//[cf]

//[of]:	integer assign add
	case 'integerAssignAdd
		self emitAdd (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign sub
	case 'integerAssignSub
		self emitSub (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign smul
	case 'integerAssignSmul
		var v1, v2 = self generatePair (e asBinary)
		self emitSmul (v1, v2)
		return nil
//[cf]
//[of]:	integer assign umul
	case 'integerAssignUmul
		var v1, v2 = self generatePair (e asBinary)
		self emitUmul (v1, v1, v2)
		return nil
//[cf]
//[of]:	integer assign sdiv
	case 'integerAssignSdiv
		var v1, v2 = self generatePair (e asBinary)
		self emitSdiv (v1, v1, v2)
		return nil
//[cf]
//[of]:	integer assign udiv
	case 'integerAssignUdiv
		var v1, v2 = self generatePair (e asBinary)
		self emitUdiv (v1, v1, v2)
		return nil
//[cf]
//[of]:	integer assign smod
	case 'integerAssignSmod
		var v1, v2 = self generatePair (e asBinary)
		self emitSmod (v1, v1, v2)
		return nil
//[cf]
//[of]:	integer assign umod
	case 'integerAssignUmod
		var v1, v2 = self generatePair (e asBinary)
		self emitUmod (v1, v1, v2)
		return nil
//[cf]
//[of]:	integer assign shl
	case 'integerAssignShl
		self emitShl (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign sshr
	case 'integerAssignSshr
		self emitSshr (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign ushr
	case 'integerAssignUshr
		self emitUshr (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign and
	case 'integerAssignAnd
		self emitAnd (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign or
	case 'integerAssignOr
		self emitOr (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign xor
	case 'integerAssignXor
		self emitXor (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign inc
	case 'integerAssignInc
		var v1 = self generateExpression (e asUnary argument)
		var v2 = oneValues [v1 size]
		self emitAdd (v1, v2)
		return nil
//[cf]
//[of]:	integer assign dec
	case 'integerAssignDec
		var v1 = self generateExpression (e asUnary argument)
		var v2 = oneValues [v1 size]
		self emitSub (v1, v2)
		return nil
//[cf]

//[of]:	integer eq
	case 'integerEq
		return self generateCompare ('z, e asBinary)
//[cf]
//[of]:	integer ne
	case 'integerNe
		return self generateCompare ('nz, e asBinary)
//[cf]
//[of]:	integer sle
	case 'integerSle
		return self generateCompare ('le, e asBinary)
//[cf]
//[of]:	integer ule
	case 'integerUle
		return self generateCompare ('be, e asBinary)
//[cf]
//[of]:	integer slt
	case 'integerSlt
		return self generateCompare ('lt, e asBinary)
//[cf]
//[of]:	integer ult
	case 'integerUlt
		return self generateCompare ('b, e asBinary)
//[cf]
//[of]:	integer sge
	case 'integerSge
		return self generateCompare ('ge, e asBinary)
//[cf]
//[of]:	integer uge
	case 'integerUge
		return self generateCompare ('ae, e asBinary)
//[cf]
//[of]:	integer sgt
	case 'integerSgt
		return self generateCompare ('gt, e asBinary)
//[cf]
//[of]:	integer ugt
	case 'integerUgt
		return self generateCompare ('a, e asBinary)
//[cf]

//[of]:	boolean not
	case 'booleanNot
		var v1 = self generateExpression (e asUnary argument)
		var t	= self emitLoadAuto (v1)
		self emitXor (t, oneValue8)
		return t
//[cf]
//[of]:	pointer dereference
	case 'pointerDereference
		
		var a = e asUnary argument
		var v = self generateExpression (a)

		// Simple type: load the value at given address
		// Complex type: just compute the address
		var type	= a type asPointer target
		var size = sizeCode (type)
		return self buildMemory (size, v)
//[cf]

//[of]:	array index
	case 'arrayIndex

		var b	= e asBinary
		var cellType	= self cellType (b)
		var index	= self generateExpression (b argument2)
		var offset	= self getScaled (b, index)
		var base	= self forceRI (self generateExpression (b argument1))
		var value	= self buildAdd (base, offset)
		
		// Simple type: load the value at given address
		// Complex type: just compute the address
		if cellType isSimple
			var size = sizeCode (cellType)
			return self newMemory (size, value)
		end
		return value
//[cf]
//[of]:	array add
	case 'arrayAdd

		var b	= e asBinary
		var cellType	= self cellType (b)
		var index	= self generateExpression (b argument2)
		var offset	= self getScaled (b, index)
		var base	= self forceRI (self generateExpression (b argument1))
		var value	= self buildAdd (base, offset)

		return value
//[cf]
//[of]:	array sub
	case 'arraySub
	
		var b	= e asBinary
		var cellType	= self cellType (b)
		var index	= self generateExpression (b argument2)
		var offset	= self getScaled (b, index)
		var base	= self forceRI (self generateExpression (b argument1))
		var value	= self buildSub (base, offset)
	
		return value
//[cf]
//[of]:	array distance
	case 'arrayDistance

		var b	= e asBinary
		var cellType	= self cellType (b)
		var dst	= self generateExpression (b argument1)
		var src	= self generateExpression (b argument2)
		var diff	= self buildSub (dst, src)
		var value	= self buildSdiv (diff, self newInteger ('dword, sizeToUnsigned(cellType size)))

		return value
//[cf]
//[of]:	array assign add
	case 'arrayAssignAdd
	
		var b	= e asBinary
		var index	= self generateExpression (b argument2)
		var offset	= self getScaled (b, index)
		var base	= self generateExpression (b argument1)
		
		self emitAdd (base, offset)
		return nil
//[cf]
//[of]:	array assign sub
	case 'arrayAssignSub

		var b	= e asBinary
		var index	= self generateExpression (b argument2)
		var offset	= self getScaled (b, index)
		var base	= self generateExpression (b argument1)
		
		self emitSub (base, offset)
		return nil
//[cf]
//[of]:	array assign inc
	case 'arrayAssignInc

		var b	= e asBinary
		var cellType	= self cellType (b)
		var base	= self generateExpression (b argument1)
		var offset	= self newInteger ('dword, sizeToUnsigned (cellType size))
		
		self emitAdd (base, offset)
		return nil
//[cf]
//[of]:	array assign dec
	case 'arrayAssignDec

		var b	= e asBinary
		var cellType	= self cellType (b)
		var base	= self generateExpression (b argument1)
		var offset	= self newInteger ('dword, sizeToUnsigned (cellType size))
		
		self emitSub (base, offset)
		return nil
//[cf]
	else
		assertFailure ("Unhandled expression")
		return nil
	end

end
//[cf]
//[of]:generateCompare
//[c]Generates a comparison and returns a boolean value
//[c]
function generateCompare (code: ConditionFlags, b: *BinaryExpression)
	return self newComparison (self generatePair (b), code)
end
//[cf]
//[of]:generateCondition
function generateCondition (c: *Expression)

	var v = self generateExpression (c)
	if v isC
		var c = v comparison
		return self emitCmp (c flags, c value1, c value2)
	else
		return self emitCmp ('nz, v, zeroValues [v size])
	end

end
//[cf]
//[of]:generatePair
//[c]Generates a pair of expressions
//[c]
function generatePair (b: *BinaryExpression)
	var v1 = self generateExpression (b argument1)
	var v2 = self generateExpression (b argument2)
	return v1, v2
end
//[cf]

//[of]:generateCall
function generateCall (	callingConvention	: CallingConvention,
	address	: *PValue,
	arguments	: *ExpressionList,
	returnTypes	: *TypeSequence	)

//[c]	
//[c]	Allocate space on stack for extra return values
//[c]	
	var returnStackSize = StackOffset : 0
	var first = true 
	returnTypes each do type
		// Skip the first value, as it is the accumulator
		if not first
			var size = sizeCode (type)
			returnStackSize += size toStackSize
		end
		first = false
	end
	if returnStackSize <> 0
		self emitSubsp (returnStackSize)
	end

//[c]
//[c]	Push arguments on stack
//[c]
	// Create a reverse list of expressions
	var reverse : [max_values] *Expression
	var i = Index : 0
	arguments each do e
		if not e isType
			reverse [i] = e
			i ++
		end
	end

	// Evaluate in reverse order
	var argumentStackSize = StackOffset : 0
	while i > 0
		i --
		var value = self generateExpression (reverse [i])
		self emitPush (value)
		argumentStackSize += value size toStackSize
	end
		
//[c]
//[c]	Call the function
//[c]
	self emitCall (address, callingConvention, argumentStackSize)
	
//[c]
//[c]	Retrieve the return values
//[c]
	// Retrieve the first return value
	var r = returnTypes size
	var res = PValue nil
	if r > 0
		var size = sizeCode (returnTypes [0])
		if size == 'qword
			res = self newVariable (nil, 'qword)
			self emitLoad (res low, *PRegisterValue : 'eax)
			self emitLoad (res high, *PRegisterValue : 'edx)
		else
			res = self emitLoadAuto (size accumulator)
		end
	end

	// Retrieve additional values
	if r > 1
		var composite = self newComposite (r)
		composite values [0] = res
		var i = Index : 1
		while i < r
			var size = sizeCode (returnTypes [i])
			var t = self newVariable (nil, size)
			self emitPop (t)
			composite values [i] = t
			i ++
		end
		res = composite
	end
	
	return res

end
//[cf]
//[of]:generateInlineCall
function generateInlineCall (call: *FunctionCallExpression)

	var returnValues : [max_values] *PValue
	var f = call func
	var arguments = call arguments

	// Reset the generator value for all composites of the function
	f prepareLocals
	
	var info	: InlineContext
	info next	= self inlineContext
	info startUnwind = self unwindItem
	self inlineContext = info

	// Assign values to arguments
	zip (f parameters, arguments) do p, e
		if not p type isMeta
			var v = self generateExpression (e)
			// An immutable expression does not required to be copied into
			// a variable. A local variable cannot be considered immutable 
			// here as it can be modified in a block closure.
			if not e isConstant and not e isParameter
				v = self emitLoadAuto (v)
			end
			p generator = v
		end
	end
	
	var singleReturn	= f returnCount < 2
	
	// Create the return values
	if not singleReturn
		var i = Index : 0
		f returnTypes each do type
			var size = sizeCode (type)
			returnValues [i] = self newVariable (nil, size)
			i ++
		end
	end
	info returnValues	= returnValues
	info singleReturn	= singleReturn

	// The exit label is required only when there are multiple returns
	if singleReturn
		self generateBlock (f body)
	else
		var exitLabel = self newLabel
		info exitLabel	= exitLabel
		self generateBlock (f body)
		self emitLabel (exitLabel)
	end

	self inlineContext = info next
	
	// Retrieve the return values
	return self singleton (returnValues, f returnTypes size)

end
//[cf]
//[cf]
//[of]:	utils
//[of]:cellType
function cellType (e: *BinaryExpression)

	var arrayValue	= e argument1
	var arrayType	= arrayValue type asPointer target asArray
	var cellType	= arrayType cellType
	return cellType

end
//[cf]
//[of]:shift
function shift (x: Uinteger) : Uinteger

	if x == 0
		return 0
	end
	
	var pow = Uint32 : 0
	var n = x
	while n <> 1
		if (n & 1) <> 0
			return 0
		end
		n >>= 1
		pow ++
	end
	return pow

end
//[cf]
//[of]:singleton
function singleton (values: *[] *PValue, n: Integer)

	if n == 0
		return nil
	elsif n == 1
		return values [0]
	else
		var composite = self newComposite (n)
		n each do i
			composite values [i] = values [i]
		end
		return composite
	end

end
//[cf]
//[of]:forceRMI
function forceRMI (v: *PValue)

	if v isX or v isC
		return self emitLoadAuto (v)
	else
		return v
	end

end
//[cf]
//[of]:forceRM
function forceRM (v: *PValue)

	if v isX or v isC or v isI
		return self emitLoadAuto (v)
	else
		return v
	end

end
//[cf]
//[of]:forceRI
function forceRI (v: *PValue)

	if v isX or v isC or v isM
		return self emitLoadAuto (v)
	else
		return v
	end

end
//[cf]
//[of]:forceR
function forceR (v: *PValue)

	if v isR
		return v
	else
		return self emitLoadAuto (v)
	end

end
//[cf]
//[of]:smartCopy
//[c]Generate code to get an immutable value of the expression:
//[c]	* if the expression is a constant, a local variable or a parameter, just evaluate it.
//[c]	* otherwise evaluate it and store it in a local variable
//[c]
function smartCopy (e: *Expression)

	var v = self generateExpression (e)
	if e isConstant or e isLocalVariable or e isParameter
		return v
	else
		return self emitLoadAuto (v)
	end

end
//[cf]

//[of]:buildAdd
function buildAdd (value1: *PValue, value2: *PValue)

	var v1	= value1
	var v2	= value2

	// Try to use the index value first (works only with 32 bit integers)	
	if v1 size == 'dword
		if v1 isR and v2 isR
			return self newIndex3 (v1, v2, 1, 0)
		elsif v2 isInteger
			if v1 isR
				return self newIndex2 (v1, v2 integer dword)
			elsif v1 isX
				var i = v1 index
				return self newIndex3 (i base, i index, i scale, i offset + v2 integer dword)
			else
				var t = self emitLoadAuto (v1)
				return self newIndex2 (t, v2 integer dword)
			end
		elsif v1 isX and v2 isR
			var i = v1 index
			if i index isNil
				return self newIndex3 (i base, v2, 1, i offset)
			elsif i base isNil
				return self newIndex3 (v2, i index, i scale, i offset)
			end
		
		elsif v1 isInteger
			if v2 isR
				return self newIndex2 (v2, v1 integer dword)
			elsif v2 isX
				var i = v2 index
				return self newIndex3 (i base, i index, i scale, i offset + v1 integer dword)
			else
				var t = self emitLoadAuto (v2)
				return self newIndex2 (t, v1 integer dword)
			end
		elsif v2 isX and v1 isR
			var i = v2 index
			if i index isNil
				return self newIndex3 (i base, v1, 1, i offset)
			elsif i base isNil
				return self newIndex3 (v1, i index, i scale, i offset)
			end
		end
	end

	// t = v1
	// t += v2
	//
	// v1 and v2 are order following the criteria ('<' reads 'before'):
	// 	x < r < m < i
	// x first because we can load x but not add it (it will be loaded first, generating an extra load)
	// r next because if t use the same register, the instruction will be eliminated
	// i last because an add with a constant can be optimized.
	//
	if v1 addRank > v2 addRank
		v1, v2 = v2, v1
	end
		
	var t = self emitLoadAuto (v1)
	self emitAdd (t, v2)
	return t

end
//[cf]
//[of]:buildSub
function buildSub (v1: *PValue, v2: *PValue)

	// Try to use the index value first (works only with 32 bit integers)	
	if v1 size == 'dword
		if v1 isR and v2 isInteger
			return self newIndex2 (v1, - (v2 integer dword))
		elsif v1 isX and v2 isInteger
			var i = v1 index
			return self newIndex3 (i base, i index, i scale, i offset - v2 integer dword)
		end
	end

	// t = v1
	// t -= v2
	//		
	var t = self emitLoadAuto (v1)
	self emitSub (t, v2)
	return t

end
//[cf]
//[of]:buildMul
function buildMul (value1: *PValue, value2: *PValue)

	var v1	= value1
	var v2	= value2
	var size	= v1 size

	if size == 'qword
		var t	= self newVariable (nil, size)
		self emitOp64 ('umul64, t, v1, v2)
		return t
	end

	if v1 isInteger
		v1, v2 = v2, v1
	end

	if v2 isInteger
		var imm = v2 integer dword

		// Multiply by zero
		if imm == 0
			return zeroValues [size]
		end
		
		// Multiply by one
		if imm == 1
			return v1
		end

		// If v1 is in the form index * scale then
		// replace v1 with index and imm with imm * scale
		if v1 isX
			var i = v1 index
			if i base isNil and i offset == 0
				v1 = i index
				imm = i scale smul (imm)
			end
		end
		
		// Try to use the indexed addressing mode
		if imm == 2 or imm == 4 or imm == 8
			return self newIndex3 (nil, self forceR (v1), imm, 0)
		end
		
		// Multiply by power of two
		var pow = self shift (imm)
		if pow <> 0
			var t = self emitLoadAuto (v1)
			self emitShl (t, self newInteger ('byte, pow))
			return t
		end
	end
	
	// Byte size requires the use of the accumulator
	if size == 'byte
		var b = self forceRM (v2)
		self emitLda (v1)
		self emitUnary ('smul, b)
		return self emitLoadAuto (size accumulator)
	end

	if v2 isInteger
		var t = self newVariable (nil, size)
		self emitTernary ('smul3, t, self forceRM (v1), v2)
		return t
	end
		
	var t = self emitLoadAuto (v1)
	self emitBinary ('smul2, t, self forceRMI (v2))
	return t

end
//[cf]
//[of]:buildSdiv
function buildSdiv (v1: *PValue, v2: *PValue)

	var t	= self newVariable (nil, v1 size)
	self emitSdiv (t, v1, v2)
	return t

end
//[cf]
//[of]:buildIndex
function buildIndex (value: *PValue, offset: Uinteger)

	if offset == 0
		return value
	end
	
	if value isR
		return self newIndex2 (value, offset)
	end

	if value isX
		var src = value index
		return self newIndex3 (src base, src index, src scale, src offset + offset)
	end
	
	var t = self emitLoadAuto (value)
	return self newIndex2 (t, offset)

end
//[cf]
//[of]:buildMemory
function buildMemory (size: PValueSize, address: *PValue)

	if address isI or address isX
		return self newMemory (size, address)
	end
	
	if address isR
		var index = self newIndex (address)
		return self newMemory (size, index)
	end
	
	// M
	var t = self emitLoadAuto (address)
	var index = self newIndex (t)
	return self newMemory (size, index)

end
//[cf]
//[cf]
//[of]:	builder
//[of]:getDirectTable
function getDirectTable (	table	: *SwitchTable32, 
	min	: Integer, 
	max	: Integer, 
	defaultLabel	: *PLabel)

	var range = (max - min + 1) asUnsigned

	var object = self objectFile createStatic
	self objectFile beginObject (object, self objectFile dataSection, align_dword)
	var s = self objectFile allocateBuffer (Uinteger, range)
	
	// Initialize the buffer: mark to 0 all slots
	var p = s
	var limit = p + range
	while p <> limit
		p [] = 0
		p ++
	end
	
	// Write all values
	table each do value, label
		var index = (value - min) asUnsigned
		// Mark the slot as used (the real value will be written later)
		s [index] = 1
		self newLabelReference (object, index * 4, label)
	end
	
	// Write holes
	range each do i
		if s [i] == 0
			self newLabelReference (object, i * 4, defaultLabel)
		end
	end
	
	self objectFile endObject (object)
	return object

end
//[cf]
//[of]:getLookupTable
function getLookupTable (	table	: *SwitchTable32, 
	defaultLabel	: *PLabel)

	var object = self objectFile createStatic
	self objectFile beginObject (object, self objectFile dataSection, align_dword)
	var s = self objectFile allocateBuffer (Uinteger, (table size + 1) * 2)
	
	// Write all values
	var p = s
	table each do value, label
		p [] = value asUnsigned
		p ++
		self newLabelReference (object, sizeToUnsigned (p cast (Bytes) ~ s cast (Bytes)), label)
		p ++
	end
	
	self newLabelReference (object, sizeToUnsigned (p cast (Bytes) ~ s cast (Bytes)), defaultLabel)
	p ++
	p [] = 0
	
	self objectFile endObject (object)
	return object

end
//[cf]
//[of]:getFunction
function getFunction (e: *FunctionExpression)

	var value = e generator downcast (*PGlobalValue)
	if value isNil
		
		var prototype	= e value
		var code	= prototype code
		if code == 'function
			var f	= prototype asFunction
			var mc	= pfunction (f) master
			var e	= mc object
			
			// Mark the function as referenced
			mc called = true
			
			value	= self newGlobal (e symbol)
		else // 'extern
			var f	= prototype asExternFunction
			value	= self newGlobal (f generator downcast (*ObjectSymbol))
		end
		
		e generator = value
	end
	return value

end
//[cf]
//[of]:getStructure
function getStructure (e: *StructureExpression)

	var value = e generator downcast (*PGlobalValue)
	if value isNil
		var structure	= e structure
		
		// Pass 1: scan recursively
		var iter	: ExpressionIterator
		iter initialize (e values)
		self readStructure (structure, iter)
		
		// Pass 2: creates the object
		iter restart (e values)
		var object = self objectFile createStatic
		var align = sizeToUnsigned (structure align)
		self objectFile beginObject (object, self objectFile dataSection, align)
		self writeStructure (structure, iter)
		self objectFile endObject (object)
		
		value = self newGlobal (object symbol)
		e generator = value
	end
	return value

end
//[cf]
//[of]:getArray
function getArray (e: *ArrayExpression)

	var value = e generator downcast (*PGlobalValue)
	if value isNil
		
		var arrayType	= e arrayType
		
		// Pass 1: scan recursively
		var iter : ExpressionIterator
		iter initialize (e values)
		self readArray (arrayType, iter)
		
		// Pass 2: creates the object
		iter restart (e values)
		var object = self objectFile createStatic
		var align = sizeToUnsigned (arrayType align)
		self objectFile beginObject (object, self objectFile dataSection, align)
		self writeArray (arrayType, iter)
		self objectFile endObject (object)
		
		value = self newGlobal (object symbol)
		e generator = value
	end
	return value

end
//[cf]
//[of]:getString8
function getString8 (e: *String8Expression)

	var value = e generator downcast (*PGlobalValue)
	if value isNil
		var object = self objectFile getString8 (e value)
		value = self newGlobal (object symbol)
		e generator = value
	end
	return value

end
//[cf]
//[of]:getString16
function getString16 (e: *String16Expression)

	var value = e generator downcast (*PGlobalValue)
	if value isNil
		var object = self objectFile getString16 (e value)
		value = self newGlobal (object symbol)
		e generator = value
	end
	return value

end
//[cf]
//[of]:getGlobal
//[c]Get the address of a constant global variable (i.e. var v : StructOrArray)
//[c]
function getGlobal (e: *GlobalExpression) : *PValue

	return self getGlobalVariable (e variable)

end
//[cf]
//[of]:getGlobalVariable
//[c]Get the address or content of a global variable
//[c]
function getGlobalVariable (variable: *GlobalVariable)

	var value = pvalue (variable)
	if value isNil
		var initialValue = variable initialValue
		var storageType	= variable storageType
		var object : *ObjectStatic
		var align = sizeToUnsigned (storageType align)
		if initialValue isNil
			// Uninitalized variable
			
			// Creates the object
			object = self objectFile createStatic
			self objectFile beginObject (object, self objectFile dataSection, align)
			// Fill with zeros
			// It should be uninitialized data
			var writer	= self objectFile
			var n = storageType size
			while n > 0
				writer writeByte (0)
				n --
			end
			self objectFile endObject (object)
		else
			// Initialized variable
			
			self readConstant (initialValue)
		
			// Write data
			object = self objectFile createStatic
			self objectFile beginObject (object, self objectFile dataSection, align)
			self writeConstant (initialValue, storageType)
			self objectFile endObject (object)
		end
	
		value = self newGlobal (object symbol)
		var expression = variable expression
		if expression code == 'globalVariable
			var size = sizeCode (variable storageType)
			value	= self newMemory (size, value)
		end
		variable generator = value
	end
	return value

end
//[cf]
//[of]:getScaled
function getScaled (	e	: *BinaryExpression,
	index	: *PValue)

	var indexType	= e argument2 type
	var value	= self getResize (index, indexType, 'dword)
	var factor	= sizeToUnsigned (self cellType (e) size)

	if factor == 1
		return value
	end
	
	if value isInteger
		return self newInteger ('dword, value integer dword smul (factor))
	end
	
	// Default: perform multiplication
	var cellSize	= self newInteger ('dword, factor)
	return self buildMul (value, cellSize)

end
//[cf]
//[of]:getResize
function getResize (value: *PValue, oldType: *Type, newSize: PValueSize)

	var oldSize = value size
	if newSize < oldSize
		var t = self newVariable (nil, newSize)
		self emitTruncate (t, value)
		return t
	elsif newSize > oldSize
		var t = self newVariable (nil, newSize)
		if oldType isSigned
			self emitSext (t, value)
		else
			self emitZext (t, value)
		end
		return t
	else
		return value
	end

end
//[cf]
//[cf]
//[of]:	creating instructions
//[of]:emitAssign
function emitAssign (	dst	: *PValue, 
	src	: *PValue )

	if src isI or src isR
		self emitStore (dst, src)
	elsif dst isR
		self emitLoad (dst, src)
	else
		var t = self emitLoadAuto (src)
		self emitStore (dst, t)
	end

end
//[cf]
//[of]:emitTruncate
function emitTruncate (value1: *PValue, value2: *PValue) :

	if value1 size == value2 size
		self emitAssign (value1, value2)
		return
	end
	
	if value2 size == 'qword
		self emitTruncate (value1, value2 low)
		return
	end
	
	var v1 = self forceR (value1)
	var v2 = self forceRM (value2)
	self emitBinary ('truncate, v1, v2)

end
//[cf]
//[of]:emitSext
function emitSext (value1: *PValue, value2: *PValue) :

	if value1 size == value2 size
		self emitAssign (value1, value2)
		return
	end
	
	if value1 size == 'qword
		var t = self newVariable (nil, 'dword)
		self emitSext (t, value2)
		self emitLda (t)
		self emitCdq
		self emitStore (value1 low, *PRegisterValue : 'eax)
		self emitStore (value1 high, *PRegisterValue : 'edx)
		return
	end
	
	var v1 = self forceR (value1)
	var v2 = self forceRM (value2)
	self emitBinary ('movsx, v1, v2)

end
//[cf]
//[of]:emitZext
function emitZext (value1: *PValue, value2: *PValue) :

	if value1 size == value2 size
		self emitAssign (value1, value2)
		return
	end
	
	if value1 size == 'qword
		self emitZext (value1 low, value2)
		self emitStore (value1 high, zeroValue32)
		return
	end
	
	var v1 = self forceR (value1)
	var v2 = self forceRM (value2)
	self emitBinary ('movzx, v1, v2)

end
//[cf]
//[of]:emitAdd
function emitAdd (v1: *PValue, v2: *PValue)
	self emitAddSub ('add, v1, v2)
end
//[cf]
//[of]:emitSub
function emitSub (v1: *PValue, v2: *PValue)
	self emitAddSub ('sub, v1, v2)
end
//[cf]
//[of]:emitSmul
function emitSmul (v1: *PValue, v2: *PValue)

	var size = v1 size

	if size == 'qword
		self emitOp64 ('umul64, v1, v1, v2)
		return
	end

	if v2 isInteger
		var imm = v2 integer dword
		
		// Multiply by one
		if imm == 1
			return
		end
		
		// Multiply by power of two
		var pow = self shift (imm)
		if pow <> 0
			self emitShl (v1, self newInteger ('byte, pow))
			return
		end
	end
	
	// Byte size requires the use of the accumulator
	if size == 'byte
		var b = self forceRM (v2)
		self emitLda (v1)
		self emitUnary ('smul, b)
		self emitStore (v1, size accumulator)
		return
	end

	var u = self forceRMI (v2)
	if v1 isR
		self emitBinary ('smul2, v1, u)
	else
		var t = self emitLoadAuto (v1)
		self emitBinary ('smul2, t, u)
		self emitStore (v1, t)
	end

end
//[cf]
//[of]:emitUmul
function emitUmul (t: *PValue, v1: *PValue, v2: *PValue)
	self emitScale ('umul, t, v1, v2)
end
//[cf]
//[of]:emitSdiv
function emitSdiv (t: *PValue, v1: *PValue, v2: *PValue)
	self emitScale ('sdiv, t, v1, v2)
end
//[cf]
//[of]:emitUdiv
function emitUdiv (t: *PValue, v1: *PValue, v2: *PValue)
	self emitScale ('udiv, t, v1, v2)
end
//[cf]
//[of]:emitSmod
function emitSmod (t: *PValue, v1: *PValue, v2: *PValue)
	self emitModulo ('smod, t, v1, v2)
end
//[cf]
//[of]:emitUmod
function emitUmod (t: *PValue, v1: *PValue, v2: *PValue)
	self emitModulo ('umod, t, v1, v2)
end
//[cf]
//[of]:emitShl
function emitShl (v1: *PValue, v2: *PValue)
	self emitShift ('shl, v1, v2)
end
//[cf]
//[of]:emitSshr
function emitSshr (v1: *PValue, v2: *PValue)
	self emitShift ('sshr, v1, v2)
end
//[cf]
//[of]:emitUshr
function emitUshr (v1: *PValue, v2: *PValue)
	self emitShift ('ushr, v1, v2)
end
//[cf]
//[of]:emitAnd
function emitAnd (v1: *PValue, v2: *PValue)
	self emitLogical ('and, v1, v2)
end
//[cf]
//[of]:emitOr
function emitOr (v1: *PValue, v2: *PValue)
	self emitLogical ('or, v1, v2)
end
//[cf]
//[of]:emitXor
function emitXor (v1: *PValue, v2: *PValue)
	self emitLogical ('xor, v1, v2)
end
//[cf]
//[of]:emitNot
function emitNot (v: *PValue)

	if v size == 'qword
		self emitUnary ('not, self forceRM (v low))
		self emitUnary ('not, self forceRM (v high))
		return
	end
	
	self emitUnary ('not, self forceRM (v))

end
//[cf]
//[of]:emitNeg
function emitNeg (v: *PValue)

	if v size == 'qword
		var low = self forceRM (v low)
		var high = self forceRM (v high)
		self emitUnary ('neg, high)
		self emitUnary ('neg, low)
		self emitBinary ('sbb, high, zeroValue32)
		return
	end
		
	self emitUnary ('neg, self forceRM (v))

end
//[cf]
//[of]:emitCmp
//[c]Emit a comparison instruction to setup the flags
//[c]
//[c]PARAMETERS
//[c]	code	--	the kind of comparison
//[c]	v1	--	the first value
//[c]	v2	--	the second value
//[c]
//[c]RETURN VALUES
//[c]	The condition flags to check the result of the comparison
//[c]
function emitCmp (code: ConditionFlags, v1: *PValue, v2: *PValue)

	if v1 size == 'qword
		self emitPush (v2)
		self emitPush (v1)
		self emitBuiltinCall ('cmp64)
		return code
	end
		
	var left = v1
	var right = v2
	var swapped = false
	
	if left isI
		left, right = right, left
		swapped = true
	end
	left = self forceRM (left)
	right = self forceRMI (right)

	// Comparing a register to zero can be optimized
	if left isR and right isInteger and right integer isNull and (code == 'z or code == 'nz)
		self emitTest (left, left)
	else
		if left isM and right isM
			right = self emitLoadAuto (right)
		end
		self emitBinary ('cmp, left, right)
	end
	return swapped cond code swap else code

end
//[cf]
//[of]:emitTest
function emitTest (v1: *PValue, v2: *PValue)

	var left = self forceRM (v1)
	var right = self forceRI (v2)
	self emitBinary ('test, left, right)

end
//[cf]

//[of]:emitAddSub
//[c]Emit add/sub 8/16/32/64
//[c]
function emitAddSub (code: PInstructionCode, v1: *PValue, v2: *PValue)

	if v1 size == 'qword
		if v1 isM and v2 isM
			self emitBinary (code, v1 low, self emitLoadAuto (v2 low))
			self emitBinary (code + 1, v1 high, self emitLoadAuto (v2 high))
		else
			self emitBinary (code, v1 low, v2 low)
			self emitBinary (code + 1, v1 high, v2 high)
		end
		return
	end
	
	if v1 isM and v2 isM
		self emitBinary (code, v1, self emitLoadAuto (v2))
	elsif v1 isR and v2 isX and v2 index scale == 1
		self emitBinary (code, v1, v2 index base)
		if v2 index index notNil
			self emitBinary (code, v1, v2 index index)
		end
		if v2 index offset <> 0
			self emitBinary (code, v1, self newInteger ('dword, v2 index offset))
		end
	else
		self emitBinary (code, v1, self forceRMI (v2))
	end

end
//[cf]
//[of]:emitLogical
//[c]Emit and/or/xor 8/16/32/64
//[c]
function emitLogical (code: PInstructionCode, v1: *PValue, v2: *PValue)
	
	if v1 size == 'qword
		if v1 isM and v2 isM
			self emitBinary (code, v1 low , self emitLoadAuto (v2 low))
			self emitBinary (code, v1 high, self emitLoadAuto (v2 high))
		else
			self emitBinary (code, v1 low, v2 low)
			self emitBinary (code, v1 high, v2 high)
		end
		return
	end
	
	if v1 isM and v2 isM
		self emitBinary (code, v1, self emitLoadAuto (v2))
	else
		self emitBinary (code, v1, self forceRMI (v2))
	end

end
//[cf]
//[of]:emitScale
function emitScale (table: *ScaleTable, t: *PValue, v1: *PValue, v2: *PValue)

	var size = t size

	if size == 'qword
		self emitOp64 (table op64, t, v1, v2)
		return
	end

	if v2 isInteger
		var imm = v2 integer dword
		
		// Multiply/Divide by one
		if imm == 1
			self emitLoad (t, v1)
			return
		end
		
		// Multiply/Divide by power of two
		var pow = self shift (imm)
		if pow <> 0
			self emitLoad (t, v1)
			self emitShift (table shift, t, self newInteger ('byte, pow))
			return
		end
	end

	var b = self forceRM (v2)
	self emitLda (v1)
	self emitExtension (table op, v1 size)
	self emitUnary (table op, b)
	self emitStore (t, size accumulator)

end
//[cf]
//[of]:emitModulo
function emitModulo (table: *ModuloTable, t: *PValue, v1: *PValue, v2: *PValue)

	var size = t size

	if size == 'qword
		self emitOp64 (table op64, t, v1, v2)
		return
	end

	if v2 isInteger
		var imm = v2 integer dword
		
		// Multiply/Divide by power of two
		var pow = self shift (imm)
		if pow <> 0
			self emitLoad (t, v1)
			self emitAnd (t, self newInteger (size, imm - 1))
			return
		end
	end

	var b = self forceRM (v2)
	self emitLda (v1)
	self emitExtension (table op, v1 size)
	self emitUnary (table op, b)
	self emitStore (t, size remainder)

end
//[cf]
//[of]:emitExtension
function emitExtension (code: PInstructionCode, size: PValueSize)

	if code == 'udiv
		switch size
		case 'byte
			// ah = 0
			self emitLoad (*PRegisterValue : 'ah, zeroValue8) // eax should be marked with the previous assign
		case 'word
			// dx = 0
			self emitLdd (zeroValue16)
		else
			// edx = 0
			self emitLdd (zeroValue32)
		end
	elsif code == 'sdiv
		switch size
		case 'byte
			self emitCbw
		case 'word
			self emitCwd
		else
			self emitCdq
		end
	end

end
//[cf]
//[of]:emitShift
function emitShift (	table	: *ShiftTable, 
	v1	: *PValue, 
	v2	: *PValue )

	if v1 size == 'qword
		self emitOp64 (table op64, v1, v2, v1)
		return
	end
	
	if v2 isInteger
		var i = self emitInstruction (PShiftInstruction)
		i code	= table imm
		i value1	= v1
		i shift	= v2 integer byte
	else
		self emitLdc (v2)
		self emitUnary (table cl, v1)
	end

end
//[cf]
//[of]:emitOp64
function emitOp64 (id: BuiltinId, t: *PValue, v1: *PValue, v2: *PValue)

	self emitPush (v2)
	self emitPush (v1)
	self emitBuiltinCall (id)
	self emitStore (t low, *PRegisterValue : 'eax)
	self emitStore (t high, *PRegisterValue : 'edx)

end
//[cf]

//[of]:emitSubsp
function emitSubsp (offset: StackOffset)

	var instr = self emitInstruction (PStackInstruction)
	instr code	= 'subsp
	instr offset	= offset

end
//[cf]
//[of]:emitSet
function emitSet (c: ConditionFlags, v: *PValue)

	var instr = self emitInstruction (PSetInstruction)
	instr code	= 'set
	instr condition	= c
	instr value1	= self forceRM (v)

end
//[cf]
//[of]:emitPush
function emitPush (v: *PValue)

	if v size == 'qword
		self emitUnary ('push, v high)
		self emitUnary ('push, v low)
		return
	end
	
	if v size <> 'dword and v isM
		self emitUnary ('push, self emitLoadAuto (v)) 
	else 
		self emitUnary ('push, self forceRMI (v))
	end

end
//[cf]
//[of]:emitPop
function emitPop (v: *PValue)

	if v size == 'qword
		self emitUnary ('pop, v low)
		self emitUnary ('pop, v high)
		return
	end
	
	if v size <> 'dword and v isM
		var t = self newVariable (nil, v size)
		self emitUnary ('pop, t)
		self emitStore (v, t)
	else
		self emitUnary ('pop, v)
	end

end
//[cf]
//[of]:emitLoadAuto
//[c]load r, rmix
//[c]
function emitLoadAuto (src: *PValue)

	var t = self newVariable (nil, src size)
	self emitLoad (t, src)
	return t

end
//[cf]
//[of]:emitLoad
//[c]load r, rmix
//[c]
function emitLoad (dst: *PValue, src: *PValue) :

	if src size == 'qword
		self emitLoad (dst low, src low)
		self emitLoad (dst high, src high)
		return
	end

	if dst == src
		return
	end

	// Assigning an undefined value has no effect
	if src code == 'undefined
		return
	end

	if src code == 'comparison
		var v = src comparison
		var cc = self emitCmp (v flags, v value1, v value2)
		self emitSet (cc, dst)
		return
	end
	
	var instr = self emitInstruction (PBinaryInstruction)
	instr code	= 'load
	instr value1	= dst
	instr value2	= src

end
//[cf]
//[of]:emitStore
//[c]store rm, ri
//[c]
function emitStore (dst: *PValue, src: *PValue) :

	if src size == 'qword
		self emitStore (dst low, src low)
		self emitStore (dst high, src high)
		return
	end
	
	// Assigning an undefined value has no effect
	if src code == 'undefined
		return
	end

	var instr = self emitInstruction (PBinaryInstruction)
	instr code	= 'store
	instr value1	= dst
	instr value2	= src

end
//[cf]
//[of]:emitLda
//[c]This instruction is processed like a regular load, but
//[c]this instruction is flagged as changing the accumulator (eax)
//[c]
function emitLda (src: *PValue)

	if src code == 'comparison
		var v = src comparison
		var cc = self emitCmp (v flags, v value1, v value2)
		self emitSet (cc, *PRegisterValue : 'al)
		return
	end

	var instr = self emitInstruction (PBinaryInstruction)
	instr code	= 'lda
	instr value1	= src size accumulator
	instr value2	= src

end
//[cf]
//[of]:emitLdd
//[c]This instruction is processed like a regular load, but
//[c]this instruction is flagged as changing edx
//[c]
function emitLdd (src: *PValue)

	if src code == 'comparison
		var v = src comparison
		var cc = self emitCmp (v flags, v value1, v value2)
		self emitSet (cc, *PRegisterValue : 'dl)
		return
	end
	
	var instr = self emitInstruction (PBinaryInstruction)
	instr code	= 'ldd
	instr value1	= src size edx
	instr value2	= src

end
//[cf]
//[of]:emitLdc
//[c]This instruction is processed like a regular load, but
//[c]this instruction is flagged as changing ecx
//[c]
function emitLdc (src: *PValue)

	if src code == 'comparison
		var v = src comparison
		var cc = self emitCmp (v flags, v value1, v value2)
		self emitSet (cc, *PRegisterValue : 'cl)
		return
	end
	
	var instr = self emitInstruction (PBinaryInstruction)
	instr code	= 'ldc
	instr value1	= src size ecx
	instr value2	= src

end
//[cf]
//[of]:emitBuiltinCall
function emitBuiltinCall (id: BuiltinId)

	var builtin = self builtins [id]
	builtin used = true
	self emitCall (builtin, 'stdcall, builtin stackOffset)

end
//[cf]
//[of]:emitBuiltinJmp
function emitBuiltinJmp (id: BuiltinId)

	var builtin = self builtins [id]
	builtin used = true
	self emitJumpi (builtin)

end
//[cf]
//[of]:emitCall
function emitCall (	address	: *PValue,
	callingConvention	: CallingConvention,
	argumentStackSize	: StackOffset)

	var instr = self emitInstruction (PCallInstruction)
	instr code	= 'call
	instr value1	= address
	instr callingConvention	= callingConvention
	instr argumentStackSize	= argumentStackSize

end
//[cf]
//[of]:emitCbw
function emitCbw

	var i = self emitInstruction (PInstruction)
	i code = 'cbw

end
//[cf]
//[of]:emitCwd
function emitCwd

	var i = self emitInstruction (PInstruction)
	i code = 'cwd

end
//[cf]
//[of]:emitCdq
function emitCdq

	var i = self emitInstruction (PInstruction)
	i code = 'cdq

end
//[cf]
//[of]:emitJump
function emitJump (label: *PLabel)

	var instr = self emitInstruction (PJumpInstruction)
	instr code	= 'jump
	instr label	= label

end
//[cf]
//[of]:emitJumpC
function emitJumpC (	condition	: ConditionFlags, 
	label	: *PLabel )

	var instr = self emitInstruction (PJumpcInstruction)
	instr code	= 'jumpc
	instr condition	= condition
	instr label	= label

end
//[cf]
//[of]:emitJumpi
function emitJumpi (value: *PValue)

	var instr = self emitInstruction (PUnaryInstruction)
	instr code	= 'jumpi
	instr value1	= value

end
//[cf]
//[of]:emitLabel
function emitLabel (label: *PLabel)
	
	var instr = self emitInstruction (PLabelInstruction)
	instr code	= 'label
	instr label	= label

end
//[cf]

//[of]:emitUnary
function emitUnary (	op	: PInstructionCode,
	value	: *PValue )

	var instr = self emitInstruction (PUnaryInstruction)
	instr code	= op
	instr value1	= value

end
//[cf]
//[of]:emitBinary
function emitBinary (	op	: PInstructionCode,
	value1	: *PValue, 
	value2	: *PValue )

	var instr = self emitInstruction (PBinaryInstruction)
	instr code	= op
	instr value1	= value1
	instr value2	= value2

end
//[cf]
//[of]:emitTernary
function emitTernary (	op	: PInstructionCode,
	value1	: *PValue, 
	value2	: *PValue,
	value3	: *PValue )

	var instr = self emitInstruction (PTernaryInstruction)
	instr code	= op
	instr value1	= value1
	instr value2	= value2
	instr value3	= value3

end
//[cf]
//[of]:emitInstruction
function emitInstruction (T)

	var i = self pool allocate (T)
	i line = self line
	if self instructions isNil
		self instructions = self pool new (Collection (PInstruction))
	end
	self instructions add (i)
	return i

end
//[cf]
//[cf]
//[of]:	creating values
//[of]:newParameter
function newParameter (name: String8, size: PValueSize)

	if size == 'qword
		return self pfunction newParameter64 (name)
	else
		return self pfunction newParameter (name, size)
	end

end
//[cf]
//[of]:newVariable
function newVariable (name: String8, size: PValueSize)

	if size == 'qword
		return self pfunction newVariable64 (name)
	else
		return self pfunction newVariable (name, size)
	end

end
//[cf]
//[of]:newLocal
function newLocal (size: Uinteger)
	return self pfunction newLocal (size)
end
//[cf]
//[of]:newInteger64
function newInteger64 (size: PValueSize, n: Uint64)
	
	if size == 'qword
		return self pfunction newInteger64 (n)
	else
		return self pfunction newInteger (size, n low)
	end

end
//[cf]
//[of]:newInteger
function newInteger (size: PValueSize, n: Uinteger)
	return self pfunction newInteger (size, n)
end
//[cf]
//[of]:newBase
function newBase (size: PValueSize, offset: StackOffset)
	return self pfunction newBase (size, offset)
end
//[cf]
//[of]:newIndex
function newIndex (base: *PValue)
	return self pfunction newIndex (base)
end

function newIndex2 (base: *PValue, offset: Uinteger)
	return self pfunction newIndex2 (base, offset)
end

function newIndex3 (base: *PValue, index: *PValue, scale: Uinteger, offset: Uinteger)
	return self pfunction newIndex3 (base, index, scale, offset)
end
//[cf]
//[of]:newGlobal
function newGlobal (symbol: *ObjectSymbol)

	var v = self pool allocate (PGlobalValue)
	v code	= 'global
	v size	= 'dword
	v symbol	= symbol
	v offset	= 0
	return v

end
//[cf]
//[of]:newFunction
function newFunction (	name	: String8, 
	pfunction	: *PFunction)

	var v = self pool allocate (PFunctionValue)
	v code	= 'function
	v size	= 'dword
	v name	= name
	v pfunction	= pfunction
	return v

end
//[cf]
//[of]:newMemory
//[c]We can't use the newMemory from the function as this function is also
//[c]used for global variables (outside function)
//[c]
function newMemory (size: PValueSize, address: *PValue)

	if size == 'qword
		return self newMemory64 (address)
	else
		return self newMemoryXX (size, address)
	end

end

function newMemoryXX (size: PValueSize, address: *PValue)

	var v = self pool allocate (PMemoryValue)
	v code	= 'memory
	v size	= size
	v address	= address
	return v

end

function newMemory64 (address: *PValue)

	var address4 : *PValue
	
	switch address code
	case 'undefined
		address4 = address
	case 'integer
		address4 = self newInteger ('dword, address integer dword + 4)
	case 'register
		address4 = self newIndex2 (address, 4)
	case 'global
		var v = self pool allocate (PGlobalValue)
		v code	= 'global
		v size	= 'dword
		v symbol	= address glob symbol
		v offset	= address glob offset + 4
		address4	= v
	case 'index
		var v	= address index
		address4 = self newIndex3 (v base, v index, v scale, v offset + 4)
	// These ones are non-sense but could happen with a cast
	// 'function
	// 'builtin
	else
		assertFailure ("memory64: invalid address type")
	end

	var low = self newMemoryXX ('dword, address)
	var high	= self newMemoryXX ('dword, address4)

	return self pool new (PMemoryValue64, low, high)

end
//[cf]
//[of]:newComposite
function newComposite (size: Integer)

	var c = self pool allocateWithArray (PCompositeValue, *PValue, size)
	c code	= 'composite
	c size	= 'composite
	c valuesSize	= size
	return c

end
//[cf]
//[of]:newComparison
function newComparison (value1: *PValue, value2: *PValue, flags: ConditionFlags)

	var c = self pool allocate (PComparisonValue)
	c code	= 'comparison
	c size	= 'byte
	c value1	= value1
	c value2	= value2
	c flags	= flags

	return c

end
//[cf]
//[cf]
//[of]:	creating other
//[of]:newLabel
function newLabel
	return self pfunction newLabel
end
//[cf]
//[of]:newSwitchTable32
function newSwitchTable32 (size: Uinteger)
	return self pfunction newSwitchTable32 (size)
end
//[cf]
//[of]:newLabelReference
function newLabelReference (	object	: *ObjectData,
	offset	: Uinteger,
	label	: *PLabel)

	return self pfunction newLabelReference (object, offset, label)

end
//[cf]
//[cf]
//[of]:	data
//[of]:readStructure
function readStructure (structure: *StructureType, iter: *ExpressionIterator) :

	if structure parentStructure notNil
		self readStructure (structure parentStructure, iter)
	end
	
	structure eachAttribute do a
		self readValue (a storageType, iter)
	end

end
//[cf]
//[of]:readArray
function readArray (arrayType: *ArrayType, iter: *ExpressionIterator)

	var cellType = arrayType cellType
	var n = arrayType arraySize
	var i = Size : 0
	repeat
		if n == 0
			if iter isEOF
				break
			end
		elsif i == n
			break
		end
		
		self readValue (cellType, iter)
		i ++
	end	

end
//[cf]
//[of]:readValue
function readValue (type: *Type, iter: *ExpressionIterator) :

	if type isStructure
		self readStructure (type asStructure, iter)
	elsif type isArray
		self readArray (type asArray, iter)
	else
		self readConstant (iter value)
		iter next
	end

end
//[cf]
//[of]:readConstant
//[c]This function is similar to 'constantValue' but is just to force the creation 
//[c]of dependent objects (strings, sub-arrays and sub-structures).
//[c]
function readConstant (e: *Expression) :

	switch e code
	case 'constantString8
		self getString8 (e asConstantString8)
	case 'constantString16
		self getString16 (e asConstantString16)
	case 'constantStructure
		self getStructure (e asConstantStructure)
	case 'constantArray
		self getArray (e asConstantArray)
	case 'constantFunction
		self getFunction (e asConstantFunction)
	case 'constantGlobal
		self getGlobal (e asConstantGlobal)
	end

end
//[cf]

//[of]:writeStructure
function writeStructure (structure: *StructureType, iter: *ExpressionIterator) :

	var writer	= self objectFile
	var origin = writer nextByte
	
	if structure parentStructure notNil
		self writeStructure (structure parentStructure, iter)
	end

	structure eachAttribute do a
		// Align next attribute
		var n = a offset - (writer nextByte ~ origin)
		while n > 0
			writer writeByte (0)
			n --
		end
		
		self writeValue (a storageType, iter)
	end
	
	// Align the structure
	var o = self objectFile nextByte ~ origin
	var n = o
	n += structure align - 1
	n &= not (structure align - 1)
	n -= o
	while n > 0
		writer writeByte (0)
		n --
	end

end
//[cf]
//[of]:writeArray
function writeArray (arrayType: *ArrayType, iter: *ExpressionIterator)

	var cellType = arrayType cellType
	var n = arrayType arraySize
	var i = Size : 0
	repeat
		if n == 0
			if iter isEOF
				break
			end
		elsif i == n
			break
		end
		
		self writeValue (cellType, iter)
		i ++
	end	

end
//[cf]
//[of]:writeValue
function writeValue (type: *Type, iter: *ExpressionIterator) :

	if type isStructure
		self writeStructure (type asStructure, iter)
	elsif type isArray
		self writeArray (type asArray, iter)
	else
		self writeConstant (iter value, type)
		iter next
	end

end
//[cf]
//[of]:writeConstant
function writeConstant (e: *Expression, type: *Type)

	var obj = self objectFile
	
	switch e code
	case 'constantInteger
		var integer	= e asConstantInteger value
		switch type size
		case 1
			obj writeByte (integer cast (Uint8))
		case 2
			obj writeWord (integer cast (Uint16))
		case 4
			obj writeDword (integer cast (Uinteger))
		else
			obj writeQword (integer)
		end
	case 'constantString8
		obj writeReference ((e asConstantString8 generator downcast (*PGlobalValue)) symbol, 0)
	case 'constantString16
		obj writeReference ((e asConstantString16 generator downcast (*PGlobalValue)) symbol, 0)
	case 'constantStructure
		obj writeReference ((e asConstantStructure generator downcast (*PGlobalValue)) symbol, 0)
	case 'constantArray
		obj writeReference ((e asConstantArray generator downcast (*PGlobalValue)) symbol, 0)
	case 'constantFunction
		obj writeReference ((e asConstantFunction generator downcast (*PGlobalValue)) symbol, 0)
	case 'constantGlobal
		obj writeReference ((self getGlobal (e asConstantGlobal) downcast (*PGlobalValue)) symbol, 0)
	else
		assertFailure ("unknown constant type")
	end

end
//[cf]
//[cf]

//[of]:	ShiftTable
static struct ShiftTable

	var op64	: BuiltinId	// The builtin shift function to call for 64 bit size
	var imm	: PInstructionCode	// The instruction code to use when shifting with an immediate value
	var cl	: PInstructionCode	// The instruction code to use when shifting with register cl

	'shl	= {'shl64, 'shli, 'shlc}
	'sshr	= {'sar64, 'sshri, 'sshrc}
	'ushr	= {'shr64, 'ushri, 'ushrc}

end
//[cf]
//[of]:	ScaleTable
static struct ScaleTable

	var op64	: BuiltinId	// The builtin shift function to call for 64 bit size
	var op	: PInstructionCode	// The instruction code to use
	var shift	: *ShiftTable	// The shift table to use when scaling with a power of two

	'umul	= {'umul64, 'umul, 'shl}
	'sdiv	= {'sdiv64, 'sdiv, 'sshr}
	'udiv	= {'udiv64, 'udiv, 'ushr}

end
//[cf]
//[of]:	ModuloTable
static struct ModuloTable

	var op64	: BuiltinId	// The builtin shift function to call for 64 bit size
	var op	: PInstructionCode	// The instruction code to use

	'smod	= {'smod64, 'sdiv}
	'umod	= {'umod64, 'udiv}

end
//[cf]
//[of]:	InlineContext
//[c]When generating the code of an inline function, this context provides
//[c]information for returns
//[c]
static struct InlineContext

	var next	: *InlineContext	// The parent context : inline functions can be nested
	var exitLabel	: *PLabel	// Return will jump to this label
	var startUnwind	: *UnwindItem	// Return will unwind up to this label
	var returnValues	: *[] *PValue	// If single return: a pointer to an array to store the values of the unique return
			// otherwise: it contains the return variables: the return variables will be assign to them
	var singleReturn	: Bool	// The function being inlined has at most one return statement
			
end
//[cf]
//[of]:	LeaveContext
//[c]Information to exit from a block instruction ('leave).
//[c]
static struct LeaveContext

	var exitLabel	: *PLabel	// Return will jump to this label
	var startUnwind	: *UnwindItem	// Return will unwind up to this label
	var returnValues	: *[] *PValue	// If single return: a pointer to an array to store the values of the unique return
			// otherwise: it contains the return variables: the return variables will be assign to them
end
//[cf]
//[of]:	PWhile
//[c]Extra information for a while statement, it provides information for breaks
//[c]
static struct PWhile

	var exitLabel	: *PLabel	// Break will jump to this label
	var continueLabel	: *PLabel	// Continue will jump to this label
	var startUnwind	: *UnwindItem	// Break & continue will unwind up to this label
			
end
//[cf]

end
//[cf]
//[of]:Utility Functions
//[of]:sizeCode
//[c]Converts a size in bytes into an enum PValueSize
//[c]
//[c]	The size is assumed to be the size of a variable, it shouldn't be
//[c]	over 8 bytes.
//[c]
function sizeCode (type: *Type)
	return size_codes [type size]
end

const size_codes = *[] PValueSize : {
	'byte,	// 0
	'byte,	// 1
	'word,	// 2
	'byte,	// 3
	'dword,	// 4
	'byte,	// 5
	'byte,	// 6
	'byte,	// 7
	'qword }	// 8
//[cf]
//[of]:canInline
function canInline (f: *Function)

	var instructions = f body instructions
	// Do not inline if more than one instruction
	if instructions size > 1
		return false
	end

	instructions each do i
		// Do not inline if instruction with inner block
		if i code <> 'return
			return false
		end
	end
	
	return true

end
//[cf]
//[cf]
//[of]:Builtins
stype BuiltinId : Int32
	'lookup
	'cmp64
	'umul64
	'sdiv64
	'udiv64
	'smod64
	'umod64
	'shl64
	'shr64
	'sar64
	
	'max
end

struct BuiltinItem
	var name	: String8
	var code	: Bytes
	var size	: Uinteger
	var stackOffset	: StackOffset
end

const builtin_table = *[]BuiltinItem : {
	"__lookup",	lookup_function,	lookup_size,	0,
	"__cmp64",	cmp64_function,	cmp64_size,	16,
	"__umul64",	umul64_function,	umul64_size,	16,
	"__sdiv64",	sdiv64_function,	sdiv64_size,	16,
	"__udiv64",	udiv64_function,	udiv64_size,	16,
	"__smod64",	smod64_function,	smod64_size,	16,
	"__umod64",	umod64_function,	umod64_size,	16,
	"__shl64",	shl64_function,	shl64_size,	12,
	"__shr64",	shr64_function,	shr64_size,	12,
	"__sar64",	sar64_function,	sar64_size,	12,
	nil,	nil,	0,	0 }

const cmp64_size = Uinteger : 36
const cmp64_function = *[cmp64_size] Byte : {
	0x8B, 0x44, 0x24, 0x08,
	0x3B, 0x44, 0x24, 0x10,
	0x75, 0x17,
	0x8B, 0x44, 0x24, 0x04,
	0x3B, 0x44, 0x24, 0x0C,
	0x74, 0x0D,
	0x66, 0xB8, 0x01, 0x02,
	0x77, 0x05,
	0x38, 0xE0,
	0xC2, 0x10, 0x00,
	0x38, 0xC4,
	0xC2, 0x10, 0x00}

const umul64_size = Uinteger : 41
const umul64_function = *[umul64_size] Byte : {
	0x53,
	0x8B, 0x44, 0x24, 0x08,
	0xF7, 0x64, 0x24, 0x10,
	0x89, 0xC3,
	0x89, 0xD1,
	0x8B, 0x44, 0x24, 0x08,
	0xF7, 0x64, 0x24, 0x14,
	0x01, 0xC1,
	0x8B, 0x44, 0x24, 0x0C,
	0xF7, 0x64, 0x24, 0x10,
	0x01, 0xC1,
	0x89, 0xD8,
	0x89, 0xCA,
	0x5B,
	0xC2, 0x10, 0x00}

const udiv64_size = Uinteger : 0x60
const udiv64_function = *[udiv64_size] Byte : {
	0x53,                   
	0x83, 0x7c, 0x24, 0x14, 0x00,       
	0x75, 0x1a,                
	0x8b, 0x5c, 0x24, 0x10,          
	0x31, 0xd2,                
	0x8b, 0x44, 0x24, 0x0c,          
	0xf7, 0xf3,                
	0x89, 0xc1,                
	0x8b, 0x44, 0x24, 0x08,          
	0xf7, 0xf3,                
	0x89, 0xca,                
	0x5b,                   
	0xc2, 0x10, 0x00,             
	0x56,                   
	0x57,                   
	0x55,                   
	0x8b, 0x44, 0x24, 0x14,          
	0x8b, 0x54, 0x24, 0x18,          
	0x8b, 0x74, 0x24, 0x1c,          
	0x8b, 0x7c, 0x24, 0x20,          
	0x31, 0xc9,                
	0x31, 0xdb,                
	0xbd, 0x40, 0x00, 0x00, 0x00,       
	0xd1, 0xe0,                
	0xd1, 0xd2,                
	0xd1, 0xd3,                
	0xd1, 0xd1,                
	0x39, 0xf9,                
	0x77, 0x06,                
	0x72, 0x0a,                
	0x39, 0xf3,                
	0x72, 0x06,                
	0x29, 0xf3,                
	0x19, 0xf9,                
	0x0c, 0x01,                
	0x4d,                   
	0x75, 0xe5,                
	0x5d,                   
	0x5f,                   
	0x5e,                   
	0x5b,                   
	0xc2, 0x10, 0x00}

const sdiv64_size = Uinteger : 169
const sdiv64_function = *[sdiv64_size] Byte : {
	0x53,
	0x31, 0xc9,
	0x8b, 0x54, 0x24, 0x14,
	0x09, 0xd2,
	0x7d, 0x16,
	0x8b, 0x44, 0x24, 0x10,
	0xf7, 0xda,
	0xf7, 0xd8,
	0x83, 0xda, 0x00,
	0x89, 0x44, 0x24, 0x10,
	0x89, 0x54, 0x24, 0x14,
	0x83, 0xf1, 0x01,
	0x8b, 0x54, 0x24, 0x0c,
	0x09, 0xd2,
	0x7d, 0x16,
	0x8b, 0x44, 0x24, 0x08,
	0xf7, 0xda,
	0xf7, 0xd8,
	0x83, 0xda, 0x00,
	0x89, 0x44, 0x24, 0x08,
	0x89, 0x54, 0x24, 0x0c,
	0x83, 0xf1, 0x01,
	0x51,
	0x83, 0x7c, 0x24, 0x18, 0x00,
	0x75, 0x18,
	0x8b, 0x5c, 0x24, 0x14,
	0x31, 0xd2,
	0x8b, 0x44, 0x24, 0x10,
	0xf7, 0xf3,
	0x89, 0xc1,
	0x8b, 0x44, 0x24, 0x0c,
	0xf7, 0xf3,
	0x89, 0xca,
	0xeb, 0x3a,
	0x56,
	0x57,
	0x55,
	0x8b, 0x44, 0x24, 0x18,
	0x8b, 0x54, 0x24, 0x1c,
	0x8b, 0x74, 0x24, 0x20,
	0x8b, 0x7c, 0x24, 0x24,
	0x31, 0xc9,
	0x31, 0xdb,
	0xbd, 0x40, 0x00, 0x00, 0x00,
	0xd1, 0xe0,
	0xd1, 0xd2,
	0xd1, 0xd3,
	0xd1, 0xd1,
	0x39, 0xf9,
	0x77, 0x06,
	0x72, 0x0a,
	0x39, 0xf3,
	0x72, 0x06,
	0x29, 0xf3,
	0x19, 0xf9,
	0x0c, 0x01,
	0x4d,
	0x75, 0xe5,
	0x5d,
	0x5f,
	0x5e,
	0x59,
	0x09, 0xc9,
	0x74, 0x07,
	0xf7, 0xda,
	0xf7, 0xd8,
	0x83, 0xda, 0x00,
	0x5b,
	0xc2, 0x10, 0x00}

const umod64_size = Uinteger : 0x66
const umod64_function = *[umod64_size] Byte : {
	0x53,                   
	0x83, 0x7c, 0x24, 0x14, 0x00,       
	0x75, 0x1c,                
	0x8b, 0x5c, 0x24, 0x10,          
	0x31, 0xd2,                
	0x8b, 0x44, 0x24, 0x0c,          
	0xf7, 0xf3,                
	0x89, 0xc1,                
	0x8b, 0x44, 0x24, 0x08,          
	0xf7, 0xf3,                
	0x89, 0xd0,                
	0x31, 0xd2,                
	0x5b,                   
	0xc2, 0x10, 0x00,             
	0x56,                   
	0x57,                   
	0x55,                   
	0x8b, 0x44, 0x24, 0x14,          
	0x8b, 0x54, 0x24, 0x18,          
	0x8b, 0x74, 0x24, 0x1c,          
	0x8b, 0x7c, 0x24, 0x20,          
	0x31, 0xc9,                
	0x31, 0xdb,                
	0xbd, 0x40, 0x00, 0x00, 0x00,       
	0xd1, 0xe0,                
	0xd1, 0xd2,                
	0xd1, 0xd3,                
	0xd1, 0xd1,                
	0x39, 0xf9,                
	0x77, 0x06,                
	0x72, 0x0a,                
	0x39, 0xf3,                
	0x72, 0x06,                
	0x29, 0xf3,                
	0x19, 0xf9,                
	0x0c, 0x01,                
	0x4d,                   
	0x75, 0xe5,                
	0x89, 0xd8,                
	0x89, 0xca,                
	0x5d,                   
	0x5f,                   
	0x5e,                   
	0x5b,                   
	0xc2, 0x10, 0x00}

const smod64_size = Uinteger : 172
const smod64_function = *[smod64_size] Byte : {
	0x53,
	0x31, 0xc9,
	0x8b, 0x54, 0x24, 0x14,
	0x09, 0xd2,
	0x7d, 0x13,
	0x8b, 0x44, 0x24, 0x10,
	0xf7, 0xda,
	0xf7, 0xd8,
	0x83, 0xda, 0x00,
	0x89, 0x44, 0x24, 0x10,
	0x89, 0x54, 0x24, 0x14,
	0x8b, 0x54, 0x24, 0x0c,
	0x09, 0xd2,
	0x7d, 0x16,
	0x8b, 0x44, 0x24, 0x08,
	0xf7, 0xda,
	0xf7, 0xd8,
	0x83, 0xda, 0x00,
	0x89, 0x44, 0x24, 0x08,
	0x89, 0x54, 0x24, 0x0c,
	0x83, 0xf1, 0x01,
	0x51,
	0x83, 0x7c, 0x24, 0x18, 0x00,
	0x75, 0x1a,
	0x8b, 0x5c, 0x24, 0x14,
	0x31, 0xd2,
	0x8b, 0x44, 0x24, 0x10,
	0xf7, 0xf3,
	0x89, 0xc1,
	0x8b, 0x44, 0x24, 0x0c,
	0xf7, 0xf3,
	0x89, 0xd0,
	0x31, 0xd2,
	0xeb, 0x3e,
	0x56,
	0x57,
	0x55,
	0x8b, 0x44, 0x24, 0x18,
	0x8b, 0x54, 0x24, 0x1c,
	0x8b, 0x74, 0x24, 0x20,
	0x8b, 0x7c, 0x24, 0x24,
	0x31, 0xc9,
	0x31, 0xdb,
	0xbd, 0x40, 0x00, 0x00, 0x00,
	0xd1, 0xe0,
	0xd1, 0xd2,
	0xd1, 0xd3,
	0xd1, 0xd1,
	0x39, 0xf9,
	0x77, 0x06,
	0x72, 0x0a,
	0x39, 0xf3,
	0x72, 0x06,
	0x29, 0xf3,
	0x19, 0xf9,
	0x0c, 0x01,
	0x4d,
	0x75, 0xe5,
	0x89, 0xd8,
	0x89, 0xca,
	0x5d,
	0x5f,
	0x5e,
	0x59,
	0x09, 0xc9,
	0x74, 0x07,
	0xf7, 0xda,
	0xf7, 0xd8,
	0x83, 0xda, 0x00,
	0x5b,
	0xc2, 0x10, 0x00}

const shl64_size = Uinteger : 49
const shl64_function = *[shl64_size] Byte : {
	0x8B, 0x44, 0x24, 0x08,
	0x8B, 0x54, 0x24, 0x0C,
	0x8B, 0x4C, 0x24, 0x04,
	0x80, 0xF9, 0x40,
	0x73, 0x19,
	0x80, 0xF9, 0x20,
	0x73, 0x08,
	0x0F, 0xA5, 0xC2,
	0xD3, 0xE0,
	0xC2, 0x0C, 0x00,
	0x89, 0xC2,
	0x31, 0xC0,
	0x80, 0xE9, 0x20,
	0xD3, 0xE2,
	0xC2, 0x0C, 0x00,
	0x31, 0xD2,
	0x31, 0xC0,
	0xC2, 0x0C, 0x00}

const shr64_size = Uinteger : 49
const shr64_function = *[shr64_size] Byte : {
	0x8B, 0x44, 0x24, 0x08,
	0x8B, 0x54, 0x24, 0x0C,
	0x8B, 0x4C, 0x24, 0x04,
	0x80, 0xF9, 0x40,
	0x73, 0x19,
	0x80, 0xF9, 0x20,
	0x73, 0x08,
	0x0F, 0xAD, 0xD0,
	0xD3, 0xEA,
	0xC2, 0x0C, 0x00,
	0x80, 0xE9, 0x20,
	0x89, 0xD0,
	0xD3, 0xE8,
	0x31, 0xD2,
	0xC2, 0x0C, 0x00,
	0x31, 0xD2,
	0x31, 0xC0,
	0xC2, 0x0C, 0x00}

const sar64_size = Uinteger : 51
const sar64_function = *[sar64_size] Byte : {
	0x8B, 0x44, 0x24, 0x08,
	0x8B, 0x54, 0x24, 0x0C,
	0x8B, 0x4C, 0x24, 0x04,
	0x80, 0xF9, 0x40,
	0x73, 0x1A,
	0x80, 0xF9, 0x20,
	0x73, 0x08,
	0x0F, 0xAD, 0xD0,
	0xD3, 0xFA,
	0xC2, 0x0C, 0x00,
	0x80, 0xE9, 0x20,
	0x89, 0xD0,
	0xD3, 0xF8,
	0xC1, 0xFA, 0x1F,
	0xC2, 0x0C, 0x00,
	0xC1, 0xFA, 0x1F,
	0x89, 0xD0,
	0xC2, 0x0C, 0x00}

const lookup_size = Uinteger : 21
const lookup_function = *[lookup_size] Byte : {
	0x83, 0xE9, 0x08,
	0x83, 0xC1, 0x08,
	0x83, 0x79, 0x04, 0x00,
	0x74, 0x07,
	0x39, 0x01,
	0x75, 0xF3,
	0xFF, 0x61, 0x04,
	0xFF, 0x21}
//[cf]
//[cf]

//[of]:P-Code
//[of]:PFunction
struct PFunction

	var inlining	: Bool	// The function is being inlined
	var inline	: Bool	// The function should be inlined
	var called	: Bool	// The function is called, referenced or exported (we must generate the non-inline version of the function)
	var ignore	: Bool	// The function must not be generated in pass 2 as it is never called
	var returnStackSize	: Uinteger	// The size to be allocated on stack for return values (excluding the first return value)
	var equivalent	: *Function	// The function is a duplicate of this one (or nil)
			
	var pool	: *MemoryPool	// The memory pool to store elements
	var parameters	: Collection (PVariable)	// The list of parameters
	var variables	: Collection (PVariable)	// The list of local variables
	var instructions	: Collection (PInstruction)	// The list of instructions
	var labels	: Collection (PLabel)	// The list of labels
	var references	: Collection (PLabelReference)	// The list of switch tables
	var object	: *ObjectFunction	// The storage in the object file
	var comparing	: Bool	// Detect recursion when comparing functions
	var parameterStackSize	: Uinteger	// The number of bytes allocated on stack by the parameters
	var localStackOffset	: Uinteger	// The number of bytes allocated on stack by the locals and variables

//[of]:	initialize - release
//[of]:initialize
function initialize (f: *Function, debug: Bool)

	self inlining	= false
	self called	= f entry	// Force 'called' flag if the function is an entry point
	self ignore	= f isMacro	// Never attempt to generate the code of an iterator alone
	self inline	= canInline (f)
	self equivalent	= nil

	// Compute the number of bytes to allocate on stack for return values
	var size = Uinteger : 0
	var first = true
	f returnTypes each do type
		if not first
			size += stackAligned (sizeToUnsigned (type size))
		end
		first = false
	end
	self returnStackSize = size

end
//[cf]
//[of]:reset
function reset (	f	: *Function, 
	pool	: *MemoryPool,
	object	: *ObjectFile,
	section	: *ObjectSection,
	debug	: Bool)

	self pool	= pool
	self object	= nil
	self comparing	= false
	self parameterStackSize	= 0
	self localStackOffset	= 0
	self parameters	initialize
	self variables	initialize
	self instructions	initialize
	self labels	initialize
	self references	initialize
	self object	= self ignore cond nil else object createFunction (f, section, debug)

end
//[cf]
//[cf]
//[of]:	accessing
//[of]:master
//[c]Returns the master
//[c]
//[c]If two functions are equivalents, return the first one
//[c]otherwise returns self
//[c]
function master
	return self equivalent notNil cond pfunction (self equivalent) else self
end
//[cf]
//[of]:hash
function hash

	var hash = Size : 0
	self instructions each do i
		hash *= 33
		hash += i hash
	end
	
	return hash

end
//[cf]
//[cf]
//[of]:	operations
//[of]:alloca
function alloca (size: Uinteger)

	// Get current position on stack
	var offset = self localStackOffset
	
	// Allocate
	offset -= stackAligned (size)
	
	// Update position on stack
	self localStackOffset = offset

	return offset

end
//[cf]
//[of]:computeIntervals
function computeIntervals

	self variables each do v
		v firstIndex = invalidInstructionIndex
	end
	
	self parameters each do p
		p firstIndex = 0
	end
	
	var index = InstructionIndex : 0
	self instructions each do instruction
		self markVariables (instruction, index)
		index ++
	end

end
//[cf]
//[of]:prepareVariables
//[c]Allocates spilled local variables on stack
//[c]
function prepareVariables

	self variables each do v
		// For debugging purpose: force spilled
		//v spilled = true
		
		if v spilled
			var local = self newLocal (v size toStackSize)
			v value = self newMemory (v size, local)
		end
	end

end
//[cf]
//[of]:prepareParameters
function prepareParameters

	var offset = stackOrigin + 4
	self parameters each do p
		p value = self newBase (p size, offset)
		offset += p size toStackSize
	end

end
//[cf]
//[cf]
//[of]:	adding - removing
//[of]:newParameter
function newParameter (	name	: String8, 
	size	: PValueSize)

	var p = self pool new (	PParameter,
		name,
		self parameters size,
		size)
	self parameters add (p)
	self parameterStackSize += p size toStackSize
	return p

end
//[cf]
//[of]:newVariable
function newVariable (	name	: String8, 
	size	: PValueSize)

	var pvariable = self pool new (	PVariable,
		name,
		self variables size,
		size)
	self variables add (pvariable)
	return pvariable

end
//[cf]
//[of]:newLabel
function newLabel

	var plabel = self pool new (PLabel, self labels size)
	self labels add (plabel)
	return plabel

end
//[cf]

//[of]:newInteger
function newInteger (	size	: PValueSize,
	n	: Uinteger)

	var v = self pool allocate (PIntegerValue)
	v code	= 'integer
	v size	= size
	v value	= n cast (Uint64)
	return v

end
//[cf]
//[of]:newLocal
function newLocal (size: Uinteger)

	var offset = self alloca (size)
	return self newIndex2 (*PRegisterValue : 'local, offset)

end
//[cf]
//[of]:newBase
function newBase (size: PValueSize, offset: StackOffset)

	var index = self newIndex2 (*PRegisterValue : 'base, offset)
	return self newMemory (size, index)

end
//[cf]
//[of]:newIndex
function newIndex (base: *PValue)

	var value = self pool allocate (PIndexValue)
	value code	= 'index
	value size	= 'dword
	value base	= base
	value index	= nil
	value scale	= 1
	value offset	= 0
	return value

end

function newIndex2 (base: *PValue, offset: Uinteger)

	var value = self pool allocate (PIndexValue)
	value code	= 'index
	value size	= 'dword
	value base	= base
	value index	= nil
	value scale	= 1
	value offset	= offset
	return value

end

function newIndex3 (base: *PValue, index: *PValue, scale: Uinteger, offset: Uinteger)

	var value = self pool allocate (PIndexValue)
	value code	= 'index
	value size	= 'dword
	value base	= base
	value index	= index
	value scale	= scale
	value offset	= offset
	return value

end
//[cf]
//[of]:newMemory
function newMemory (size: PValueSize, address: *PValue)

	var v = self pool allocate (PMemoryValue)
	v code	= 'memory
	v size	= size
	v address	= address
	return v

end
//[cf]

//[of]:newParameter64
function newParameter64 (name: String8)

	var low	= self newParameter (name, 'dword)
	var high	= self newParameter (name, 'dword)

	return self pool new (PParameter64, low, high)

end
//[cf]
//[of]:newVariable64
function newVariable64 (name: String8)

	var low	= self newVariable (name, 'dword)
	var high	= self newVariable (name, 'dword)

	return self pool new (PVariable64, low, high)

end
//[cf]
//[of]:newInteger64
function newInteger64 (n: Uint64)

	var low = self newInteger ('dword, n low)
	var high	= self newInteger ('dword, n high)

	return self pool new (PIntegerValue64, low, high)

end
//[cf]

//[of]:newSwitchTable32
function newSwitchTable32 (size: Uinteger)

	var table = self pool allocateBytes (size cast (Size) * SwitchItem32 size + SwitchTable32 size) cast (*SwitchTable32)
	table initialize (size)
	return table

end
//[cf]
//[of]:newLabelReference
function newLabelReference (	object	: *ObjectData,
	offset	: Uinteger,
	label	: *PLabel)

	var reference = self pool new (PLabelReference, object, offset, label)
	self references add (reference)
	return reference

end
//[cf]
//[cf]
//[of]:	output
//[of]:addToStringBuffer
function addToStringBuffer (sb: *StringBuffer)

	sb << String : "Parameters:"
	sb << CodeUnit : 'lf
	self parameters each do v
		sb << CodeUnit : 'tab
		sb << v
		sb << CodeUnit : 'tab
		sb << v size
		sb << CodeUnit : 'tab
		sb << v firstIndex
		sb << CodeUnit : 'tab
		sb << v lastIndex
		sb << CodeUnit : 'tab
		sb << v spilled
		sb << CodeUnit : 'tab
		sb << v referenceCount
		sb << CodeUnit : 'lf
	end
	sb << CodeUnit : 'lf

	sb << String : "Variables:"
	sb << CodeUnit : 'lf
	self variables each do v
		sb << CodeUnit : 'tab
		sb << v
		sb << CodeUnit : 'tab
		sb << v size
		sb << CodeUnit : 'tab
		sb << v firstIndex
		sb << CodeUnit : 'tab
		sb << v lastIndex
		sb << CodeUnit : 'tab
		sb << v spilled
		sb << CodeUnit : 'tab
		sb << v referenceCount
		sb << CodeUnit : 'lf
	end
	sb << CodeUnit : 'lf
	
	sb << String : "Instructions:"
	sb << CodeUnit : 'lf
	var index = Uinteger : 0
	self instructions each do i
		sb << index
		sb << CodeUnit : 'tab
		sb << i
		sb << CodeUnit : 'lf
		index ++
	end

end
//[cf]
//[cf]
//[of]:	testing
//[of]:isEqual
function isEqual (other: *PFunction) : Bool
	
	if self == other
		return true
	end
	
	// Can't compare recursive functions
	if self comparing
		return false
	end

	// Check the number of arguments
	// Instructions could be identical but the number
	// of arguments could differs requiring a different
	// code in stdcall
	if self parameters size <> other parameters size
		return false
	end
	
	self comparing = true
	var eq = isEqualInstructions (self instructions, other instructions)
	self comparing = false
	return eq

end
//[cf]
//[cf]
	
//[of]:	private
//[of]:markVariables
//[c]Marks all variables referenced in the given instruction
//[c]
function markVariables (instruction: *PInstruction, index: InstructionIndex)

	switch instruction code
	
	case	'load, 'lda, 'ldd, 'ldc, 'store, 
		'truncate, 'movsx, 'movzx,
		'add, 'sub, 'adc, 'sbb, 'smul2, 'and, 'or, 'xor, 'cmp, 'test
	
		var i = instruction binary
		i value1 markVariables (index)
		i value2 markVariables (index)
	
	case	'smul, 'umul, 'sdiv, 'udiv,
		'not, 'neg, 'set,
		'push, 'pop,
		'shli, 'sshri, 'ushri, 'shlc, 'sshrc, 'ushrc,
		'call, 'jumpi
	
		var i = instruction unary
		i value1 markVariables (index)

	case 'smul3

		var i = instruction ternary
		i value1 markVariables (index)
		i value2 markVariables (index)
		i value3 markVariables (index)
	
	case 'subsp
		// No variable, nothing to do

	case 'label
		instruction label label index = index

	case 'jump
		self extendVariables (instruction jump, index)
	
	case 'jumpc
		self extendVariables (instruction jumpc, index)
	
	end

end
//[cf]
//[of]:extendVariables
//[c]Extends the range of all variables actives at the label targetted by the jump
//[c]to the index of the jump (the index argument).
//[c]
function extendVariables (jump: *PJumpInstruction, index: InstructionIndex)

	var labelIndex = jump label index
	// We are only interested in backward jumps, forward jumps are
	// not set yet.
	if labelIndex <> invalidInstructionIndex
		self variables each do v
			// If the variable is active at the label: extend the range
			if v firstIndex <= labelIndex and v lastIndex > labelIndex // '>' as the lastIndex is the index of the instruction + 1
				v lastIndex = index
			end
		end

		self parameters each do p
			// If the parameter is active at the label: extend the range
			if p lastIndex > labelIndex // '>' as the lastIndex is the index of the instruction + 1
				p lastIndex = index
			end
		end
	end

end
//[cf]
//[cf]

end
//[cf]
//[of]:PLabel
//[c]A label defines a position in the code of a function.
//[c]
//[c]It is possible to jump to a label in the same function but it is not
//[c]possible to jump to a label defined in another function.
//[c]
struct PLabel : CollectionElement (PLabel)

	var id	: Integer
	var index	: InstructionIndex
	
	// Native Code Generator
	var offset	: Uinteger	// x86: address relative to the beginning of the function

//[of]:	initialize - release
//[of]:initialize
function initialize (id: Integer)

	self id	= id
	self index	= invalidInstructionIndex
	self offset	= undefined_address

end
//[cf]
//[cf]
//[of]:	accessing
//[of]:relativeOffset
function relativeOffset (position: Uinteger)
	return self offset - (position + 4)
end
//[cf]
//[cf]
//[of]:	testing
//[of]:isDefined
function isDefined
	return self offset <> undefined_address
end
//[cf]
//[cf]
//[of]:	output
//[of]:addToStringBuffer
function addToStringBuffer (sb: *StringBuffer)

	sb << CodeUnit : $L
	sb << self id

end
//[cf]
//[cf]

end
//[cf]
//[of]:SwitchTable32
struct SwitchTable32 : CollectionElement (SwitchTable32)

	var size	: Uinteger
	var choices	: [] SwitchItem32

//[of]:	initialize - release
//[of]:initialize
function initialize (size: Uinteger)
	self size = size
end
//[cf]
//[cf]
//[of]:	accessing
//[of]:setCase
function setCase (	index	: Integer, 
	value	: Integer, 
	label	: *PLabel)

	self choices [index] value	= value
	self choices [index] label	= label

end
//[cf]
//[cf]
//[of]:	enumerating
//[of]:each
function each

	self size each do i
		var item = self choices [i]
		yield item value, item label
	end

end
//[cf]
//[cf]

end
//[cf]
//[of]:SwitchItem32
struct SwitchItem32
	var value	: Integer
	var label	: *PLabel
end
//[cf]
//[of]:PLabelReference
struct PLabelReference	: CollectionElement (PLabelReference)

	var object	: *ObjectData	// The object containing the reference to the label
	var offset	: Uinteger	// The position of the reference in the object
	var label	: *PLabel	// The target label

//[of]:	initialize - release
//[of]:initialize
function initialize (	object	: *ObjectData,
	offset	: Uinteger,
	label	: *PLabel)

	self object	= object
	self offset	= offset
	self label	= label

end
//[cf]
//[cf]

end
//[cf]
//[of]:Utils
//[of]:isEqualInstructions
function isEqualInstructions (	self	: *Collection (PInstruction), 
	other	: *Collection (PInstruction))

	var n = self size
	if n <> other size
		return false
	end

	zip (self, other) do i1, i2
		if not i1 isEqual (i2)
			return false
		end
	end

	return true

end
//[cf]
//[cf]
//[of]:UnwindItem
struct UnwindItem
	var next	: *UnwindItem	// The next item to unwind
	var block	: *Block	// The block to evaluate
end
//[cf]
//[cf]
//[of]:P-Instruction
//[of]:PInstructionCode
stype PInstructionCode

	'load	// load	r, rmix
	'lda	// load	r, rmix where r is al, ax or eax
	'ldd	// load	r, rmix where r is dl, dx or edx
	'ldc	// load	r, rmix where r is cl, cx or ecx
	'store	// store	rm, ri
	'truncate	// truncate	r, rm
	'movsx	// movsx	r, rm
	'movzx	// movzx	r, rm
	'add	// add	r, rmi
		// add	rm, ri
	'adc	// add	r, rmi -- must be 'add + 1
		// add	rm, ri
	'sub	// sub	r, rmi
		// sub	rm, ri
	'sbb	// add	r, rmi -- must be 'sub + 1
		// add	rm, ri
	'smul	// smul	rm
	'smul2	// smul	r, rmi
	'smul3	// smul	r, rm, i
	'umul	// umul	rm
	'sdiv	// sdiv	rm
	'udiv	// udiv	rm
	'shli	// shl	rm, i8
	'shlc	// shl	rm, cl
	'sshri	// sshri	rm, i8
	'sshrc	// sshrc	rm, cl
	'ushri	// ushri	rm, i8
	'ushrc	// ushrc	rm, cl
	'and	// and	r, rmi
		// and	rm, ri
	'or	// or	r, rmi
		// or	rm, ri
	'xor	// xor	r, rmi
		// xor	rm, ri
	'cmp	// cmp	r, rmi
		// cmp	rm, ri
	'not	// not	rm
	'neg	// neg	rm
	'test	// test	rm, ri
	'set	// set	rm
	'push	// push	rmi	-- only 32 bit with memory value
	'pop	// pop	rm	-- only 32 bit with memory value
	'subsp	// sub	esp, imm
	'call	// call	rmi
	'jumpi	// jump	rmi
	'cbw	// cbw
	'cwd	// cwd
	'cdq	// cdq
	'label	// label	L
	'jump	// jump	L
	'jumpc	// jump	cc, L

end

const instruction_names = *[]String : {
	"load",
	"load",
	"load",
	"load",
	"store",
	"trunc",
	"movsx",
	"movzx",
	"add",
	"adc",
	"sub",
	"sbb",
	"smul",
	"smul",
	"smul",
	"umul",
	"sdiv",
	"udiv",
	"shl",
	"shlc",
	"sshr",
	"sshrc",
	"ushr",
	"ushrc",
	"and",
	"or",
	"xor",
	"cmp",
	"not",
	"neg",
	"test",
	"set",
	"push",
	"pop",
	"subsp",
	"call",
	"jump", 
	"cbw",
	"cwd",
	"cdq",
	"", // label
	"", // jump
	""} // jump c

const instruction_registers = *[]RegisterMask : {
	'none,	// load	r, rmix
	'eax,	// lda	r, rmix
	'edx,	// ldd	r, rmix
	'ecx,	// ldc	r, rmix
	'none,	// store	rm, ri
	'none,	// truncate	r, rm
	'none,	// movsx	r, rm
	'none,	// movzx	r, rm
	'none,	// add	r, rmi
	'none,	// adc	r, rmi
	'none,	// sub	r, rmi
	'none,	// sbb	r, rmi
	'eax | 'edx,	// smul	rm
	'none,	// smul	r, rmi
	'none,	// smul	r, rm, i
	'eax | 'edx,	// umul	rm
	'eax | 'edx,	// sdiv	rm
	'eax | 'edx,	// udiv	rm
	'none,	// shl	rm, i8
	'cl,	// shl	rm, cl
	'none,	// sshri	rm, i8
	'cl,	// sshrc	rm, cl
	'none,	// ushri	rm, i8
	'cl,	// ushrc	rm, cl
	'none,	// and	r, rmi
	'none,	// or	r, rmi
	'none,	// xor	r, rmi
	'none,	// cmp	r, rmi
	'none,	// not	rm
	'none,	// neg	rm
	'none,	// test	rm, ri
	'none,	// set	rm
	'none,	// push	rmi	-- 8 bit does not works with memory value
	'none,	// pop	rm	-- 8 bit does not works with memory value
	'none,	// sub	esp, imm
	'eax | 'edx | 'ecx,	// call	rmi
	'eax | 'edx | 'ecx,	// jump	rmi
	'eax,	// cbw
	'edx,	// cwd
	'edx,	// cdq
	'none,	// label	L
	'none,	// jump	L
	'none}	// jump	cc, L

const cmp_none	= ref alwaysYes (*PInstruction, *PInstruction)
const cmp_un	= ref (*PUnaryInstruction) isEqual (*PUnaryInstruction)
const cmp_bin	= ref (*PBinaryInstruction) isEqual (*PBinaryInstruction)
const cmp_ter	= ref (*PTernaryInstruction) isEqual (*PTernaryInstruction)
const cmp_shift	= ref (*PShiftInstruction) isEqual (*PShiftInstruction)
const cmp_set	= ref (*PSetInstruction) isEqual (*PSetInstruction)
const cmp_stack	= ref (*PStackInstruction) isEqual (*PStackInstruction)
const cmp_call	= ref (*PCallInstruction) isEqual (*PCallInstruction)
const cmp_label	= ref (*PLabelInstruction) isEqual (*PLabelInstruction)
const cmp_jump	= ref (*PJumpInstruction) isEqual (*PJumpInstruction)
const cmp_jumpc	= ref (*PJumpcInstruction) isEqual (*PJumpcInstruction)

const instructionComparisonTable = *[] & (*PInstruction, *PInstruction) -> (Bool) : {
	cmp_bin,	// load	r, rmix
	cmp_bin,	// lda	r, rmix
	cmp_bin,	// ldd	r, rmix
	cmp_bin,	// ldc	r, rmix
	cmp_bin,	// store	rm, ri
	cmp_bin,	// truncate	r, rm
	cmp_bin,	// movsx	r, rm
	cmp_bin,	// movzx	r, rm
	cmp_bin,	// add	r, rmi
	cmp_bin,	// adc	r, rmi
	cmp_bin,	// sub	r, rmi
	cmp_bin,	// sbb	r, rmi
	cmp_un,	// smul	rm
	cmp_bin,	// smul	r, rmi
	cmp_ter,	// smul	r, rm, i
	cmp_un,	// umul	rm
	cmp_un,	// sdiv	rm
	cmp_un,	// udiv	rm
	cmp_shift,	// shl	rm, i8
	cmp_un,	// shl	rm, cl
	cmp_shift,	// sshri	rm, i8
	cmp_un,	// sshrc	rm, cl
	cmp_shift,	// ushri	rm, i8
	cmp_un,	// ushrc	rm, cl
	cmp_bin,	// and	r, rmi
	cmp_bin,	// or	r, rmi
	cmp_bin,	// xor	r, rmi
	cmp_bin,	// cmp	r, rmi
	cmp_un,	// not	rm
	cmp_un,	// neg	rm
	cmp_bin,	// test	rm, ri
	cmp_set,	// set	rm
	cmp_un,	// push	rmi	-- 8 bit does not works with memory value
	cmp_un,	// pop	rm	-- 8 bit does not works with memory value
	cmp_stack,	// sub	esp, imm
	cmp_call,	// call	rmi
	cmp_un,	// jump	rmi
	cmp_none,	// cbw
	cmp_none,	// cwd
	cmp_none,	// cdq
	cmp_label,	// label	L
	cmp_jump,	// jump	L
	cmp_jumpc}	// jump	cc, L

//[cf]
//[of]:PInstruction
struct PInstruction : CollectionElement (PInstruction)

	var code	: PInstructionCode
	var line	: LineNumber

//[of]:	accessing
//[of]:hash
function hash

	switch self code
	case	'load, 'lda, 'ldd, 'ldc,
		'store,
		'truncate,
		'movsx,
		'movzx,
		'add,
		'sub,
		'adc,
		'sbb,
		'smul2,
		'and,
		'or,
		'xor,
		'cmp,
		'test
	
		var i = self binary
		return i value1 hash + i value2 hash
		
	case	'push,
		'pop,
		'smul,
		'umul,
		'sdiv,
		'udiv,
		'shlc,
		'sshrc,
		'ushrc,
		'not,
		'neg,
		'jumpi
	
		var i = self unary
		return i value1 hash
		
	else
		return self code cast (Size)
	end

end
//[cf]
//[cf]
//[of]:	testing
//[of]:isFollowedByLabel
function isFollowedByLabel (label: *PLabel)

	var next = self nextSibling
	
	// No more instruction
	if next isNil
		return false
	end
	
	// Not a label
	if next code <> 'label
		return false
	end
	
	// Compare labels
	return next label label == label

end
//[cf]
//[of]:isEqual
function isEqual (other: *PInstruction)

	if self code <> other code
		return false
	end
	return instructionComparisonTable [self code] call (self, other)

end
//[cf]
//[cf]
//[of]:	downcasting
//[of]:label
function label
	return self downcast (*PLabelInstruction)
end
//[cf]
//[of]:unary
function unary
	return self downcast (*PUnaryInstruction)
end
//[cf]
//[of]:binary
function binary
	return self downcast (*PBinaryInstruction)
end
//[cf]
//[of]:ternary
function ternary
	return self downcast (*PTernaryInstruction)
end
//[cf]
//[of]:shift
function shift
	return self downcast (*PShiftInstruction)
end
//[cf]
//[of]:jump
function jump
	return self downcast (*PJumpInstruction)
end
//[cf]
//[of]:jumpc
function jumpc
	return self downcast (*PJumpcInstruction)
end
//[cf]
//[of]:set
function set
	return self downcast (*PSetInstruction)
end
//[cf]
//[of]:stack
function stack
	return self downcast (*PStackInstruction)
end
//[cf]
//[of]:call
function call
	return self downcast (*PCallInstruction)
end
//[cf]
//[cf]
//[of]:	output
//[of]:addToStringBuffer
function addToStringBuffer (sb: *StringBuffer) :

	switch self code
	case	'load, 'lda, 'ldd, 'ldc,
		'store,
		'truncate,
		'movsx,
		'movzx,
		'add,
		'sub,
		'adc,
		'sbb,
		'smul2,
		'and,
		'or,
		'xor,
		'cmp,
		'test
	
		sb << self binary

	case	'push,
		'pop,
		'smul,
		'umul,
		'sdiv,
		'udiv,
		'shlc,
		'sshrc,
		'ushrc,
		'not,
		'neg,
		'jumpi
	
		sb << self unary

	case 'smul3
		sb << self ternary

	case 'call
		sb << self call
	case 'shli, 'sshri, 'ushri
		sb << self shift
	case 'set
		sb << self set
	case 'cbw, 'cwd, 'cdq
		sb << CodeUnit : 'tab
		sb << instruction_names [self code]
	case 'label
		sb << self label
	case 'jump
		sb << self jump
	case 'jumpc
		sb << self jumpc
	case 'subsp
		sb << self stack
	end

end
//[cf]
//[cf]

end
//[cf]
//[of]:PLabelInstruction
struct PLabelInstruction : PInstruction

	var label	: *PLabel

	function addToStringBuffer (sb: *StringBuffer)
		sb << self label
		sb << CodeUnit : $:
	end

	function isEqual (other: *PLabelInstruction)
		return self label id == other label id
	end

end
//[cf]
//[of]:PUnaryInstruction
struct PUnaryInstruction : PInstruction

	var value1	: *PValue

	function addToStringBuffer (sb: *StringBuffer)
		sb << CodeUnit : 'tab
		sb << instruction_names [self code]
		sb << CodeUnit : 'tab
		sb << self value1
	end

	function isEqual (other: *PUnaryInstruction)
		return self value1 isEqual (other value1)
	end

end
//[cf]
//[of]:PBinaryInstruction
struct PBinaryInstruction : PUnaryInstruction

	var value2	: *PValue

	function addToStringBuffer (sb: *StringBuffer) :
		sb << CodeUnit : 'tab
		sb << instruction_names [self code]
		sb << CodeUnit : 'tab
		sb << self value1
		sb << CodeUnit : $,
		sb << CodeUnit : 'space
		sb << self value2
	end

	function isEqual (other: *PBinaryInstruction)
		return	self value1 isEqual (other value1) and
			self value2 isEqual (other value2)
	end

end
//[cf]
//[of]:PTernaryInstruction
struct PTernaryInstruction : PBinaryInstruction

	var value3	: *PValue

	function addToStringBuffer (sb: *StringBuffer)
		sb << CodeUnit : 'tab
		sb << instruction_names [self code]
		sb << CodeUnit : 'tab
		sb << self value1
		sb << CodeUnit : $,
		sb << CodeUnit : 'space
		sb << self value2
		sb << CodeUnit : $,
		sb << CodeUnit : 'space
		sb << self value3
	end
	
	function isEqual (other: *PTernaryInstruction)
		return	self value1 isEqual (other value1) and 
			self value2 isEqual (other value2) and
			self value3 isEqual (other value3)
	end

end
//[cf]
//[of]:PShiftInstruction
struct PShiftInstruction : PUnaryInstruction

	var shift	: Byte

	function addToStringBuffer (sb: *StringBuffer)
		sb << CodeUnit : 'tab
		sb << instruction_names [self code]
		sb << CodeUnit : 'tab
		sb << self value1
		sb << CodeUnit : $,
		sb << CodeUnit : 'space
		sb << self shift cast (Uinteger)
	end

	function isEqual (other: *PShiftInstruction)
		return	self value1 isEqual (other value1) and
			self shift == other shift
	end

end
//[cf]
//[of]:PJumpInstruction
struct PJumpInstruction : PInstruction

	var label	: *PLabel

	function addToStringBuffer (sb: *StringBuffer)
		sb << CodeUnit : 'tab
		sb << String : "jump"
		sb << CodeUnit : 'tab
		sb << self label
	end

	function isEqual (other: *PJumpInstruction)
		return self label id == other label id
	end

end
//[cf]
//[of]:PJumpcInstruction
struct PJumpcInstruction : PJumpInstruction

	var condition	: ConditionFlags	// The boolean value, must be a comparison or a simple value

	function addToStringBuffer (sb: *StringBuffer)
		sb << CodeUnit : 'tab
		sb << String : "j"
		sb << self condition
		sb << CodeUnit : 'tab
		sb << self label
	end

	function isEqual (other: *PJumpcInstruction)
		return	self label id == other label id and
			self condition == other condition
	end

end
//[cf]
//[of]:PSetInstruction
struct PSetInstruction : PUnaryInstruction

	var condition	: ConditionFlags

	function addToStringBuffer (sb: *StringBuffer)
		sb << CodeUnit : 'tab
		sb << String : "set"
		sb << self condition
		sb << CodeUnit : 'tab
		sb << self value1
	end

	function isEqual (other: *PSetInstruction)
		return	self value1 isEqual (other value1) and
			self condition == other condition
	end

end
//[cf]
//[of]:PStackInstruction
struct PStackInstruction : PInstruction

	var offset	: StackOffset

	function addToStringBuffer (sb: *StringBuffer)
		sb << CodeUnit : 'tab
		sb << instruction_names [self code]
		sb << CodeUnit : 'tab
		sb << self offset
	end

	function isEqual (other: *PStackInstruction)
		return self offset == other offset
	end

end
//[cf]
//[of]:PCallInstruction
struct PCallInstruction : PUnaryInstruction

	var callingConvention	: CallingConvention
	var argumentStackSize	: StackOffset

	function addToStringBuffer (sb: *StringBuffer)
		sb << CodeUnit : 'tab
		sb << String : "call"
		sb << CodeUnit : 'tab
		sb << self value1
		sb << String : ", "
		sb << self callingConvention
		sb << String : ", "
		sb << self argumentStackSize
	end

	function isEqual (other: *PCallInstruction)
		return	self callingConvention == other callingConvention and
			self argumentStackSize == other argumentStackSize and
			self value1 isEqual (other value1)
	end

end
//[cf]
//[cf]
//[of]:P-Value
//[of]:PValueCode
stype PValueCode : Byte

	'register	// r
	'variable	// r
	'parameter	// r
	'memory	// m
	'integer	// i
	'undefined	// i
	'global	// i
	'function	// i
	'builtin	// i
	'index	// x (r + r * s + i)
	'interval	// Temporary value during register allocation
	'comparison	// This one never appears in p-instructions
	'composite	// This one never appears in p-instructions
		
	'variable64	// 
	'parameter64	//
	'integer64	//
	'memory64	//

end
//[cf]
//[of]:PValueSize
stype PValueSize : Byte
	'byte
	'word
	'dword
	'qword
	'composite	// Unused, for composite only, equivalent to undefined
	
	static const stackSizeTable	= *[] Uinteger	: {4,	4,	4,	8	}
	static const accumulatorTable	= *[] *PRegisterValue	: {'al,	'ax,	'eax		}
	static const edxTable	= *[] *PRegisterValue	: {'dl,	'dx,	'edx		}
	static const ecxTable	= *[] *PRegisterValue	: {'cl,	'cx,	'ecx		}
	static const remainderTable	= *[] *PRegisterValue	: {'ah,	'dx,	'edx,	nil	}
	
	function addToStringBuffer (sb: *StringBuffer)
		var s : String
		switch self
		case 'byte
			s = "byte"
		case 'word
			s = "word"
		case 'dword
			s = "dword"
		case 'qword
			s = "qword"
		else
			s = "*invalid*"
		end
		sb << s
	end

	function toStackSize
		return stackSizeTable [self]
	end

	function accumulator
		return accumulatorTable [self]
	end

	function edx
		return edxTable [self]
	end

	function ecx
		return ecxTable [self]
	end

	function remainder
		return remainderTable [self]
	end

end
//[cf]
//[of]:PValue
struct PValue

	var code	: PValueCode
	var size	: PValueSize

//[of]:	accessing
//[of]:hash
function hash : Size

	switch self code
	case 'memory
		return self memory address hash
	case 'integer
		return self integer value cast (Size)
	else
		return self code cast (Size)
	end

end
//[cf]
//[of]:leftIndex
//[c]Returns the code class
//[c]	'register	0
//[c]	'memory	1
//[c]
function leftIndex : Integer
	return self code == 'register cond 0 else 1
end
//[cf]
//[of]:rightIndex
//[c]Returns the code class
//[c]
//[c]	'register	0
//[c]	'memory	1
//[c]	immediate values	2
//[c]
function rightIndex : Integer

	return	self code == 'register cond 0 else
		self code == 'memory cond 1 else
		2

end
//[cf]
//[of]:markVariables
function markVariables (index: InstructionIndex) :

	switch self code
	case 'variable, 'parameter
		var v = self variable
		v incReferenceCount
		if v firstIndex == invalidInstructionIndex
			v firstIndex	= index + 1
			v lastIndex	= index + 1
		else
			v lastIndex	= index
		end
	
	case 'memory
		self memory address markVariables (index)
		
	case 'index
		var base = self index base
		if base notNil
		 	base markVariables (index)
		end
		var idx = self index index
		if idx notNil
			idx markVariables (index)
		end
	
	end

end
//[cf]
//[of]:addRank
//[c]x < r < m < i
//[c]
function addRank : Integer

	switch self code
	case 'index // x
		return 0
	case 'register, 'variable, 'parameter // r
		return 1
	case 'memory // m
		return 2
	else // i
		return 3
	end

end
//[cf]
//[of]:low
function low

	switch self code
	case 'integer64
		return self integer64 low
	case 'variable64, 'parameter64
		return self variable64 low
	case 'memory64
		return self memory64 low
	case 'undefined
		return undefinedValue32
	else
		output ("Invalid 64 bit value")
		return nil
	end

end
//[cf]
//[of]:high
function high

	switch self code
	case 'integer64
		return self integer64 high
	case 'variable64, 'parameter64
		return self variable64 high
	case 'memory64
		return self memory64 high
	case 'undefined
		return undefinedValue32
	else
		output ("Invalid 64 bit value")
		return nil
	end

end
//[cf]
//[cf]
//[of]:	downcasting
//[of]:register
function register
	return self downcast (*PRegisterValue)
end
//[cf]
//[of]:integer
function integer
	return self downcast (*PIntegerValue)
end
//[cf]
//[of]:memory
function memory
	return self downcast (*PMemoryValue)
end
//[cf]
//[of]:glob
function glob
	return self downcast (*PGlobalValue)
end
//[cf]
//[of]:func
function func
	return self downcast (*PFunctionValue)
end
//[cf]
//[of]:builtin
function builtin
	return self downcast (*PBuiltinValue)
end
//[cf]
//[of]:variable
function variable
	return self downcast (*PVariable)
end
//[cf]
//[of]:parameter
function parameter
	return self downcast (*PParameterValue)
end
//[cf]
//[of]:composite
function composite
	return self downcast (*PCompositeValue)
end
//[cf]
//[of]:index
function index
	return self downcast (*PIndexValue)
end
//[cf]
//[of]:interval
function interval
	return self downcast (*PIntervalValue)
end
//[cf]
//[of]:comparison
function comparison
	return self downcast (*PComparisonValue)
end
//[cf]

//[of]:integer64
function integer64
	return self downcast (*PIntegerValue64)
end
//[cf]
//[of]:variable64
function variable64
	return self downcast (*PVariable64)
end
//[cf]
//[of]:memory64
function memory64
	return self downcast (*PMemoryValue64)
end
//[cf]
//[cf]
//[of]:	output
//[of]:addToStringBuffer
function addToStringBuffer (sb: *StringBuffer)

	// Bug in the compiler: an infinite recursion makes it unable to 
	// compile this function
	if false
		return
	end
	
	var outputTable = *[] & (*PValue, *StringBuffer) : {
		ref (*PRegisterValue)	addToStringBuffer	(*StringBuffer),	// 'register
		ref (*PVariable)	addToStringBuffer	(*StringBuffer),	// 'variable
		ref (*PVariable)	addToStringBuffer	(*StringBuffer),	// 'parameter
		ref (*PMemoryValue)	addToStringBuffer	(*StringBuffer),	// 'memory
		ref (*PIntegerValue)	addToStringBuffer	(*StringBuffer),	// 'integer
		ref (*PValue)	addUndefinedToStringBuffer	(*StringBuffer),	// 'undefined
		ref (*PGlobalValue)	addToStringBuffer	(*StringBuffer),	// 'global
		ref (*PFunctionValue)	addToStringBuffer	(*StringBuffer),	// 'function
		ref (*PBuiltinValue)	addToStringBuffer	(*StringBuffer),	// 'builtin
		ref (*PIndexValue)	addToStringBuffer	(*StringBuffer),	// 'index
		ref (*PIntervalValue)	addToStringBuffer	(*StringBuffer)}	// 'interval
	
	outputTable [self code] call (self, sb)

end
	
function addUndefinedToStringBuffer (sb: *StringBuffer)
	sb << CodeUnit : $?
end
//[cf]
//[cf]
//[of]:	testing
//[of]:isInteger
function isInteger
	return self code == 'integer
end
//[cf]
//[of]:isRegister
function isRegister
	return self code == 'register
end
//[cf]
//[of]:isConstant
function isConstant
	return self code in ('integer, 'global)
end
//[cf]
//[of]:isEqual
function isEqual (other: *PValue) : Bool

	if self isNil
		return other isNil
	elsif other isNil
		return false 
	elsif self code <> other code
		return false
	elsif self size <> other size
		return false 
	end
	
	switch self code
	case 'register
		return self register number == other register number
	case 'variable, 'parameter
		return self variable id == other variable id
	case 'memory
		return self memory address isEqual (other memory address)
	case 'integer
		return self integer value == other integer value
	case 'undefined
		return true
	case 'global
		return self glob symbol == other glob symbol and self glob offset == other glob offset
	case 'function
		return self func pfunction isEqual (other func pfunction)
	case 'builtin
		return self builtin == other builtin
	case 'index
		var v1 = self index
		var v2 = other index
		return	v1 base isEqual (v2 base) and
			v1 index isEqual (v2 index) and
			v1 scale == v2 scale and 
			v1 offset == v2 offset
	else
		assertFailure ("Invalid value when comparing")
		return false
	end

end
//[cf]
//[of]:reduceableToRegister
//[c]Returns true if the value can (will) be reduced to a single register
//[c]without any pre-load.
//[c]
function reduceableToRegister

	// It is already a register
	if self code == 'register
		return true
	end
	
	// It is a non-spilled variable
	if self code == 'interval and not self interval variable spilled
		return true
	end
	
	return false

end
//[cf]

//[of]:isR
function isR
	return	self code == 'register or
		self code == 'variable or
		self code == 'parameter or
		self code == 'variable64 or
		self code == 'parameter64 or
		self code == 'interval
end
//[cf]
//[of]:isI
function isI
	return	self code == 'integer or
		self code == 'undefined or
		self code == 'global or
		self code == 'integer64 or
		self code == 'function
end
//[cf]
//[of]:isX
function isX
	return self code == 'index
end
//[cf]
//[of]:isM
function isM
	return	self code == 'memory or
		self code == 'memory64
end
//[cf]
//[of]:isC
function isC
	return self code == 'comparison
end
//[cf]
//[cf]

end
//[cf]
//[of]:PRegisterValue
struct PRegisterValue : PValue

	var number	: Register	// The x86 register (register XXX)
	var info	: Integer	// Extra information for register

	'eax	= {'register, 'dword,	'eax,	0}
	'ecx	= {'register, 'dword,	'ecx,	1}
	'edx	= {'register, 'dword,	'edx,	2}
	'ebx	= {'register, 'dword,	'ebx,	3}
	'esp	= {'register, 'dword,	'esp,	4}
	'ebp	= {'register, 'dword,	'ebp,	5}
	'esi	= {'register, 'dword,	'esi,	6}
	'edi	= {'register, 'dword,	'edi,	7}
			
	'ax	= {'register, 'word,	'ax,	8}
	'cx	= {'register, 'word,	'cx,	9}
	'dx	= {'register, 'word,	'dx,	10}
	'bx	= {'register, 'word,	'bx,	11}
	'sp	= {'register, 'word,	'sp,	12}
	'bp	= {'register, 'word,	'bp,	13}
	'si	= {'register, 'word,	'si,	14}
	'di	= {'register, 'word,	'di,	15}
			
	'al	= {'register, 'byte,	'al,	16}
	'cl	= {'register, 'byte,	'cl,	17}
	'dl	= {'register, 'byte,	'dl,	18}
	'bl	= {'register, 'byte,	'bl,	19}
	'ah	= {'register, 'byte,	'ah,	20}
	'ch	= {'register, 'byte,	'ch,	21}
	'dh	= {'register, 'byte,	'dh,	22}
	'bh	= {'register, 'byte,	'bh,	23}
			
	'base	= {'register, 'dword,	'base,	0}
	'local	= {'register, 'dword,	'local,	0}

	static struct RegisterInfo
		var register8	: *PRegisterValue	// The x86 8 bit register equivalent (or nil)
		var register16	: *PRegisterValue	// The x86 16 bit register equivalent (or nil for ah, bh, ch and dh)
		var register32	: *PRegisterValue	// The x86 32 bit register equivalent (or nil for ah, bh, ch and dh)
	end
	
	static const registerInfo	= *[]RegisterInfo : {
		'al,	'ax,	'eax,
		'cl,	'cx,	'ecx,
		'dl,	'dx,	'edx,
		'bl,	'bx,	'ebx,
		nil,	'sp,	'esp,
		nil,	'bp,	'ebp,
		nil,	'si,	'esi,
		nil,	'di,	'edi,
				
		'al,	'ax,	'eax,
		'cl,	'cx,	'ecx,
		'dl,	'dx,	'edx,
		'bl,	'bx,	'ebx,
		nil,	'sp,	'esp,
		nil,	'bp,	'ebp,
		nil,	'si,	'esi,
		nil,	'di,	'edi,
				
		'al,	'ax,	'eax,
		'cl,	'cx,	'ecx,
		'dl,	'dx,	'edx,
		'bl,	'bx,	'ebx,
		nil,	nil,	nil,
		nil,	nil,	nil,
		nil,	nil,	nil,
		nil,	nil,	nil}
	
	function addToStringBuffer (sb: *StringBuffer)
		var name : String
		var i = self number
		switch self size
		case 'byte
			name = *[]String : {"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"}[i]
		case 'word
			name = *[]String : {"ax", "cx", "dx", "bx", "sp", "bp", "si", "di"}[i]
		case 'dword
			name = *[]String : {"eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi", "base", "local"}[i]
		case 'qword
			name = *[]String : {"edx:eax", "", "", "ebp:ebx", "", "", "edi:esi", ""}[i]
		end
		sb << name
	end

	function register8
		return registerInfo [self info] register8
	end

	function register16
		return registerInfo [self info] register16
	end

	function register32
		return registerInfo [self info] register32
	end

	function isAccumulator
		return self number == 0
	end

end
//[cf]
//[of]:PVariable
//[c]A value that represent a local variable
//[c]
struct PVariable : PValue

	var nextSibling	: *PVariable	// The next variable in the functions's collection
	var name	: String8	// The name of the variable or nil for anonymous variables
	var id	: Integer	// Number if no name
	var firstIndex	: InstructionIndex	// First index where the variable is referenced
	var lastIndex	: InstructionIndex	// Last index where the variable is referenced
	var referenceCount	: Uinteger	// Number of access to this variable
	var spilled	: Bool	// The variable is spilled (the interval holds a register for a single instruction)
	var interval	: *PIntervalValue	// The current interval of the variable (contains the current register) or nil
	var value	: *PMemoryValue	// The value to access the variable when spilled
	
	function initialize (	name	: String8,
		id	: Integer,
		size	: PValueSize)

		self code	= 'variable	
		self size	= size
		self name	= name
		self id	= id
		self referenceCount	= 0
		self spilled	= false
		self interval	= nil
	end
	
	function _lt (other: *PVariable)
		return self firstIndex < other firstIndex
	end
	
	function incReferenceCount
		self referenceCount ++
	end
	
	function addToStringBuffer (sb: *StringBuffer)
		if self name notNil
			sb << self name << self id
		else
			sb << CodeUnit : $V
			sb << self id
		end
	end

end
//[cf]
//[of]:PParameter
//[c]A value that represent a function parameter
//[c]
//[c]	A parameter is just a variable with a counter of access.
//[c]	
struct PParameter : PVariable

	function initialize (	name	: String8,
		id	: Integer,
		size	: PValueSize)
	
		self code	= 'parameter
		self size	= size
		self name	= name
		self id	= id
		self referenceCount	= 0
		self interval	= nil

	end
	
end
//[cf]
//[of]:PIntegerValue
struct PIntegerValue : PValue

	var value	: Uint64

	function addToStringBuffer (sb: *StringBuffer)
		sb << self dword
	end
		
	function byte
		return self value cast (Uint8)
	end
	
	function word
		return self value cast (Uint16)
	end
	
	function dword
		return self value cast (Uinteger)
	end
	
	function qword
		return self value cast (Uint64)
	end
	
	function isNull
		return self value == 0
	end
	
	function isUnit
		return self value == 1
	end

end
//[cf]
//[of]:PGlobalValue
//[c]Address of a symbol
//[c]
struct PGlobalValue : PValue

	var symbol	: *ObjectSymbol
	var offset	: Uinteger

	function addToStringBuffer (sb: *StringBuffer)
		sb << CodeUnit : $G
		sb << self symbol
		if self offset <> 0
			sb << CodeUnit : $+
			sb << self offset
		end
	end

end
//[cf]
//[of]:PFunctionValue
//[c]Address of a function
//[c]
//[c]An object value is different from a global value as it must not be referenced 
//[c]from a different section, it can be used only as a relative reference: a 
//[c]reference to it is resolved at the end of the compilation and it does not 
//[c]generate a relocation item in the object file.
//[c]
struct PFunctionValue : PValue

	var name	: String8
	var pfunction	: *PFunction

	function addToStringBuffer (sb: *StringBuffer)
		sb << self name
	end

end
//[cf]
//[of]:PBuiltinValue
struct PBuiltinValue : PValue

	var name	: String8
	var data	: Bytes
	var size	: Uinteger
	var used	: Bool
	var stackOffset	: StackOffset	// Offset to add to the stack pointer after calling this builtin
	var object	: *ObjectData

	function initialize (	object	: *ObjectFile,
		name	: String8,
		code	: Bytes, 
		size	: Uinteger,
		offset	: StackOffset)

		self code	= 'builtin	
		self name	= name
		self data	= code
		self size	= size
		self used	= false
		self stackOffset	= offset
		self object	= object createData (code, size)
	end

	function addToStringBuffer (sb: *StringBuffer)
		sb << self name
	end

end
//[cf]
//[of]:PMemoryValue
struct PMemoryValue : PValue

	var address	: *PValue

	function addToStringBuffer (sb: *StringBuffer) :
		sb << self size
		sb << String : " ["
		sb << self address
		sb << CodeUnit : $]
	end

end
//[cf]
//[of]:PIndexValue
struct PIndexValue : PValue

	var base	: *PValue	// The base
	var index	: *PValue	// The index or nil
	var scale	: Uinteger	// 1, 2, 4, 8
	var offset	: Uinteger	// The offset

	function addToStringBuffer (sb: *StringBuffer) :
		
		if self base notNil
			sb << self base
		end
		if self index notNil
			if self base notNil
				sb << String : " + "
			end
			sb << self index
			if self scale <> 1
				sb << String : " * "
				sb << self scale
			end
		end
		if self offset asSigned > 0
			sb << String : " + "
			sb << self offset
		elsif self offset asSigned < 0
			sb << String : " - "
			sb << - self offset
		end

	end

end
//[cf]
//[of]:PCompositeValue
struct PCompositeValue : PValue

	var valuesSize	: Integer	// The number of values.
	var values	: [] *PValue	// The list of values. It must be the last attribute (variable size)

	function _at (index: Integer)
		return self values [index]
	end
	
	function each
		self valuesSize each do i
			yield self [i]
		end
	end

end
//[cf]
//[of]:PIntervalValue
struct PIntervalValue : PValue

	var variable	: *PVariable	// The variable of the interval
	var register	: RegisterId	// The register used by the variable

	function initialize (variable: *PVariable, register: RegisterId)
		self code	= 'interval
		self size	= variable size
		self variable	= variable
		self register	= register
	end
	
	function addToStringBuffer (sb: *StringBuffer)
		sb << self variable
		sb << CodeUnit : $(
		sb << self register
		sb << CodeUnit : $)
		if self variable spilled
			sb << CodeUnit : $*
		end
	end

end
//[cf]
//[of]:PComparisonValue
struct PComparisonValue : PValue

	var value1	: *PValue	// The left value of the comparison
	var value2	: *PValue	// The right value of the comparison
	var flags	: ConditionFlags	// The flags to check for positive comparison

end
//[cf]

//[of]:PVariable64
struct PVariable64 : PValue

	var low	: *PVariable
	var high	: *PVariable
	
	function initialize (low: *PVariable, high: *PVariable)
		self code	= 'variable64
		self size	= 'qword
		self low	= low
		self high	= high
	end

end
//[cf]
//[of]:PParameter64
struct PParameter64 : PVariable64

	function initialize (low: *PVariable, high: *PVariable)
		self code	= 'parameter64
		self size	= 'qword
		self low	= low
		self high	= high
	end

end
//[cf]
//[of]:PIntegerValue64
struct PIntegerValue64 : PValue

	var low	: *PIntegerValue
	var high	: *PIntegerValue
	
	function initialize (low: *PIntegerValue, high: *PIntegerValue)
		self code	= 'integer64
		self size	= 'qword
		self low	= low
		self high	= high
	end

end
//[cf]
//[of]:PMemoryValue64
struct PMemoryValue64 : PValue

	var low	: *PMemoryValue
	var high	: *PMemoryValue
	
	function initialize (low: *PMemoryValue, high: *PMemoryValue)
		self code	= 'memory64
		self size	= 'qword
		self low	= low
		self high	= high
	end

end
//[cf]

//[of]:Constant Values
// Important: These values must never be used in the generator attribute as 
// they can not be shared, they are read-only so the pred attribute can not 
// be modified.

const undefinedValue32	= *PValue : {'undefined, 'dword}
	
const zeroValue8	= *PIntegerValue : {'integer,	'byte,	0}
const zeroValue16	= *PIntegerValue : {'integer,	'word,	0}
const zeroValue32	= *PIntegerValue : {'integer,	'dword,	0}
const zeroValue64	= *PIntegerValue64 : {'integer64,	'qword,	oneValue32, zeroValue32}
	
const oneValue8	= *PIntegerValue : {'integer,	'byte,	1}
const oneValue16	= *PIntegerValue : {'integer,	'word,	1}
const oneValue32	= *PIntegerValue : {'integer,	'dword,	1}
const oneValue64	= *PIntegerValue64 : {'integer64,	'qword,	oneValue32, zeroValue32}
//[cf]
//[cf]
//[of]:P-Constants
//[of]:Address
const Address = Uinteger

const undefined_address	= Address : 0 - 1
//[cf]
//[of]:InstructionIndex
//[c]Unsigned integer type used to number instructions in a function.
//[c]Its main use is to define the interval of variables.
//[c]
const InstructionIndex	= Uinteger

const invalidInstructionIndex = InstructionIndex : 0 - 1
//[cf]
//[of]:StackOffset
const StackOffset	= Uinteger

const stackOrigin = StackOffset : 0
//[cf]
//[of]:RegisterId
stype RegisterId

	'al	// 0
	'ah	// 1
	'bl	// 2
	'bh	// 3
	'cl	// 4
	'ch	// 5
	'dl	// 6
	'dh	// 7
		
	'ax	// 8
	'bx	// 9
	'cx	// 10
	'dx	// 11
	'si	// 12
	'di	// 13
	'bp	// 14
		
	'eax	// 15
	'ebx	// 16
	'ecx	// 17
	'edx	// 18
	'esi	// 19
	'edi	// 20
	'ebp	// 21
		
	'none = -1
	
	static const register_masks = *[]RegisterMask : {
		'al,
		'ah,
		'bl,
		'bh,
		'cl,
		'ch,
		'dl,
		'dh,
		'ax,
		'bx,
		'cx,
		'dx,
		'si,
		'di,
		'bp,
		'eax,
		'ebx,
		'ecx,
		'edx,
		'esi,
		'edi,
		'ebp}

	static const register_clear_masks = *[]RegisterMask : {
		not 'al,
		not 'ah,
		not 'bl,
		not 'bh,
		not 'cl,
		not 'ch,
		not 'dl,
		not 'dh,
		not 'ax,
		not 'bx,
		not 'cx,
		not 'dx,
		not 'si,
		not 'di,
		not 'bp,
		not 'eax,
		not 'ebx,
		not 'ecx,
		not 'edx,
		not 'esi,
		not 'edi,
		not 'ebp}
	
	static const rid_to_register_table = *[] *PRegisterValue : {
		'al,
		'ah,
		'bl,
		'bh,
		'cl,
		'ch,
		'dl,
		'dh,
		'ax,
		'bx,
		'cx,
		'dx,
		'si,
		'di,
		'bp,
		'eax,
		'ebx,
		'ecx,
		'edx,
		'esi,
		'edi,
		'ebp}

	function mask
		return register_masks [self]
	end
	
	function clearMask
		return register_clear_masks [self]
	end

	function registerValue
		return rid_to_register_table [self]
	end
		
	function addToStringBuffer (sb: *StringBuffer)
		if self == 'none
			sb << String : "(none)"
		end
		sb << self registerValue
	end

end
//[cf]
//[of]:RegisterMask
stype RegisterMask : Uinteger

	'none	= 0x0000
		
	'al	= 0x0001
	'ah	= 0x0002
	'bl	= 0x0004
	'bh	= 0x0008
	'cl	= 0x0010
	'ch	= 0x0020
	'dl	= 0x0040
	'dh	= 0x0080
		
	'ax	= 0x0003
	'bx	= 0x000C
	'cx	= 0x0030
	'dx	= 0x00C0
	'si	= 0x0100
	'di	= 0x0200
	'bp	= 0x0400
		
	'eax	= 0x0003
	'ebx	= 0x000C
	'ecx	= 0x0030
	'edx	= 0x00C0
	'esi	= 0x0100
	'edi	= 0x0200
	'ebp	= 0x0400

end
//[cf]
//[of]:ConditionFlags
stype ConditionFlags

	'z	// ==
	'nz	// <>
	'le	// <=
	'be	// <= (unsigned)
	'lt	// <
	'b	// < (unsigned)
	'ge	// >=
	'ae	// >= (unsigned)
	'gt	// >
	'a	// > (unsigned)

	static const names	= *[]String	: {	"z",	"nz",	"le",	"be",	"lt",	"b",	"ge",	"ae",	"gt",	"a"	}
	static const swapTable	= *[]ConditionFlags	: {	'z,	'nz,	'ge,	'ae,	'gt,	'a,	'le,	'be,	'lt,	'b	}
	static const invertTable	= *[]ConditionFlags	: {	'nz,	'z,	'gt,	'a,	'ge,	'ae,	'lt,	'b,	'le,	'be	}
	static const condTable	= *[] Condition	: {	'z,	'nz,	'le,	'be,	'l,	'c,	'ge,	'nc,	'g,	'a	}

	function addToStringBuffer (sb: *StringBuffer)
		sb << names [self]
	end

	function swap
		return swapTable [self]
	end
	
	function invert
		return invertTable [self]
	end

	function code
		return condTable [self]
	end

end
//[cf]
//[cf]
//[of]:X86
//[of]:Utility Functions
//[of]:isShortDisplacement
function isShortDisplacement (x)
	var d = x asSigned
	return d >= -128 and d < 128
end
//[cf]
//[of]:stackAligned
//[c]Returns the given size aligned on a multiple of 32 bits
//[c]
function stackAligned (size: Uinteger)

	var alignedSize	= size
	
	alignedSize	+= stackAlign - 1
	alignedSize	&= not (stackAlign - 1)
	return alignedSize

end

const stackAlign	= Uinteger : 4
//[cf]
//[of]:modrm
function modrm (r: Byte, mod: Byte, rm: Byte)
	return (r << 3) + (mod << 6) + rm
end
//[cf]
//[cf]
//[of]:Constants
//[c]
//[c]Registers
//[c]
stype Register : Byte
	'eax	= 0
	'ecx	= 1
	'edx	= 2
	'ebx	= 3
	'esp	= 4
	'ebp	= 5
	'esi	= 6
	'edi	= 7
		
	'ax	= 0
	'cx	= 1
	'dx	= 2
	'bx	= 3
	'sp	= 4
	'bp	= 5
	'si	= 6
	'di	= 7
		
	'al	= 0
	'cl	= 1
	'dl	= 2
	'bl	= 3
	'ah	= 4
	'ch	= 5
	'dh	= 6
	'bh	= 7
		
	'base	= 8	// fake register that will be translated to esp + n
	'local	= 9	// fake register that will be translated to esp + n
end

//[c]
//[c]Conditions
//[c]
stype Condition : Byte
	'o	= 0
	'c	= 2	// jc, jb (CF=1)
	'nc	= 3
	'z	= 4
	'nz	= 5
	'be	= 6
	'a	= 7
	'l	= 12
	'ge	= 13
	'le	= 14
	'g	= 15
end
//[cf]
//[cf]
//[of]:Program Extensions
function pfunction (x)
	return x generator downcast (*PFunction)
end

function pvariable (x)
	return x generator downcast (*PVariable)
end

function pvalue (x)
	return x generator downcast (*PValue)
end

function pcomposite (x)
	return x generator downcast (*PCompositeValue)
end

function plabel (x)
	return x generator downcast (*PLabel)
end
//[cf]

.private
import "data/object-file-\(backend)"
import "data/program"
import "commons"
import "std"
