//[of]:CodeGenerator
struct CodeGenerator : ObjectFile

	var program	: *Program	// The program to build
	var pool	: MemoryPool	// We still need to allocate stuff
	var debug	: Bool	// Generate debug information
	var dump	: Bool	// Dump p-functions
	var pcodegen	: PCodeGenerator	// Object to generate p-code

//[c]	
//[c]	Register Allocator
//[c]	
	var variables	: SortVector (*PVariable)	// All variables and parameters sorted by firstIndex
	var lockedRegisters	: RegisterMask	// The registers to keep on the current instruction
	var actives	: [maxVariables] *PVariable	// The list of variables having a register sorted by last index
			// This is a sliding list: the first elements are never removed as they
			// are removed in the order of the list, the activeFirst attribute is just
			// updated.
			// But it limits the total amount of local variables to 1024.
	var activeSize	: Integer	// Number of variables in the active list
	var activeFirst	: Integer	// Offset to the first variable not yet inactive
	var registers	: RegisterMask	// The mask of registers currently used.
	var usedRegisters	: RegisterMask	// The registers used at least once.

//[c]
//[c]	Assembler
//[c]
	var lookupBuiltin	: Builtin	// Information for the lookup buitin function
	
	// Variables for function generation
	var loaded	: RegisterMask	// The registers currently loaded (some variables are used twice in a single instruction)
	var callStackSize	: Disp32	// Number of bytes on stack for calls
	var paddingStackSize	: Disp32	// Padding added on stack frame to get a multiple of 16 bytes
	var localStackSize	: Disp32	// Number of bytes for local variables on stack
	var saveRegisterStackSize	: Disp32	// Number of bytes allocated on the stack frame to save registers

	// Variable for switch table generation
	var directBuffer	: *[]*PLabel	// Temporary storage to build a direct table
	var directSize	: Index	// Number of items allocated in directBuffer
	
//[c]	
//[c]	DWARF
//[c]	
	var textSize	: ObjectOffset	// The size of the .text section
	var types	: Collection (DwarfType)	// The list of types to declare
	var debugLineLength	: ObjectOffset	// The size of the section saved at the beginning
	var headerLength	: ObjectOffset	// The size of the header
	var debugModule	: *Module	// The current module
	var debugAddress	: ObjectOffset	// The current address
	var debugLineNumber	: LineNumber	// The current line number -- 0 based (warning: DWARF count from 1)

	static const maxVariables	= Integer : 1024	// Maximum number of variables in a function
	static const dwarfLineBase	= Integer : 0
	static const dwarfLineRange	= Integer : 10
	static const dwarfOpcodeBase	= Integer : 13

//[of]:	initialize - release
//[of]:initialize
function initialize (program: *Program, debug: Bool, dump: Bool)

	const lookup_size = ObjectOffset : 24
	const lookup_function = *[lookup_size] Byte : {
		0x48, 0x83, 0xE9, 0x10,
		0x48, 0x83, 0xC1, 0x10,
		0x48, 0x83, 0x79, 0x08, 0x00,
		0x74, 0x07,
		0x39, 0x01,
		0x75, 0xF1,
		0xFF, 0x61, 0x08,
		0xFF, 0x21}

	self dump = dump
	self debug = debug
	self program = program
	self pool	initialize
	self super initialize (self pool, debug)
	self pcodegen initialize (self pool)
	self variables initializeWithSize (maxVariables, ref (*PVariable) compare (*PVariable))

	self directBuffer = (*PLabel) allocateArray (1024)
	self directSize = 1024
	self lookupBuiltin initialize (self, "__lookup", lookup_function, lookup_size)

	// DWARF
	self types initialize
	self debugLineLength = 0
	self headerLength = 0
	self textSize = 0

end
//[cf]
//[of]:release
function release
	(*PLabel) freeArray (self directBuffer, self directSize)
	self pcodegen release
	self variables release
	self pool release
	self super release
end
//[cf]
//[cf]
//[of]:	generating
//[of]:generate
function generate (filename: String)

	self pcodegen generate (self program, self debug)

	// Remove inlined functions that are never referenced
	self program eachFunction do f
		var pf	= pfunction (f)
		pf ignore = not pf called
	end

	// Remove duplicate functions
	self removeDuplicateFunctions
	
	// Allocate registers to variables and parameters
	self program eachFunction do f
		self prepareFunction (f)
	end

	// Everything is ready to assemble and generate the object file:
	// * constants have a global values
	// * functions have p-code and register allocated
	// Let's start the first pass
	self pass
	
	// Terminate the first pass and prepare the second pass
	self endPass1
	
	// Second pass
	self pass

	// Save the object file and return result
	return self super dump (filename)

end

//[of]:pass
//[c]Generate the object file
//[c]	- put data in data section
//[c]	- put functions in text section
//[c]
//[c]This pass is executed twice:
//[c]	(1) The first pass does not write anything to the output, it just store 
//[c]	offsets and sizes that will be use to resolve references and to allocate 
//[c]	sufficient memory for the second pass.
//[c]	(2) The second pass actually write data to a memory buffer.
//[c]	
//[c]	This code must be as fast as possible as it's executed twice: anything
//[c]	that can be moved outside must be removed.
//[c]
function pass

	// Start filling object file for this pass
	self startPass
	
	if self debug
		self startDebugInfo
		self startDebugLine
	end
	
	self program eachStructureConstant do c
		self generateStructure (c)
	end
	self program eachArrayConstant do c
		self generateArray (c)
	end
	self program eachString8Constant do c
		self generateString8 (c)
	end
	self program eachString16Constant do c
		self generateString16 (c)
	end
	self program eachGlobalVariable do v
		self generateGlobalVariable (v)
	end
	self program eachExternFunction do f
		var glob = pglobal (f)
		glob symbol = self createExternSymbol (f publicName)
	end
	self program eachFunction do f
		self assembleFunction (f)
	end
	self pcodegen directTables each do t
		self generateDirectTable (t)
	end
	self pcodegen lookupTables each do t
		self generateLookupTable (t)
	end
	self addBuiltins

	if self debug
		self endDebugInfo
		self endDebugLine
	end

	// Complete sections
	self endPass

end

//[of]:generateStructure
function generateStructure (e: *StructureExpression)

	var glob = pglobal (e)

	var structure	= e structure
	var iter : ExpressionIterator
	iter initialize (e values)
	var section = self dataSection
	var buffer = section buffer
	
	// Align the structure in the section
	buffer align (ObjectOffset fromSize (structure align), 0)
	
	glob symbol = self createAutoSymbol (section, glob length)
	glob address = buffer pos
	writeStructure (section, structure, iter)
	glob length = buffer pos - glob address

end
//[cf]
//[of]:generateArray
function generateArray (e: *ArrayExpression)

	var glob = pglobal (e)

	var arrayType	= e arrayType
	var iter : ExpressionIterator
	iter initialize (e values)
	var section = self dataSection
	var buffer = section buffer

	// Align the structure in the section
	buffer align (ObjectOffset fromSize (arrayType align), 0)
	
	glob symbol = self createAutoSymbol (section, glob length)
	glob address = buffer pos
	writeArray (section, arrayType, iter)
	glob length = buffer pos - glob address
	
end
//[cf]
//[of]:generateString8
function generateString8 (e: *String8Expression)

	var glob = pglobal (e)
	var str = e value
	var size = ObjectOffset fromSize ((str size + 1) toByteSize)
	var section = self dataSection
	var buffer = section buffer

	// Align the structure in the section
	// buffer align ('byte, 0) -- it is useless to align on a byte

	glob symbol	= self createAutoSymbol (section, size)
	glob address	= buffer pos
	glob length	= size
	buffer write (str, size)
	
end
//[cf]
//[of]:generateString16
function generateString16 (e: *String16Expression)

	var glob = pglobal (e)
	var str = e value
	var size = ObjectOffset fromSize ((str size + 1) toByteSize)
	var section = self dataSection
	var buffer = section buffer

	// Align the structure in the section
	buffer align ('word, 0)

	glob symbol	= self createAutoSymbol (section, size)
	glob address	= buffer pos
	glob length	= size
	buffer write (str, size)

end
//[cf]
//[of]:generateGlobalVariable
function generateGlobalVariable (variable: *GlobalVariable)

	var glob = pglobal (variable)
	var initialValue = variable initialValue
	var storageType	= variable storageType
	var section = self dataSection
	var buffer = section buffer

	// Align the structure in the section
	buffer align (ObjectOffset fromSize (storageType align), 0)
	
	glob symbol = self createAutoSymbol (section, glob length)
	glob address = buffer pos
	if initialValue isNil
		// Uninitalized variable
		// Fill with zeros.  It should be uninitialized data
		var n = storageType size
		while n > 0
			buffer writeByte (0)
			n --
		end
	else
		// Initialized variable
		writeConstant (section, initialValue, storageType)
	end
	glob length = buffer pos - glob address

	// Write debug information
	if self debug
		var section = self debugInfo
		var buffer = section buffer
		buffer writeByte (Abbrev : 'variable)
		buffer writeString8 (variable name string)
		buffer writeDword (self getDwarfType (storageType))
		buffer writeByte (1 + 8)
		buffer writeByte (LocationAtom : 'addr)
		section writeReference64 (glob symbol, 0)
	end

end
//[cf]
//[of]:assembleFunction
function assembleFunction (f: *Function)

	var pf = pfunction (f)
	if pf ignore
		return
	end

	var section = self textSection
	pf address = section buffer pos
	pf symbol = self createFunctionSymbol (f publicName, section, pf address, pf length)
	
	// Copy some variables
	self callStackSize = pf callStackSize
	self localStackSize = pf localStackSize

	// Emit the location at the beginning of the function
	self emitLocation (section buffer pos, f module, f line)

	self generateFunctionPrologue (pf)

	// The debug information for the function is registered after
	// generating the prologue because the savedRegisterStackSize and
	// padding must be computed for variable and parameter location.
	self addDebugFunction (pf debug, pf address, pf length)

	self generateInstructions (pf)

	// Emit the location at the end of the function: use the last line number + 1
	self emitLocation (self text buffer pos, f module, self debugLineNumber + 1)
	
	self generateFunctionEpilogue (pf)

	pf length = section buffer pos - pf address

end
//[c]
//[of]:sub-routines
//[of]:generateFunctionPrologue
//[c]Generates the function prologue
//[c]
//[c]	The prologue looks like
//[c]	
//[c]		push	rbp	; In debug mode only, ebp is not used
//[c]		mov	rbp, rsp	;
//[c]		push	reg	; Save all registers used in this function (ebp, esi, edi, ebx)
//[c]		...		;
//[c]		mov	[rsp + n], reg	; Save register argument to stack (if spilled)
//[c]		mov	reg1, reg	; Copy register argument to more permanent register
//[c]
function generateFunctionPrologue (pfunction: *PFunction)

	self saveRegisterStackSize = 0
	// In debug mode, save the stack pointer into ebp to help
	// the debugger showing the call stack
	if self debug
		// PUSH RBP
		self push ('rbp)
		self saveRegisterStackSize += 8
		// MOV RBP, RSP
		self writeModrm (Register : 'rsp, 3, Register : 'rbp, 0x48, 0x89)
	end

	var u = pfunction usedRegisters
	var i = Index : 0
	while i < savedRegisterCount
		var rid = savedRegisters [i]
		// rbp is already saved in debug mode
		if rid <> 'rbp or not self debug
			if (u & rid mask) <> 'none
				self push (rid)
				self saveRegisterStackSize += 8
			end
		end
		i ++
	end

	// Count the total number of bytes for the stack frame, from rsp to the 
	// return address (included)
	var n = Disp32 : 0
	n += pfunction callStackSize
	n += pfunction localStackSize
	n += self saveRegisterStackSize
	n += 'sizeOfReturnAddress
	
	// Align to 16 bytes
	var padding = (Disp32 : 16 - (n & 15)) & 15
	n += padding
	
	// Save padding
	self paddingStackSize = padding

	// Deduce what's already removed
	n -= self saveRegisterStackSize
	n -= 'sizeOfReturnAddress
	
	self subRspImm (n)

	// Copy arguments (register arguments may need to be copied)
	self copyArguments (pfunction)
	
end

//[of]:copyArguments
//[c]Copy arguments (register arguments may need to be copied)
//[c]
//[c]	It is the same algorithm as the call function
//[c]
function copyArguments (pf: *PFunction)

	var slots : [registerArgumentCount] ArgumentRegister
	var n = min (pf parameters size, registerArgumentCount)
	
	// Mask of affected registers
	var mask = RegisterMask : 'none
	
	// Initialize slots
	n each do i
		var s = slots [i]
		s processed = false
		s dst = -1
		s src = -1
		mask |= registerArguments [i] mask
	end
	
	// Create the graph
	var p = pf parameters firstElement
	n each do i
		var v = p spilled cond p else p register
		var s = slots [i]
		s value = v
		if v isRegister
			var r = v asRegister register
			// Consider only registers to pass to the function and the 
			// ones that are not already assigned to the correct register
			if r mask has (mask) and r <> registerArguments [i]
				s dst = argumentRegisters [r]
				s size = v size
				slots [s dst] src = i
			end
		end
		p = p nextSibling
	end

	// Assign registers to spilled variable or non-argument registers
	n each do i
		var s = slots [i]
		if s dst == -1
			self movValueRegister (s value, registerArguments [i])
		end
	end
	
	self processGraph (n, slots)

end
//[cf]
//[cf]
//[of]:generateFunctionEpilogue
//[c]Generates the function epilogue
//[c]
//[c]	The epilogue looks like
//[c]	
//[c]		pop	reg	; Save all registers used in this function (ebp, esi, edi, ebx)
//[c]		...		;
//[c]		pop	rbp	; In debug mode only, ebp is not used
//[c]		ret		; Return
//[c]
function generateFunctionEpilogue (pfunction: *PFunction)

	// Count the total number of bytes to add to rsp
	var n = pfunction callStackSize
	n += self paddingStackSize
	n += pfunction localStackSize
	self addRspImm (n)

	var u = pfunction usedRegisters
	var i = savedRegisterCount
	while i > 0
		i --
		var rid = savedRegisters [i]
		// rbp is restored later in debug mode
		if rid <> 'rbp or not self debug
			if (u & rid mask) <> 'none
				self pop (rid)
			end
		end
	end

	// In debug mode, save the stack pointer into ebp to help
	// the debugger showing the call stack
	if self debug
		// POP RBP
		self pop ('rbp)
	end
	
	// RET
	self writeByte (0xC3)

end
//[cf]
//[of]:generateInstructions
function generateInstructions (pfunction: *PFunction)
	pfunction instructions each do i
		self generateInstruction (i)
	end
end
//[c]
function generateInstruction (instruction: *PInstruction)

	self emitLocation (self text buffer pos, self debugModule, instruction line)
	self loaded = 'none
	
	switch instruction code
	case 'add
		self generateOp (instruction asBinary, 'add)
	case 'and
		self generateOp (instruction asBinary, 'and)
	case 'call
		self call (instruction asCall)
	case 'cmp
		self generateOp (instruction asBinary, 'cmp)
	case 'jump
		var label = instruction asJump label
		self jump (instruction, label)
	case 'jumpc
		var i	= instruction asJumpc
		self jcc (i condition code, i label)
	case 'jumpi
		var i = instruction asUnary
		self jumpi (i value1)
	case 'label
		instruction asLabel label address = self text buffer pos
	case 'load, 'store
		var i = instruction asBinary
		self movValueValue (i value1, i value2)
	case 'lookup
		var i = instruction asBinary
		self lookup (i value1, i value2)
	case 'movsx
		var i = instruction asBinary
		self xtend (i value1, i value2, 0xBE)
	case 'movzx
		var i = instruction asBinary
		self xtend (i value1, i value2, 0xB6)
	case 'neg
		self op1 (instruction asUnary value1, 3)
	case 'not
		self op1 (instruction asUnary value1, 2)
	case 'or
		self generateOp (instruction asBinary, 'or)
	case 'return
		self ret (instruction asReturn)
	case 'set
		var i = instruction asSet
		self set (i value1, i condition)
	case 'sdiv
		var i = instruction asBinary
		self sdiv (i value1, i value2, false)
	case 'shlc
		var i = instruction asBinary
		self shift (i value1, i value2, 4)
	case 'shli
		self shiftImm (instruction asShift, 4)
	case 'sshrc
		var i = instruction asBinary
		self shift (i value1, i value2, 7)
	case 'sshri
		self shiftImm (instruction asShift, 7)
	case 'smod
		var i = instruction asBinary
		self sdiv (i value1, i value2, true)
	case 'smul
		var i = instruction asBinary
		self mul (i value1, i value2, 5)
	case 'smul2
		var i = instruction asBinary
		self mul2 (i value1, i value2)
	case 'smul3
		var i = instruction asTernary
		self mul3 (i value1, i value2, i value3)
	case 'sub
		self generateOp (instruction asBinary, 'sub)
	case 'test
		var i	= instruction asBinary
		self test (i value1, i value2)
	case 'truncate
		var i = instruction asBinary
		self truncate (i value1, i value2)
	case 'udiv
		var i = instruction asBinary
		self udiv (i value1, i value2, false)
	case 'umod
		var i = instruction asBinary
		self udiv (i value1, i value2, true)
	case 'umul
		var i = instruction asBinary
		self mul (i value1, i value2, 4)
	case 'ushrc
		var i = instruction asBinary
		self shift (i value1, i value2, 5)
	case 'ushri
		self shiftImm (instruction asShift, 5)
	case 'xor
		self generateOp (instruction asBinary, 'xor)
	case 'module
		self emitLocation (self text buffer pos, instruction asModule module, instruction line)
	end

end

//[of]:generateOp
function generateOp (i: *PBinaryInstruction, operation: *BinaryOperation)
	self opValueValue (operation, i value1, i value2)
end
//[cf]
//[cf]
//[cf]
//[of]:assembling
//[c]All primitives to generate x86-64 instructions from the p-code.
//[c]
//[of]:control flow
//[of]:call
//[c]Call a sub-routine
//[c]
//[c]	call fn, arg1, arg2, ...
//[c]	where 
//[c]	fn	--	A constant (integer, reference to function, builtin, global) 
//[c]			or a r/m value.
//[c]	argi	--	An argument passed as register. It is either a register or an 
//[c]			integer value.
//[c]	
//[c]	Arguments are passed by stack and by registers. Stack arguments are 
//[c]	already pushed to the stack, and the instruction contains only the list of
//[c]	arguments passed as registers.
//[c]	
//[c]	As the arguments may be random registers, we may have random assignments
//[c]	such as :
//[c]		edi -> esi
//[c]		esi -> edi
//[c]	or even more complex permutation.
//[c]	
//[c]	To solve this, we have to order assigments. The algorithm follows this principle:
//[c]	Register receiving an immediate value, a variable that is spilled, or a register
//[c]	that is not a parameter are assigned last (1).
//[c]	For other registers passed as arguments, a graph is created where nodes are
//[c]	registers and transitions are assignments.
//[c]	Registers that are not assigned to something are loaded first.
//[c]	If a cycle is detected, a temporary register is used:
//[c]		r0 <- r1 <- r2 <- r0
//[c]	becomes:
//[c]		rax <- r0
//[c]		r0 <- r1
//[c]		r1 <- r2
//[c]		r2 <- rax
//[c]
function call (instruction: *PCallInstruction)

	var slots : [registerArgumentCount] ArgumentRegister
	var n = instruction argumentCount
	
	// Mask of affected registers
	var mask = RegisterMask : 'none
	
	// Initialize slots
	n each do i
		var s = slots [i]
		s processed = false
		s dst = -1
		s src = -1
		mask |= registerArguments [i] mask
	end
	
	// Create the graph
	n each do i
		var v = instruction argumentValues [i] reduce
		var s = slots [i]
		s value = v
		if v isRegister
			var r = v asRegister register
			// Consider only registers to pass to the function and the 
			// ones that are not already assigned to the correct register
			if r mask has (mask) and r <> registerArguments [i]
				s src = argumentRegisters [r]
				slots [s src] dst = i
				slots [s src] size = v size
			end
		end
	end

	self processGraph (n, slots)

	// Assign remaining registers: (1)
	// * integer value
	// * spilled registers
	// * registers not passed to the function
	n each do i
		var s = slots [i]
		if not s processed
			self movRegisterValue (registerArguments [i], s value)
		end
	end

	// Perform the call
	var address = instruction address reduce
	switch address code
	case 'function
		self writeByte (0xE8)
		self writeRelative (address asFunction master address)
	case 'global
		self writeByte (0xE8)
		self text writeRelativeReference (address asGlobal symbol)
	case 'register, 'memory
		// call rm
		self writeRMX ('dword, address, 2, 0x00, 0xFF - 1)
	else
		assertFailure ("call: invalid value")
	end

	// Assign return values to registers
	// Only one register value currently supported
	if instruction returnCount == 1
		self movValueRegister (instruction returnValues [0], registerReturns [0])
	end
	
end
//[cf]
//[of]:jcc
function jcc (condition: Byte, label: *PLabel)

	if label isDefined
		var position = self text buffer pos + 2
		var offset = label address - position
		// We must have the same behavior between pass 1 and 2: always
		// ignore forward labels (not defined in pass 1 but defined in pass 2)
		if offset >= 0 - 128 and offset < 0
			self writeByte (condition + 0x70)
			self writeByte (offset cast (Byte))
			return
		end
	end

	// Jcc rel32
	self writeByte (0x0F)
	self writeByte (condition + 0x80)
	self writeLabel (label)	

end
//[cf]
//[of]:jump
function jump (instruction: *PInstruction, label: *PLabel)

	if instruction isFollowedByLabel (label)
		return
	end
	
	if label isDefined
		var position = self text buffer pos + 2
		var offset = label address - position
		// We must have the same behavior between pass 1 and 2: always
		// ignore forward labels (not defined in pass 1 but defined in pass 2)
		if offset >= 0 - 128 and offset < 0
			// JMP rel8
			self writeByte (0xEB)
			self writeByte (offset cast (Byte))
			return
		end
	end
	
	// JMP rel32
	self writeByte (0xE9)
	self writeLabel (label)

end
//[cf]
//[of]:jumpi
function jumpi (value: *PValue)

	var address = value reduce
	switch address code
	case 'function
		self writeByte (0xE9)
		self writeRelative (address asFunction master address)
	case 'global
		self writeByte (0xE9)
		self text writeRelativeReference (address asGlobal symbol)
	case 'register, 'memory
		// jump rm
		self writeRMX ('dword, address, 4, 0x00, 0xFF - 1)
	else
		assertFailure ("jump: invalid value")
	end

end
//[cf]
//[of]:lookup
//[c]lookup rmi, r
//[c]
function lookup (value: *PValue, table: *PValue)

	self movRegisterValue ('rax, value)
	self movRegisterValue ('rcx, table)
	self writeByte (0xE9)
	self writeRelative (self lookupBuiltin address)

	self lookupBuiltin used = true

end
//[cf]
//[of]:ret
function ret (instruction: *PReturnInstruction)

	if instruction count == 1
		self movRegisterValue (registerReturns [0], instruction values [0])
	end
	self jump (instruction, instruction label)

end
//[cf]
//[cf]
//[of]:converting
//[of]:truncate
//[c]truncate r, rm
//[c]
function truncate (value1: *PValue, value2: *PValue)

	var v2 = value2 reduce
	if v2 isM
		// Create a copy of memory with the size of the first argument
		var m : PMemoryValue
		m code = 'memory
		m size = value1 size
		m address = v2 asMemory address
		
		self movValueValue (value1, m)
	else
		// Just copy the register
		self movValueRegister (value1, v2 asRegister register)
	end

end
//[cf]
//[of]:xtend
//[c]sext r, rm
//[c]zext r, rm
//[c]
function xtend (value1: *PValue, value2: *PValue, opcode: Byte)

	var v1 = value1 asRegister
	var v2 = value2 reduce

	if v2 size == 'byte
		if v2 isRegister
			// We can't use 'writeRMX' here because the size of the operation is not byte
			// but we must add a rex prefix if source value is sil, dil, bpl or spl
			var reg = v1 register
			var rm = v2 asRegister register
			var rex = ((reg & 8) >> 1) | ((rm & 8) >> 3)
			// Special case: force REX prefix with sil, dil, bpl or spl
			if reg >= 4 or rm >= 4
				rex |= 0x40
			end
			switch v1 size
			case 'word
				self writeByte (0x66)
			case 'qword
				rex |= 8
			end
			self writeOpcode (rex, opcode, 0x0F)
			self writeByte (modrm (reg & 7, 3, rm & 7))
		else
			// opcode - 1 because v2 is at least 16 bits, the opcode is going to be incremented
			self writeRMX (v1 size, v2, v1 register, 0xFF, opcode - 1, 0x0F)
		end
	elsif v2 size == 'word
		self writeRMX (v1 size, v2, v1 register, 0xFF, opcode, 0x0F)
	else // 'qword
		// Special case: zero-extend dword to qword
		if opcode == 0xB6 and v1 size == 'qword
			// Just perform a mov reg, rm, it's automatically zero-extended to 64 bits
			self movRegisterValue (v1 register, v2)
		else
			// opcode - 1 because v2 is at least 16 bits, the opcode is going to be incremented
			self writeRMX (v1 size, v2, v1 register, 0xFF, 0x63 -1)
		end
	end
	
	// If value1 is a spilled variable: store result
	self postStoreRegister (v1)
	
end
//[cf]
//[cf]
//[of]:mov
//[of]:movValueValue
function movValueValue (	left	: *PValue,
	right	: *PValue )

	var v1 = left
	var v2 = right

	if v1 isRegister and v1 asRegister isSpilled
		if v2 isI32
			// rm, i
			v1 = v1 asRegister variable memory
		elsif v2 isRegister and not v2 asRegister isSpilled
			// rm, r
			v1 = v1 asRegister variable memory
		else
			// r, *
			self movRegisterValue (v1 asRegister register, v2)
			self movMemoryRegister (v1 asRegister variable memory, v1 asRegister register)
			return
		end
	elsif v1 isVariable
		// rm, v
		v1 = v1 asVariable memory
	end

	switch v1 code
	case 'register
		self movRegisterValue (v1 asRegister register, v2)
	case 'memory
		self movMemoryValue (v1 asMemory, v2)
	else
		assertFailure ("mov: invalid left value")
	end

end
//[cf]
//[of]:movValueRegister
function movValueRegister (left: *PValue, right: Register)

	switch left code
	case 'variable
		self movMemoryRegister (left asVariable memory, right)
	case 'register
		if left asRegister isSpilled
			self movMemoryRegister (left asRegister variable memory, right)
		else
			self movRegisterRegister (left size, left asRegister register, right)
		end
	case 'memory
		self movMemoryRegister (left asMemory, right)
	else
		assertFailure ("mov value reg: invalid value")
	end

end
//[cf]

//[of]:movRegisterValue
function movRegisterValue (r: Register, right: *PValue)

	switch right code
	case 'variable
		self movRegisterMemory (r, right asVariable memory)
	case 'register
		if right asRegister isSpilled
			self movRegisterMemory (r, right asRegister variable memory)
		else
			self movRegisterRegister (right size, r, right asRegister register)
		end
	case 'integer
		self movRegisterInteger (r, right asInteger)
	case 'memory
		self movRegisterMemory (r, right asMemory)
	case 'index
		self movRegisterIndex (r, right asIndex)
		
	case 'global
		// MOV r64, imm64
		self writeByte (0x48 +  ((r & 8) >> 3))
		self writeByte (0xB8 + (r & 7))
		var g = right asGlobal
		self text writeReference64 (g symbol, 0)
		
	case 'function
		// MOV r64, imm64
		self writeByte (0x48 +  ((r & 8) >> 3))
		self writeByte (0xB8 + (r & 7))
		var f = right asFunction master
		self text writeReference64 (f symbol, 0)

	else
		assertFailure ("mov reg value: unknown value", right code cast (Integer))
	end

end
//[cf]
//[of]:movRegisterRegister
function movRegisterRegister (size: PValueSize, left: Register, right: Register)

	// Nothing to do if src is same as dst
	if left == right
		return
	end
	
	self writeRegRM (size, right, 0xFF, left, 0x88)

end
//[cf]
//[of]:movRegisterInteger
function movRegisterInteger (register: Register, constant: *PIntegerValue)

	if constant isZero
		// XOR r, r
		self writeRegRM (constant size, register, 0xFF, register, 0x32)
	else
		var rex = (register & 8) >> 3
		switch constant size
		case 'byte
			// MOV r8, imm8
			if register >= 4
				rex |= 0x40
			end
			self writeOpcode (rex, 0xB0 + (register & 7))
			self writeByte (constant byte)
		case 'word
			// MOV r16, imm16
			self writeByte (0x66)
			self writeOpcode (rex, 0xB8 + (register & 7))
			self writeWord (constant word)
		case 'dword
			// MOV r32, imm32
			self writeOpcode (rex, 0xB8 + (register & 7))
			self writeDword (constant dword)
		else // 'qword
			// MOV r64, imm64
			self writeOpcode (rex|8, 0xB8 + (register & 7))
			self writeQword (constant qword)
		end
	end

end
//[cf]
//[of]:movRegisterMemory
function movRegisterMemory (left: Register, right: *PMemoryValue)
	self preloadRegisters (right)
	self writeMemory (right, left, 0xFF, 0x8A)
end
//[cf]
//[of]:movRegisterIndex
function movRegisterIndex (register: Register, right: *PIndexValue)

	self preloadIndex (right)

	// LEA r, [...]
	var info : MemoryInfo
	self getMemory (right, info)
	var rex = info rex
	rex |= 8 | (register & 8) >> 1
	self writeOpcode (rex, 0x8D)
	self writeMemoryInfo (info, register & 7)

end
//[cf]

//[of]:movMemoryValue
function movMemoryValue (	left	: *PMemoryValue,
	right	: *PValue )

	switch right code
	case 'register
		var r = right asRegister
		self preloadRegister (r)
		self movMemoryRegister (left, r register)
	case 'integer
		self movMemoryInteger (left, right asInteger)
	else
		assertFailure ("mov memory value: invalide value")
	end

end
//[cf]
//[of]:movMemoryRegister
function movMemoryRegister (left: *PMemoryValue, right: Register)
	self preloadRegisters (left)
	self writeMemory (left, right, 0xFF, 0x88)
end
//[cf]
//[of]:movMemoryInteger
function movMemoryInteger (	value	: *PMemoryValue,
	constant	: *PIntegerValue )

	self preloadRegisters (value)
	self writeMemory (value, 0, 0x00, 0xC6)
	self writeImmediate (constant)

end
//[cf]
//[cf]
//[of]:op
//[of]:mul
//[c]smul rm1, rm2
//[c]umul rm1, rm2
//[c]
//[c]Generates:
//[c]	mov	rax, rm1
//[c]	imul	rm2
//[c]	mov rm1, rax
//[c]
function mul (value1: *PValue, value2: *PValue, reg: Byte)

	self movRegisterValue ('rax, value1)
	self writeRM (value2 reduce, reg, 0x00, 0xF6)
	self movValueRegister (value1, 'rax)
	
end
//[cf]
//[of]:mul2
//[c]smul2 r, rm
//[c]
function mul2 (value1: *PValue, value2: *PValue)

	var v1 = value1 asRegister

	// If value1 is a spilled variable: load it first
	self preloadRegister (v1)
	
	// 0xAF - 1 because it's at least 16 bits, the opcode is going to be incremented
	self writeRM (value2 reduce, v1 register, 0xFF, 0xAF - 1, 0x0F)
	
	// If value1 is a spilled variable: store result
	self postStoreRegister (v1)
	
end
//[cf]
//[of]:mul3
//[c]smul3 r, rm, i
//[c]
function mul3 (value1: *PValue, value2: *PValue, value3: *PValue)
	
	var v1 = value1 asRegister
	var v2 = value2 reduce
	var v3 = value3 asInteger
	
	var nn = v3 dword
	if isShortDisplacement (nn)
		self writeRM (v2, v1 register, 0xFF, 0x6B - 1)
		self writeByte (nn cast (Byte))
	else
		self writeRM (v2, v1 register, 0xFF, 0x69 - 1)
		self writeImmediate (v3)
	end

	// If value1 is a spilled variable: store result
	self postStoreRegister (v1)

end
//[cf]
//[of]:op1
//[c]neg rm
//[c]not rm
//[c]
function op1 (value: *PValue, code: Byte)
	self writeRM (value reduce, code, 0x00, 0xF6)
end
//[cf]
//[of]:opValueValue
function opValueValue (operation: *BinaryOperation, value1: *PValue, value2: *PValue)

	var v1 = value1
	var v2 = value2

	if v1 isRegister and v1 asRegister isSpilled
		if v2 isI32
			// rm, i
			v1 = v1 asRegister variable memory
		elsif v2 isRegister and not v2 asRegister isSpilled
			// rm, r
			v1 = v1 asRegister variable memory
		else
			// r, *
			self movRegisterValue (v1 asRegister register, v2)
			self opMemoryRegister (operation, v1 asRegister variable memory, v1 asRegister)
			return
		end
	elsif v1 isVariable
		// rm, v
		v1 = v1 asVariable memory
	end

	switch v1 code
	case 'register
		self opRegisterValue (operation, v1 asRegister, v2)
	case 'memory
		self opMemoryValue (operation, v1 asMemory, v2)
	else
		assertFailure ("op: invalid left value")
	end

end

static struct BinaryOperation

	var regRm	: Byte	// op reg, r/m
	var rmReg	: Byte	// op r/m, reg
	var accImm	: Byte	// op al/ax/eax/rax, imm
	var rmImm	: Byte	// op r/m, imm
	var rmImmm	: Byte	// op r/m, imm (/reg)
	var neutralZero	: Bool	// zero has no effect (applies to add, sub, or, xor)

	'add = {
		0x02,	// op reg, r/m
		0x00,	// op r/m, reg
		0x04,	// op al/ax/eax, imm
		0x80,	// op r/m, imm
		0x00,	// op r/m, imm (/reg)
		true}	// zero has no effect

	'sub = {
		0x2A,	// op reg, r/m
		0x28,	// op r/m, reg
		0x2C,	// op al/ax/eax, imm
		0x80,	// op r/m, imm
		0x05,	// op r/m, imm (/reg)
		true}	// zero has no effect

	'cmp = {
		0x3A,	// op reg, r/m
		0x38,	// op r/m, reg
		0x3C,	// op al/ax/eax, imm
		0x80,	// op r/m, imm
		0x07,	// op r/m, imm (/reg)
		false}	// zero has effect (flags)

	'and = {
		0x22,	// op reg, r/m
		0x20,	// op r/m, reg
		0x24,	// op al/ax/eax, imm
		0x80,	// op r/m, imm
		0x04,	// op r/m, imm (/reg)
		false}	// zero has effect

	'or = {
		0x0A,	// op reg, r/m
		0x08,	// op r/m, reg
		0x0C,	// op al/ax/eax, imm
		0x80,	// op r/m, imm
		0x01,	// op r/m, imm (/reg)
		true}	// zero has no effect

	'xor = {
		0x32,	// op reg, r/m
		0x30,	// op r/m, reg
		0x34,	// op al/ax/eax, imm
		0x80,	// op r/m, imm
		0x06,	// op r/m, imm (/reg)
		true}	// zero has no effect
	
end
//[cf]
//[of]:opRegisterValue
function opRegisterValue (op: *BinaryOperation, left: *PRegisterValue, right: *PValue)

	switch right code
	case 'variable
		self opRegisterMemory (op, left, right asVariable memory)
	case 'register
		if right asRegister isSpilled
			self opRegisterMemory (op, left, right asRegister variable memory)
		else
			self opRegisterRegister (op, left, right asRegister)
		end
	case 'integer
		self opRegisterInteger (op, left, right asInteger)
	case 'memory
		self opRegisterMemory (op, left, right asMemory)
	end

end
//[cf]
//[of]:opRegisterMemory
function opRegisterMemory (op: *BinaryOperation, left: *PRegisterValue, right: *PMemoryValue)
	self preloadRegisters (right)
	self writeMemory (right, left register, 0xFF, op regRm)
end
//[cf]
//[of]:opRegisterRegister
function opRegisterRegister (op: *BinaryOperation, left: *PRegisterValue, right: *PRegisterValue)
	self writeRegister (right, left register, 0xFF, op regRm)
end
//[cf]
//[of]:opRegisterInteger
function opRegisterInteger (op: *BinaryOperation, left: *PRegisterValue, right: *PIntegerValue)

	var nn = right dword
	if nn == 0 and op neutralZero
		return
	end
	
	if right size > 'byte and isShortDisplacement (nn)
		// op r16, imm8
		self writeRegRM (right size, op rmImmm, 0x00, left register, op rmImm + 2)
		self writeByte (nn cast (Byte))
	else
		if left register == 'rax
			// op RAX, imm
			switch right size
			case 'byte
				self writeByte (op accImm)
			case 'word
				self writeByte (0x66)
				self writeByte (op accImm + 1)
			case 'dword
				self writeByte (op accImm + 1)
			else // 'qword
				self writeByte (0x48)
				self writeByte (op accImm + 1)
			end
			self writeImmediate (right)
		else
			// op r, imm
			self writeRegRM (right size, op rmImmm, 0x00, left register, op rmImm)
			self writeImmediate (right)
		end
	end

end
//[cf]
//[of]:opMemoryValue
function opMemoryValue (op: *BinaryOperation, left: *PMemoryValue, right: *PValue)

	switch right code
	case 'register
		var r = right asRegister
		self preloadRegister (r)
		self opMemoryRegister (op, left, r)
	case 'integer
		self opMemoryInteger (op, left, right asInteger)
	else
		assertFailure ("op: invalid righr value")
	end

end
//[cf]
//[of]:opMemoryRegister
function opMemoryRegister (op: *BinaryOperation, left: *PMemoryValue, right: *PRegisterValue)
	self preloadRegisters (left)
	self writeMemory (left, right register, 0xFF, op rmReg)
end
//[cf]
//[of]:opMemoryInteger
function opMemoryInteger (op: *BinaryOperation, left: *PMemoryValue, right: *PIntegerValue)

	var nn = right dword
	if nn == 0 and op neutralZero
		return
	end
	
	self preloadRegisters (left)
	if right size > 'byte and isShortDisplacement (nn)
		// op [x], imm8
		self writeMemory (left, op rmImmm, 0x00, op rmImm + 2)
		self writeByte (nn cast (Byte))
	else
		// op [x], imm
		self writeMemory (left, op rmImmm, 0x00, op rmImm)
		self writeImmediate (right)
	end

end
//[cf]
//[of]:sdiv
//[c]sdiv rm1, rm2
//[c]
//[c]Generates:
//[c]	mov	rax, rm1
//[c]	sext rdx
//[c]	idiv rm2
//[c]	mov rm1, rax
//[c]
function sdiv (value1: *PValue, value2: *PValue, remainder: Bool)

	self movRegisterValue ('rax, value1)
	
	switch value1 size
	case 'byte
		// cbw
		self writeByte (0x66)
		self writeByte (0x98)
	case 'word
		// cwd
		self writeByte (0x66)
		self writeByte (0x99)
	case 'dword
		// cdq
		self writeByte (0x99)
	else // 'qword
		// cqo
		self writeByte (0x48)
		self writeByte (0x99)
	end

	self writeRM (value2 reduce, 0x07, 0x00, 0xF6)
	var reg = Register : 'rax
	if remainder
		if value1 size == 'byte
			// MOV DL, AH
			self writeByte (0x88)
			self writeByte ((3 << 6) | (4 << 3) | 2)
		end
		reg = 'rdx
	end
	self movValueRegister (value1, reg)
	
end
//[cf]
//[of]:set
//[c]set cc, rm
//[c]
function set (value: *PValue, condition: ConditionFlags)
	self writeRM (value reduce, 0, 0x00, 0x90 + condition code, 0x0F)
end
//[cf]
//[of]:shift
//[c]shlc rm, rm2
//[c]sshrc rm, rm2
//[c]ushrc rm, rm2
//[c]
//[c]Generates:
//[c]	mov cl, rm2
//[c]	shl	rm, cl
//[c]
function shift (value1: *PValue, value2: *PValue, code: Byte)

	self movRegisterValue ('rcx, value2)
	self writeRM (value1 reduce, code, 0x00, 0xD2)

end
//[cf]
//[of]:shiftImm
//[c]shli	rm, i8
//[c]sshri	rm, i8
//[c]ushri	rm, i8
//[c]
function shiftImm (i: *PShiftInstruction, code: Byte)

	var value = i value1 reduce
	var shift = i shift
	if shift == 1
		// shift [x]
		self writeRM (value, code, 0x00, 0xD0)
	else
		// shift [x], imm8
		self writeRM (value, code, 0x00, 0xC0)
		self writeByte (shift)
	end

end
//[cf]
//[of]:test
//[c]test rm, ri
//[c]
function test (value1: *PValue, value2: *PValue)

	var v1 = value1
	var v2 = value2

	// Eliminate spilled variable on first argument
	if v1 isRegister
		if v1 asRegister isSpilled
			var variable = v1 asRegister variable
			v1 = variable memory

			// A common case is to test the variable with itself
			// let's use the same register in such a case
			if v2 isRegister and variable == v2 asRegister variable
				v1 = v2
			end
		end
	elsif v1 isVariable
		v1 = v1 asVariable memory

		// A common case is to test the variable with itself
		// let's use the same register in such a case
		if v2 isRegister and v1 == v2 asRegister variable
			v1 = v2
		end
	end

	if value2 isI32
		// test rm, i
		if v1 isRegister and v1 asRegister register == 'rax
			// test accumulator, imm
			var opcode = Byte : 0xA8
			switch v1 size
			case 'word
				opcode ++
				self writeByte (0x66)
			case 'dword
				opcode ++
			case 'qword
				opcode ++
				self writeByte (0x48)
			end
			self writeByte (opcode)
		else
			// test rm, imm
			self writeRM (v1, 0, 0x00, 0xF6)
		end
		self writeImmediate (v2)
	else
		// test rm, r
		var v2 = value2 asRegister
		self preloadRegister (v2)
		self writeRM (v1, v2 register, 0xFF, 0x84)
	end

end
//[cf]
//[of]:udiv
//[c]udiv rm1, rm2
//[c]
//[c]Generates:
//[c]	mov	rax, rm1
//[c]	xor rdx, rdx
//[c]	div rm2
//[c]	mov rm1, rax
//[c]
function udiv (value1: *PValue, value2: *PValue, remainder: Bool)

	self movRegisterValue ('rax, value1)
	
	switch value1 size
	case 'byte
		// xor ah, ah
		self writeByte (0x32)
		self writeByte ((3 << 6) | (4 << 3) | 4)
	case 'word
		// xor dx, dx
		self writeByte (0x66)
		self writeByte (0x33)
		self writeByte ((3 << 6) | (2 << 3) | 2)
	case 'dword
		// xor edx, edx
		self writeByte (0x33)
		self writeByte ((3 << 6) | (2 << 3) | 2)
	else // 'qword
		// xor rdx, rdx
		self writeByte (0x48)
		self writeByte (0x33)
		self writeByte ((3 << 6) | (2 << 3) | 2)
	end

	self writeRM (value2 reduce, 0x06, 0x00, 0xF6)
	
	var reg = Register : 'rax
	if remainder
		if value1 size == 'byte
			// MOV DL, AH
			self writeByte (0x88)
			self writeByte ((3 << 6) | (4 << 3) | 2)
		end
		reg = 'rdx
	end
	self movValueRegister (value1, reg)
	
end
//[cf]
//[cf]
//[of]:stack
//[of]:addRspImm
function addRspImm (offset: Disp32)

	if offset == 0
		// Do nothing
	elsif isShortDisplacement (offset)
		// ADD RSP, imm8
		self writeModrm (0, 3, Register : 'rsp, 0x48, 0x83)
		self writeByte (offset cast (Byte))
	else
		// ADD RSP, imm32
		self writeModrm (0, 3, Register : 'rsp, 0x48, 0x81)
		self writeDword (offset asUnsigned)
	end
	
end
//[cf]
//[of]:pop
function pop (r: Register)
	if (r & 8) <> 0
		self writeByte (0x41)
	end
	self writeByte (0x58 + (r & 7))
end
//[cf]
//[of]:push
function push (r: Register)
	if (r & 8) <> 0
		self writeByte (0x41)
	end
	self writeByte (0x50 + (r & 7))
end
//[cf]
//[of]:subRspImm
function subRspImm (offset: Disp32)

	if offset == 0
		// Do nothing
	elsif isShortDisplacement (offset)
		// SUB RSP, imm8
		self writeModrm (5, 3, Register : 'rsp, 0x48, 0x83)
		self writeByte (offset cast (Byte))
	else
		// SUB RSP, imm64
		self writeModrm (5, 3, Register : 'rsp, 0x48, 0x81)
		self writeDword (offset cast (Uint32))
	end

end
//[cf]
//[cf]
//[cf]
//[of]:tests
//[of]:testMovMemoryRegister
function testMovMemoryRegister

	var m	: PMemoryValue
	var x	: PIndexValue
	var r1	: PRegisterValue
	var r2	: PRegisterValue
	
	m code	= 'memory
	m address	= x
		
	x code	= 'index
	x size	= 'qword
	x base	= r1
	x index	= r2
	x scale	= 4
	x offset	= 20
		
	r1 code	= 'register
	r1 size	= 'qword
	r1 variable	= nil
	r1 register	= 'rbx
		
	r2 code	= 'register
	r2 size	= 'qword
	r2 variable	= nil
	r2 register	= 'rcx

	// Just an address
	self movMemoryRegister (*PMemoryValue : { 'memory, 'byte, *PIntegerValue : {'integer, 'qword, 0x400000}}, 'r13)
		
	// One base register
	m size = 'byte
	x index = nil
	x offset = 1040
	var i = Register : 0
	while i < 16
		r1 register = i
		self movMemoryRegister (m, 'r13)
		i ++
	end

	// one register with scale
	m size = 'byte
	x base = nil
	x index = r2
	x offset = 0
	x scale = 2
	i = 0
	while i < 16
		r2 register = i
		self movMemoryRegister (m, 'r8)
		i ++
	end

	// Two registers with scale
	m size = 'byte
	x base = nil
	x base = r1
	x index = r2
	x offset = 10
	x scale = 4
	r1 register = 'r8
	i = 0
	while i < 16
		r2 register = i
		self movMemoryRegister (m, 'r8)
		i ++
	end

	// Tricky 1 : rbp or r13 as base and no offset
	m size = 'dword
	x base = nil
	x base = r1
	x index = r2
	x offset = 0
	x scale = 4
	r1 register = 'r13
	i = 0
	while i < 16
		r2 register = i
		self movMemoryRegister (m, 'r8)
		i ++
	end
	
	// long offset
	x offset = -8192
	self movMemoryRegister (m, 'r13)
	
	self movMemoryRegister (
		*PMemoryValue : { 'memory, 'byte, *PIndexValue : {'index, 'qword,
			*PRegisterValue : {'register, 'qword, nil, 'r13},
			nil,
			1,
			20}},
			'r13)

end
//[cf]
//[of]:testMovRegisterMemory
function testMovRegisterMemory

	var m	: PMemoryValue
	var x	: PIndexValue
	var r1	: PRegisterValue
	var r2	: PRegisterValue
	
	m code	= 'memory
	m address	= x
		
	x code	= 'index
	x size	= 'qword
	x base	= r1
	x index	= r2
	x scale	= 4
	x offset	= 20
		
	r1 code	= 'register
	r1 size	= 'qword
	r1 variable	= nil
	r1 register	= 'rbx
		
	r2 code	= 'register
	r2 size	= 'qword
	r2 variable	= nil
	r2 register	= 'rcx

	// One base register
	m size = 'word
	x index = nil
	x offset = 1040
	var i = Register : 0
	while i < 16
		r1 register = i
		self movRegisterMemory ('r9, m)
		i ++
	end

	// one register with scale
	m size = 'dword
	x base = nil
	x index = r2
	x offset = 0
	x scale = 2
	i = 0
	while i < 16
		r2 register = i
		self movRegisterMemory ('rsi, m)
		i ++
	end

	// Two registers with scale
	m size = 'qword
	x base = r1
	x index = r2
	x offset = 10
	x scale = 4
	r1 register = 'rax
	i = 0
	while i < 16
		r2 register = i
		self movRegisterMemory ('r8, m)
		i ++
	end

	// Tricky 1 : rbp or r13 as base and no offset
	m size = 'dword
	x base = r1
	x index = r2
	x offset = 0
	x scale = 4
	r1 register = 'r13
	i = 0
	while i < 16
		r2 register = i
		self movRegisterMemory ('r8, m)
		i ++
	end

	// Each 8 bit register
	m size = 'byte
	x base = r1
	x index = nil
	x offset = 1040
	r1 register = 'rax
	i = Register : 0
	while i < 16
		self movRegisterMemory (i, m)
		i ++
	end
	
end
//[cf]
//[of]:testMovRegisterInteger
function testMovRegisterInteger

	var v : PIntegerValue
	v code = 'integer
		
	// Zero
	v size = 'word
	v value = 0
	var i = Register : 0
	while i < 16
		v size = 'byte
		self movRegisterInteger (i, v)
		v size = 'word
		self movRegisterInteger (i, v)
		v size = 'dword
		self movRegisterInteger (i, v)
		v size = 'qword
		self movRegisterInteger (i, v)
		i ++
	end

	// Byte
	v size = 'byte
	v value = 120
	i = 0
	while i < 16
		self movRegisterInteger (i, v)
		i ++
	end

	// Word
	v size = 'word
	v value = 1200
	i = 0
	while i < 16
		self movRegisterInteger (i, v)
		i ++
	end

	// Dword
	v size = 'dword
	v value = 65535
	i = 0
	while i < 16
		self movRegisterInteger (i, v)
		i ++
	end

	// Qword
	v size = 'qword
	v value = 65535
	i = 0
	while i < 16
		self movRegisterInteger (i, v)
		i ++
	end

end
//[cf]
//[of]:testSub
function testSub

	const mb	= *PMemoryValue	: { 'memory, 'byte, *PIntegerValue : {'integer, 'qword, 0x400000}}
	const rb	= *PRegisterValue	: { 'register, 'byte, nil, 'rbx}
	const rb2	= *PRegisterValue	: { 'register, 'byte, nil, 'rsi}
	const ib	= *PIntegerValue	: { 'integer, 'byte, 82}

	self opValueValue ('sub, mb, rb)
	self opValueValue ('sub, rb, mb)

	self opValueValue ('sub, rb2, rb)
	self opValueValue ('sub, rb, rb2)

	self opValueValue ('sub, rb, ib)
	self opValueValue ('sub, rb2, ib)

	self movValueValue (rb2, rb)

	self testValueValue (rb2, ib)
	self testValueValue (rb2, rb)
	self testValueValue (rb, rb)
	self testValueValue (mb, ib)
	self testValueValue (mb, rb)


	const mq	= *PMemoryValue	: { 'memory, 'qword, *PIntegerValue : {'integer, 'qword, 0x400000}}
	const rq	= *PRegisterValue	: { 'register, 'qword, nil, 'rbx}
	const rq2	= *PRegisterValue	: { 'register, 'qword, nil, 'rsi}
	const iq	= *PIntegerValue	: { 'integer, 'qword, 82}

	self opValueValue ('sub, mq, rq)
	self opValueValue ('sub, rq, mq)

	self opValueValue ('sub, rq2, rq)
	self opValueValue ('sub, rq, rq2)

	self opValueValue ('sub, rq, iq)
	self opValueValue ('sub, rq2, iq)

	self movValueValue (rq2, rq)

	self testValueValue (rq2, iq)
	self testValueValue (rq2, rq)
	self testValueValue (rq, rq)
	self testValueValue (mq, iq)
	self testValueValue (mq, rq)
end
//[cf]
//[of]:testMul
function testMul

	const mb	= *PMemoryValue	: { 'memory, 'byte, *PIntegerValue : {'integer, 'qword, 0x400000}}
	const rb	= *PRegisterValue	: { 'register, 'byte, nil, 'rbx}
	const rb2	= *PRegisterValue	: { 'register, 'byte, nil, 'rsi}
	const ib	= *PIntegerValue	: { 'integer, 'byte, 82}

	self mulValueValue (mb, rb, 4)
	self mulValueValue (rb, mb, 4)

	self mulValueValue (rb2, rb, 5)
	self mulValueValue (rb, rb2, 5)

	const mq	= *PMemoryValue	: { 'memory, 'qword, *PIntegerValue : {'integer, 'qword, 0x400000}}
	const rq	= *PRegisterValue	: { 'register, 'qword, nil, 'rbx}
	const rq2	= *PRegisterValue	: { 'register, 'qword, nil, 'rsi}
	const iq	= *PIntegerValue	: { 'integer, 'qword, 82}

	self mulValueValue (mq, rq, 4)
	self mulValueValue (rq, mq, 4)

	self mulValueValue (rq2, rq, 5)
	self mulValueValue (rq, rq2, 5)

end
//[cf]
//[of]:testOp1
function testOp1

	self op1 (*PMemoryValue	: { 'memory, 'byte, *PIntegerValue : {'integer, 'qword, 0x400000}}, 2)
	self op1 (*PRegisterValue	: { 'register, 'byte, nil, 'rbx}, 2)
	self op1 (*PRegisterValue	: { 'register, 'byte, nil, 'r13}, 2)

	self op1 (*PMemoryValue	: { 'memory, 'qword, *PIntegerValue : {'integer, 'qword, 0x400000}}, 2)
	self op1 (*PRegisterValue	: { 'register, 'qword, nil, 'rbx}, 2)
	self op1 (*PRegisterValue	: { 'register, 'qword, nil, 'r13}, 2)

	self set (*PMemoryValue	: { 'memory, 'byte, *PIntegerValue : {'integer, 'qword, 0x400000}}, 'z)
	self set (*PRegisterValue	: { 'register, 'byte, nil, 'rbx}, 'nz)
	self set (*PRegisterValue	: { 'register, 'byte, nil, 'r13}, 'gt)

end
//[cf]
//[of]:testTruncate
function testTruncate

	self truncate (*PRegisterValue	: { 'register, 'dword, nil, 'r12},	*PMemoryValue	: { 'memory, 'qword, *PIntegerValue : {'integer, 'qword, 0x400000}})
	self truncate (*PRegisterValue	: { 'register, 'word, nil, 'r12},	*PMemoryValue	: { 'memory, 'qword, *PIntegerValue : {'integer, 'qword, 0x400000}})
	self truncate (*PRegisterValue	: { 'register, 'byte, nil, 'r12},	*PMemoryValue	: { 'memory, 'qword, *PIntegerValue : {'integer, 'qword, 0x400000}})
	self truncate (*PRegisterValue	: { 'register, 'word, nil, 'r12},	*PMemoryValue	: { 'memory, 'dword, *PIntegerValue : {'integer, 'qword, 0x400000}})
	self truncate (*PRegisterValue	: { 'register, 'byte, nil, 'r12},	*PMemoryValue	: { 'memory, 'dword, *PIntegerValue : {'integer, 'qword, 0x400000}})
	self truncate (*PRegisterValue	: { 'register, 'byte, nil, 'r12},	*PMemoryValue	: { 'memory, 'word, *PIntegerValue : {'integer, 'qword, 0x400000}})
	
	self truncate (*PRegisterValue	: { 'register, 'dword, nil, 'r12},	*PRegisterValue	: { 'register, 'qword, nil, 'rbx})
	self truncate (*PRegisterValue	: { 'register, 'word, nil, 'r12},	*PRegisterValue	: { 'register, 'qword, nil, 'rbx})
	self truncate (*PRegisterValue	: { 'register, 'byte, nil, 'r12},	*PRegisterValue	: { 'register, 'qword, nil, 'rbx})
	self truncate (*PRegisterValue	: { 'register, 'word, nil, 'r12},	*PRegisterValue	: { 'register, 'dword, nil, 'rbx})
	self truncate (*PRegisterValue	: { 'register, 'byte, nil, 'r12},	*PRegisterValue	: { 'register, 'dword, nil, 'rbx})
	self truncate (*PRegisterValue	: { 'register, 'byte, nil, 'r12},	*PRegisterValue	: { 'register, 'word, nil, 'rbx})

end
//[cf]
//[of]:testExtend
function testExtend

	// Signed
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PMemoryValue	: { 'memory, 'dword, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xBE)
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PMemoryValue	: { 'memory, 'word, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xBE)
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PMemoryValue	: { 'memory, 'byte, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xBE)
	self xtend (*PRegisterValue	: { 'register, 'dword, nil, 'r12},	*PMemoryValue	: { 'memory, 'word, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xBE)
	self xtend (*PRegisterValue	: { 'register, 'dword, nil, 'r12},	*PMemoryValue	: { 'memory, 'byte, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xBE)
	self xtend (*PRegisterValue	: { 'register, 'word, nil, 'r12},	*PMemoryValue	: { 'memory, 'byte, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xBE)
	
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PRegisterValue	: { 'register, 'dword, nil, 'rbx},	0xBE)
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PRegisterValue	: { 'register, 'word, nil, 'rbx},	0xBE)
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PRegisterValue	: { 'register, 'byte, nil, 'rbx},	0xBE)
	self xtend (*PRegisterValue	: { 'register, 'dword, nil, 'r12},	*PRegisterValue	: { 'register, 'word, nil, 'rbx},	0xBE)
	self xtend (*PRegisterValue	: { 'register, 'dword, nil, 'r12},	*PRegisterValue	: { 'register, 'byte, nil, 'rbx},	0xBE)
	self xtend (*PRegisterValue	: { 'register, 'word, nil, 'r12},	*PRegisterValue	: { 'register, 'byte, nil, 'rbx},	0xBE)

	// Zero extension
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PMemoryValue	: { 'memory, 'dword, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xB6)
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PMemoryValue	: { 'memory, 'word, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xB6)
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PMemoryValue	: { 'memory, 'byte, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xB6)
	self xtend (*PRegisterValue	: { 'register, 'dword, nil, 'r12},	*PMemoryValue	: { 'memory, 'word, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xB6)
	self xtend (*PRegisterValue	: { 'register, 'dword, nil, 'r12},	*PMemoryValue	: { 'memory, 'byte, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xB6)
	self xtend (*PRegisterValue	: { 'register, 'word, nil, 'r12},	*PMemoryValue	: { 'memory, 'byte, *PIntegerValue : {'integer, 'qword, 0x400000}},	0xB6)
	
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PRegisterValue	: { 'register, 'dword, nil, 'rbx},	0xB6)
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PRegisterValue	: { 'register, 'word, nil, 'rbx},	0xB6)
	self xtend (*PRegisterValue	: { 'register, 'qword, nil, 'r12},	*PRegisterValue	: { 'register, 'byte, nil, 'rbx},	0xB6)
	self xtend (*PRegisterValue	: { 'register, 'dword, nil, 'r12},	*PRegisterValue	: { 'register, 'word, nil, 'rbx},	0xB6)
	self xtend (*PRegisterValue	: { 'register, 'dword, nil, 'r12},	*PRegisterValue	: { 'register, 'byte, nil, 'rbx},	0xB6)
	self xtend (*PRegisterValue	: { 'register, 'word, nil, 'r12},	*PRegisterValue	: { 'register, 'byte, nil, 'rbx},	0xB6)

end
//[cf]
//[cf]
//[of]:types
//[of]:ArgumentRegister
//[c]Structure to exchange registers.
//[c]It represents a register that may be copied to another register (dst) and
//[c]may be loaded from another register (src).
//[c]
static struct ArgumentRegister
	var value	: *PValue	// The reduced value, source or destination
	var size	: PValueSize	// The size of value stored in this register
	var processed	: Bool	// This register has been processed already
	var dst	: Index	// This register has a destination register (or -1)
	var src	: Index	// This register has a source register (or -1)
end
//[cf]
//[of]:MemoryInfo
//[c]Stores parameters to encode an effective address.
//[c]
static struct MemoryInfo

	var flags	: Flags
	var rex	: Byte
	var modrm	: Byte
	var sib	: Byte
	var offset	: Disp32
	var symbol	: ObjectSymbol

	static stype Flags : Byte
		'sib	= 1
		'offset8	= 2
		'offset32	= 4
		'reference	= 8
	end

//[of]:	offset8
function offset8
	return self offset cast (Byte)
end
//[cf]
//[of]:	offset32
function offset32
	return self offset
end
//[cf]
	
//[of]:	setSib
function setSib (sib: Byte)
	self sib = sib
	self flags |= 'sib
end
//[cf]
//[of]:	setOffset8
function setOffset8 (offset: Byte)
	self offset = offset cast (Disp32)
	self flags |= 'offset8
end
//[cf]
//[of]:	setOffset32
function setOffset32 (offset: Disp32)
	self offset = offset
	self flags |= 'offset32
end
//[cf]
	
//[of]:	setReference
function setReference (	symbol	: ObjectSymbol,
	offset	: Disp32)

	self modrm	= modrm (0, 0, 4)
	self sib	= 5 + (4 << 3) + (0 << 6)	// base = 4, index = 4, scale = any
	self offset	= offset
	self symbol	= symbol
	self flags = 'reference | 'sib

end
//[cf]
//[of]:	setAddress32
function setAddress32 (address: Disp32)
	self modrm = modrm (0, 0, 4)
	self sib = 5 + (4 << 3) + (0 << 6)	// base = 4, index = 4, scale = any
	self offset = address
	self flags = 'offset32 | 'sib
end
//[cf]
//[of]:	setIndex
function setIndex (	register	: Register,
	offset	: Disp32)

	self rex |= (register & 8) >> 3
	var reg = register & 7
	
	if reg == 'rsp
		self setIndexAndScale2 (offset, reg, 4, 0)
	// Remark: [rbp] must be coded as [rbp + 0]
	elsif offset == 0 and reg <> 'rbp
		self modrm = modrm (0, 0, reg)
	elsif isShortDisplacement (offset)
		self modrm = modrm (0, 1, reg)
		self setOffset8 (offset cast (Byte))
	else
		self modrm = modrm (0, 2, reg)
		self setOffset32 (offset)
	end

end
//[cf]
//[of]:	setIndexAndScale
function setIndexAndScale2 (	offset	: Disp32,
	baseRegister	: Byte,
	indexRegister	: Byte,
	ss	: Byte)

	self rex |= (baseRegister & 8) >> 3
	self rex |= (indexRegister & 8) >> 2
	var baseReg = baseRegister & 7
	var indexReg = indexRegister & 7

	// Remark: [rbp + scaled] must be coded as [ebp + scaled + 0]
	if offset == 0 and baseReg <> Register : 'rbp
		self modrm = modrm (0, 0, 4)
		self setSib (baseReg + (indexReg << 3) + (ss << 6))
	elsif isShortDisplacement (offset)
		self modrm = modrm (0, 1, 4)
		self setSib (baseReg + (indexReg << 3) + (ss << 6))
		self setOffset8 (offset cast (Byte))
	else
		self modrm = modrm (0, 2, 4)
		self setSib (baseReg + (indexReg << 3) + (ss << 6))
		self setOffset32 (offset)
	end

end

function setIndexAndScale (	offset	: Disp32,
	indexRegister	: Byte,
	ss	: Byte)

	self rex |= (indexRegister & 8) >> 2
	var indexReg = indexRegister & 7
	
	self modrm = modrm (0, 0, 4)
	self setSib (5 + (indexReg << 3) + (ss << 6))
	self setOffset32 (offset)

end
//[cf]

//[of]:	hasOffset8
function hasOffset8
	return (self flags & 'offset8) <> 0
end
//[cf]
//[of]:	hasOffset32
function hasOffset32
	return (self flags & 'offset32) <> 0
end
//[cf]
//[of]:	hasReference
function hasReference
	return (self flags & 'reference) <> 0
end
//[cf]
//[of]:	hasSib
function hasSib
	return (self flags & 'sib) <> 0
end
//[cf]

end
//[cf]
//[cf]
//[of]:utils
//[of]:modrm
static function modrm (reg: Byte, mod: Byte, rm: Byte)
	return (reg << 3) + (mod << 6) + rm
end
//[cf]
//[of]:isShortDisplacement
static function isShortDisplacement (x)
	var d = x asSigned
	return d >= -128 and d < 128
end
//[cf]
//[of]:postStoreRegister
//[c]Store a spilled variable: from the register to the stack.
//[c]
function postStoreRegister (value: *PRegisterValue)

	var variable = value variable
	
	// No variable: it is a register (likely rsp)
	if variable isNil
		return
	end
	
	// The variable is not spilled: no post-store needed
	if not variable spilled
		return
	end

	var register = value register
	self writeMemory (variable memory, register, 0xFF, 0x88)
		
end
//[cf]
//[of]:preloadRegisters
function preloadRegisters (m: *PMemoryValue)

	var address = m address
	if address code == 'index
		self preloadIndex (address asIndex)
	elsif address code == 'register
		self preloadRegister (address asRegister)
	end

end
//[cf]
//[of]:preloadIndex
function preloadIndex (i: *PIndexValue)
	var base = i base
	if base notNil and base code == 'register // base can be 'base or 'local
		self preloadRegister (base asRegister)
	end
	var index = i index
	if index notNil
		self preloadRegister (index asRegister)
	end
end
//[cf]
//[of]:preloadRegister
function preloadRegister (value: *PRegisterValue)

	var variable = value variable
	
	// No variable: it is a register (likely rsp)
	if variable isNil
		return
	end
	
	// The variable is not spilled: no preload needed
	if not variable spilled
		return
	end

	var register = value register
	var mask = register mask
	// The variable is already loaded
	if self loaded & mask <> 'none
		return
	end
	
	self writeMemory (variable memory, register, 0xFF, 0x8A)
	self loaded |= mask
		
end
//[cf]
//[of]:processGraph
//[c]Generates all the mov instructions in the right order according to the
//[c]register graph.
//[c]
function processGraph (n: Index, slots: *[]ArgumentRegister)

	n each do start
		var s = slots [start]
		// Skip if processed or no source
		if not s processed and s src <> -1
			var i = start
			repeat
				// This register has no destination
				if s dst == -1
					while s src <> -1
						var src = s src
						self movRegisterRegister (slots [src] size, registerArguments [i], registerArguments [src])
						s processed = true
						i = src
						s = slots [i]
					end
					break
				
				// The destination is the starting point: there is a circular dependency
				elsif s dst == start
					// We could optimize short loops with an XCHG
					self movRegisterRegister (slots [start] size, 'rax, registerArguments [start])
					repeat
						var dst = s dst
						self movRegisterRegister (slots [i] size, registerArguments [dst], registerArguments [i])
						slots [dst] processed = true
						i = s src
						s = slots [i]
						if i == start
							break
						end
					end
					var dst = s dst
					self movRegisterRegister (slots [start] size, registerArguments [dst], 'rax)
					slots [dst] processed = true
					break
					
				else
					i = s dst
					s = slots [i]
				end
			end
		end
	end

end
//[cf]
//[cf]
//[of]:writing
//[of]:getMemory
function getMemory (value: *PValue, info: *MemoryInfo)

	// Initialize memory info
	info flags = 0
	info rex = 0
	
	switch value code
	case 'integer
		info setAddress32 (value asInteger offset)
		
	case 'register
		info setIndex (value asRegister register, 0)
	
	case 'global
		var glob = value asGlobal
		info setReference (glob symbol, 0)

	case 'index
		var v	= value asIndex
		var offset	= v offset
		var i	= v index asRegister
		
		var b : Register
		var base = v base
		if base isNil
			b = 'none
		elsif base code == 'register
			b = base asRegister register
		elsif base code == 'base
			// Translate base to rsp
			b = 'rsp
			offset += self callStackSize
			offset += self paddingStackSize
			offset += self localStackSize
			offset += self saveRegisterStackSize
		elsif base code == 'local
			// Translate local to rsp
			b = 'rsp
			offset += self callStackSize
			offset	+= self paddingStackSize
		else
			assertFailure ("index: invalid base type")
		end
		
		if i isNil
			info setIndex (b, offset)
		else
			var scale = v scale
			var ss = Byte : (	scale == 1 cond 0 else
				scale == 2 cond 1 else
				scale == 4 cond 2 else
				3)
			if b == 'none
				info setIndexAndScale (offset, i register, ss)
			else
				info setIndexAndScale2 (offset, b, i register, ss)
			end
		end
		
	// These ones are non-sense but could happen with a cast
	// 'function
	else
		assertFailure ("memory: invalid address type")
	end

end
//[cf]
//[of]:writeImmediate
//[c]Writes any immediate value (imm8, imm16 or imm32).
//[c]
function writeImmediate (value: *PValue)

	var i = value asInteger
	switch value size
	case 'byte
		self writeByte (i byte)
	case 'word
		self writeWord (i word)
	else // 'dword, 'qword
		// A qword always fits in 32 bits
		self writeDword (i dword)
	end

end
//[cf]
//[of]:writeLabel
function writeLabel (label: *PLabel)
	var pos = self text buffer pos
	var off32 = label address - (pos + 4)
	self writeDword (off32 toDword)
end
//[cf]
//[of]:writeModrm
function writeModrm (r: Byte, mod: Byte, rm: Byte, ...)

	vargs_each do opcode
		self writeByte (opcode)
	end
	self writeByte (modrm (r, mod, rm))

end
//[cf]
//[of]:writeMemory
//[c]Writes an instruction with the form 
//[c]	op rm, r
//[c]	op r, rm
//[c]	op rm, imm
//[c]
//[c]PARAMETERS
//[c]	value	--	The value corresponding to rm.
//[c]	register	--	The value corresponding to r or the opcode extension if it's the rm, imm form.
//[c]	mask	--	It prevents adding a 0x40 REX prefix with the 'rm, imm' form.
//[c]			So it must be 0 with 'rm, imm' and 0xFF otherwiser.
//[c]	opcode0	--	The base opcode: it is incremented for word, dword and qword sizes
//[c]	...	--	Additional prefix to the opcode
//[c]
function writeMemory (	value	: *PMemoryValue, 
	register	: Byte, 
	mask	: Byte,
	opcode0	: Byte, ...)

	var info : MemoryInfo
	self getMemory (value address, info)
	var rex = info rex
	rex |= (register & 8) >> 1
	var opcode = opcode0
	switch value size
	case 'byte
		// Special case: force REX prefix with sil, dil, bpl or spl
		if register & mask >= 4
			rex |= 0x40
		end
	case 'word
		self writeByte (0x66)
		opcode ++
	case 'dword
		opcode ++
	case 'qword
		rex |= 8
		opcode ++
	end
	self writeOpcode (rex, opcode, ...)
	self writeMemoryInfo (info, register & 7)

end
//[cf]
//[of]:writeMemoryInfo
function writeMemoryInfo (	info	: *MemoryInfo,
	register	: Byte)

	self writeByte (info modrm | (register << 3))
	if info hasSib
		self writeByte (info sib)
	end
		
	if info hasOffset8
		self writeByte (info offset8)
	elsif info hasOffset32
		self writeDword (info offset32 asUnsigned)
	elsif info hasReference
		self text writeReference32 (info symbol, info offset)
	end

end
//[cf]
//[of]:writeOpcode
function writeOpcode (rex: Byte, opcode: Byte, ...)
	if rex <> 0
		self writeByte (0x40 | rex)
	end
	vargs_each do op
		self writeByte (op)
	end
	self writeByte (opcode)
end
//[cf]
//[of]:writeRegister
function writeRegister (value: *PRegisterValue, reg: Byte, mask: Byte, opcode0: Byte, ...)
	self writeRegRM (value size, reg, mask, value register, opcode0, ...)
end
//[cf]
//[of]:writeRegRM
function writeRegRM (	size	: PValueSize, 
	reg	: Byte, 
	mask	: Byte, 
	rm	: Byte, 
	opcode0	: Byte, ...)

	var rex = ((reg & 8) >> 1) | ((rm & 8) >> 3)
	var opcode = opcode0
	switch size
	case 'byte
		// Special case: force REX prefix with sil, dil, bpl or spl
		if (reg & mask) >= 4 or rm >= 4
			rex |= 0x40
		end
	case 'word
		self writeByte (0x66)
		opcode ++
	case 'dword
		opcode ++
	case 'qword
		rex |= 8
		opcode ++
	end
	self writeOpcode (rex, opcode, ...)
	self writeByte (modrm (reg & 7, 3, rm & 7))

end
//[cf]
//[of]:writeRelative
//[c]Writes a relative address (for function calls)
//[c]
function writeRelative (address: ObjectOffset)
	var buffer = self textSection buffer
	var origin	= buffer pos
	buffer writeDword ((address - (origin + 4)) cast (Uint32))
end
//[cf]
//[of]:writeRM
function writeRM (rm: *PValue, register: Byte, mask: Byte, opcode: Byte, ...)
	if rm isRegister
		self writeRegister (rm asRegister, register, mask, opcode, ...)
	else
		self preloadRegisters (rm asMemory)
		self writeMemory (rm asMemory, register, mask, opcode, ...)
	end
end
//[cf]
//[of]:writeRMX
//[c]Same as write RM, but it uses an explicit size
//[c]* movzx, movsx don't follow the size of the rm value.
//[c]* call rm is implicitly 64 bit, so it does not need a REX.W flag (pass dword size instead of qword).
//[c]
function writeRMX (size: PValueSize, rm: *PValue, register: Byte, mask: Byte, opcode: Byte, ...)
	if rm isRegister
		self writeRegRM (size, register, mask, rm asRegister register, opcode, ...)
	else
		// Create a fake source rm with the extended size
		var m : PMemoryValue
		m code = 'memory
		m size = size
		m address = rm asMemory address
		
		self preloadRegisters (m)
		self writeMemory (m, register, mask, opcode, ...)
	end
end
//[cf]

//[of]:writeByte
function writeByte (v: Uint8)
	self text buffer writeByte (v)
end
//[cf]
//[of]:writeWord
function writeWord (v: Uint16)
	self text buffer writeWord (v)
end
//[cf]
//[of]:writeDword
function writeDword (v: Uint32)
	self text buffer writeDword (v)
end
//[cf]
//[of]:writeQword
function writeQword (v: Uint64)
	self text buffer writeQword (v)
end
//[cf]
//[cf]
//[cf]
//[of]:generateDirectTable
function generateDirectTable (table: *SwitchTable)

	var range = (table high - table low + 1) cast (Index)
	var section = self text
	var buffer = section buffer
	
	// Align the table on qword
	buffer align ('qword, 0)

	var glob = table value
	glob symbol = self createAutoSymbol (section, glob length)
	glob address = buffer pos
	glob length = range cast (ObjectOffset) * 'qword

	var s = self getDirectBuffer (range)
	
	// Initialize the buffer: fill with defaultLabel
	var p = s
	var limit = p + range
	var default = table defaultLabel
	while p <> limit
		p [] = default
		p ++
	end
	
	// Fill the buffer
	var low = table low
	table each do value, label
		s [value - low] = label
	end
	
	// Generate the table
	range each do i
		var offset = (s [i] address - table pfunction address) toInt64
		section writeReference64 (table pfunction symbol, offset)
	end
	
end

function getDirectBuffer (n: Index)
	if self directSize < n
		(*PLabel) freeArray (self directBuffer, self directSize)
		self directSize = n
		self directBuffer = (*PLabel) allocateArray (n)
	end
	return self directBuffer
end
//[cf]
//[of]:generateLookupTable
function generateLookupTable (table: *SwitchTable)

	var section = self text
	var buffer = section buffer
	
	// Align the table on qword
	buffer align ('qword, 0)

	var glob = table value
	glob symbol = self createAutoSymbol (section, glob length)
	glob address = buffer pos

	// Write all values
	table each do value, label
		buffer writeQword (value asUnsigned)
		var offset = (label address - table pfunction address) toInt64
		section writeReference64 (table pfunction symbol, offset)
	end
	var offset = (table defaultLabel address - table pfunction address) toInt64
	section writeReference64 (table pfunction symbol, offset)
	buffer writeQword (0)
	
	glob length = buffer pos - glob address

end
//[cf]
//[of]:addBuiltins
//[c]Add builtin functions.
//[c]This function must be executed at the end of the pass because the flag
//[c]'used' must be set: we must emit the exact same number of bytes
//[c]during the two passes.
//[c]
//[c]builtin flag could be computed during the p-code generation instead
//[c]and so the used flag would be known at the beginning of the first
//[c]pass.
//[c]
function addBuiltins

	var builtin = self lookupBuiltin
	if builtin used
		var section = self text
		var buffer = section buffer
		builtin symbol = self createAutoSymbol (section, builtin size)
		builtin address = buffer pos
		buffer write (builtin data, builtin size)
	end

end
//[cf]

//[of]:writeStructure
static function writeStructure (section: *ObjectContent, structure: *StructureType, iter: *ExpressionIterator) :

	var buffer = section buffer
	var origin = buffer pos
	
	if structure parentStructure notNil
		writeStructure (section, structure parentStructure, iter)
	end

	structure eachAttribute do a
		// Align next attribute
		var n = ObjectOffset fromSize (a offset) - (buffer pos - origin)
		while n > 0
			buffer writeByte (0)
			n --
		end
		writeValue (section, a storageType, iter)
	end
	
	// Align the structure
	var o = buffer pos - origin
	var n = o
	var align = ObjectOffset fromSize (structure align)
	n += align - 1
	n &= not (align - 1)
	n -= o
	while n > 0
		buffer writeByte (0)
		n --
	end

end
//[cf]
//[of]:writeArray
static function writeArray (section: *ObjectContent, arrayType: *ArrayType, iter: *ExpressionIterator)

	var cellType = arrayType cellType
	var n = arrayType arraySize
	var i = Size : 0
	repeat
		if n == 0
			if iter isEOF
				break
			end
		elsif i == n
			break
		end
		writeValue (section, cellType, iter)
		i ++
	end	

end
//[cf]
//[of]:writeValue
static function writeValue (section: *ObjectContent, type: *Type, iter: *ExpressionIterator) :

	if type isStructure
		writeStructure (section, type asStructure, iter)
	elsif type isArray
		writeArray (section, type asArray, iter)
	else
		writeConstant (section, iter value, type)
		iter next
	end

end
//[cf]
//[of]:writeConstant
static function writeConstant (section: *ObjectContent, e: *Expression, type: *Type)

	var buffer = section buffer
	if e code == 'constantInteger
		var integer	= e asConstantInteger value
		switch type size
		case 1
			buffer writeByte (integer cast (Uint8))
		case 2
			buffer writeWord (integer cast (Uint16))
		case 4
			buffer writeDword (integer cast (Uinteger))
		else
			buffer writeQword (integer)
		end
	elsif e code == 'constantFunction
		if e asConstantFunction value code == 'function
			section writeReference64 (pfunction (e) master symbol, 0)
		else // 'extern
			section writeReference64 (pglobal (e) symbol, 0)
		end
	elsif e code == 'constantGlobal
		section writeReference64 (pglobal (e asConstantGlobal variable) symbol, 0)
	else
		section writeReference64 (pglobal (e) symbol, 0)
	end

end
//[cf]
//[cf]
//[of]:removeDuplicateFunctions
function removeDuplicateFunctions

	// Don't remove duplicate as very different source code may have 
	// same code, resulting unusable source level debugging.
	if self debug
		return
	end

	var buckets : FunctionBuckets
	buckets initialize

	// Divide functions up by hash value
	// This step reduce the number of comparisons as we compare
	// only functions with the same hash value.
	self program eachFunction do f
		var pf	= pfunction (f)
		if not pf ignore
			buckets add (f)
		end
	end
	
	// Compare pair of functions inside each bucket
	var count = Index : 0
	buckets each do bucket
		var n = bucket size
		if bucket size > 1
			(n - 1) each do i1
				var f1	= bucket [i1]
				var m1	= pfunction (f1)
				// Skip this one if it already matches
				if m1 equivalent isNil
					var i2 = i1 + 1
					while i2 < n
						var f2	= bucket [i2]
						var m2	= pfunction (f2)
						// Skip this one if it already matches
						if m2 equivalent isNil
							// Two functions can have identical p-code but a 
							// different calling convention. It is critical to
							// compare calling conventions first.
							if f1 callingConvention == f2 callingConvention and m1 isEqual (m2)
								m1 called |= m2 called
								m1 ignore = not m1 called
								m2 equivalent = f1
								m2 ignore = true
								m2 called = false
								count ++
//[c]								output ("\a duplicate of \a\n", f2, f1)
							end
						end
						i2 ++
					end
				end
			end
		end
	end

	if self dump
		var sb : StringBuffer
		sb initialize
		sb << String : "Functions: " 
		sb << buckets count
		sb << CodeUnit : 'lf
		sb << String : "Buckets: " 
		sb << buckets buckets size
		sb << CodeUnit : 'lf
		sb << String : "Biggest bucket : " 
		sb << buckets maxCount
		sb << CodeUnit : 'lf
		sb << String : "Duplicates: " 
		sb << count
		sb << CodeUnit : 'lf
		println (sb string)
		sb release
	end
	
	buckets release

end

//[of]:FunctionBuckets
static const FunctionBucket = Vector (*Function)

static struct FunctionBuckets
	var buckets	: SimpleDictionary (Size, *FunctionBucket, Size : 0, nil)
	var count	: Integer
	var maxKey	: Size
	var maxCount	: Integer
	
	function initialize
		self buckets initialize
		self count	= 0
		self maxCount = 0
		self maxKey = 0
	end
	
	function release
		self buckets eachValue do bucket
			bucket delete
		end
		self buckets release
	end
		
	function add (f: *Function)
		var pf = pfunction (f)
		var key = pf hash | 1
		var bucket = self buckets [key]
		if bucket isNil
			bucket = FunctionBucket new
			self buckets add (key, bucket)
		end
		bucket add (f)

		if bucket size > self maxCount
			self maxKey = key
			self maxCount = bucket size
		end
		self count ++
	end
	
	function each
		self buckets eachValue do b
			yield b
		end
	end

end
//[cf]
//[cf]
//[of]:prepareFunction
function prepareFunction (f: *Function)

	var pf = pfunction (f)
	if pf ignore
		return
	end
	
	pf computeIntervals
	self sortVariables (pf)
	self computeConflicts (pf)
	self allocateRegisters (pf)
	self allocateSpilledVariables (pf)
	self allocateParameters (pf)

	// Debug
	if self dump
		var sb : StringBuffer
		sb initialize
		sb << f << CodeUnit : 'lf
		sb << pf
		println (sb string)
		sb release
	end

end

//[of]:sortVariables
//[c]Sorts all variables including parameters using the sort insert algorithm:
//[c]it is efficient as the list is already almost sorted.
//[c]
function sortVariables (pf: *PFunction)

	// Remove the variable of the previous run
	self variables removeAll
	
	pf parameters each do v
		self variables add (v)
	end
	
	pf variables each do v
		self variables add (v)
	end

end
//[cf]
//[of]:computeConflicts
//[c]For each variable and parameter: compute the hard registers that are modified
//[c]while the variable/parameter is active.
//[c]
function computeConflicts (pf: *PFunction)

	// Initialize the list of actives
	self activeFirst = 0
	self activeSize = 0

	// Index and Count on variables
	var i = Index : 0
	var n = self variables size

	// Index on instruction
	var regIndex, regInstr = firstRange ('internal, pf instructions firstElement)
	
	// Repeat until no more instruction
	while regInstr notNil
		var v : *PVariable
		var index : InstructionIndex
		if i <> n
			v = self variables [i]
			index = v firstIndex
		else
			index = 'last
		end
		
		if index <= regIndex
			// Case 1: the first is the variable
			self insertToActives (v)
			i ++
		else
			// Case 2: the first is the hard register
			
			// The current location is now regIndex
			var index = regIndex
			
			// The mask is now the one of the instruction
			var mask = regInstr registers

			// Expire all variables no longer active at index			
			var j = self activeFirst
			var m = self activeSize
			while j < m
				var v = self actives [j]
				if v lastIndex >= index
					break
				end
				j++
			end
			self activeFirst = j
			
			// Mark all remaining active variables as in conflict with this new mask
			while j < m
				var v = self actives [j]
				v conflicts |= mask
				j ++
			end

			// Get the next instruction that has one or more hard registers			
			regIndex, regInstr = firstRange (regIndex + 'stepCount, regInstr nextSibling)
		end
	end
		
end
//[c]
static function firstRange (index: InstructionIndex, instruction: *PInstruction)
	var i = index
	var instr = instruction
	while instr notNil and instr registers == 'none
		i += 'stepCount
		instr = instr nextSibling
	end
	return i, instr
end
//[cf]
//[of]:allocateParameters
//[c]* Assigns offset to arguments passed on stack.
//[c]* Allocates a local variable to save register arguments that are spilled.
//[c]
function allocateParameters (pf: *PFunction)

	var offset = Disp32 : 'sizeOfReturnAddress
	var i = Index : 0
	pf parameters each do p
		if i < registerArgumentCount
			// It's a register argument but it is spilled: allocate a local variable to save it
			if p spilled
				var local = pf addLocal (self pool, p size toStackSize)
				p memory = PMemoryValue new (self pool, p size, local)
			end
		else
			p memory = PValue newBase (self pool, p size, offset)
			offset += p size toStackSize
		end
		i ++
	end

end
//[cf]
//[of]:allocateRegisters
//[c]Allocates registers for local variables and parameters.
//[c]
function allocateRegisters (pfunction: *PFunction)

	// Free all registers
	self registers = 'none
	self usedRegisters = 'none
	self lockedRegisters = 'none

	// In debug mode, ebp is used to point to the stack frame
	// so it can not be used
	if self debug
		self registers |= 'rbp
		self usedRegisters |= 'rbp
	end

	// Initialize the list of actives
	self activeFirst = 0
	self activeSize = 0
	
	// For each register parameters: try to allocate the prefered register or
	// any other register
	var i = Index : 0
	pfunction parameters each do p
		if i < registerArgumentCount
			self lockedRegisters = 'none
			self allocateRegister (p)
		end
		i ++
	end

	// Scan all instructions
	var index = InstructionIndex : 0
	pfunction instructions each do instr
		self lockUSE (instr)
		self allocateUSE (instr)
		index += 'stepCount
		self expireOldIntervals (index)
		self allocateDEF (instr)
	end

	// Save used registers
	pfunction usedRegisters = self usedRegisters

end

//[of]:expireOldIntervals
function expireOldIntervals (index: InstructionIndex)

	// Expire old intervals
	var i = self activeFirst
	var n = self activeSize
	while i < n
		var v = self actives [i]
		var last = v lastIndex
		if last >= index
			break
		end
		self freeRegister (v)
		i ++
	end
	self activeFirst = i

end

//[of]:freeRegister
function freeRegister (variable: *PVariable)

	var r = variable register
	self registers &= r register clearMask
	
	// This instruction is useless as we are not accessing the interval from 
	// the variable anymore.
	//variable register = nil

end
//[cf]
//[cf]
//[of]:lockUSE
//[c]For all variables 'use' in the instruction and having already a register
//[c]allocated, this register is locked to prevent being stealed and thus
//[c]avoid generating useless copies.
//[c]
function lockUSE (instruction: *PInstruction)

	self lockedRegisters = 'none

	switch instruction code
	
	case	'load, 'store, 'truncate, 'movsx, 'movzx
	
		var i = instruction asBinary
		self lockWrite (i value1)
		self lockRead (i value2)
	
	case	'add, 'sub, 'smul, 'smul2, 'umul, 'sdiv, 'udiv, 'smod, 'umod, 'and, 'or, 'xor, 'cmp, 'test, 'shlc, 'sshrc, 'ushrc, 'lookup
	
		var i = instruction asBinary
		self lockRead (i value1)
		self lockRead (i value2)
	
	case	'not, 'neg, 
		'shli, 'sshri, 'ushri,
		'jumpi
	
		var i = instruction asUnary
		self lockRead (i value1)

	case	'call
	
		// Only the address has to be locked: arguments are only registers
		// and will be assigned to a specific register anyway.
		var i = instruction asCall
		self lockRead (i address)
	
	case	'return
	
		// Nothing to lock
	
	case	'set
	
		var i = instruction asUnary
		self lockWrite (i value1)

	case 'smul3

		var i = instruction asTernary
		self lockWrite (i value1)
		self lockRead (i value2)
		self lockRead (i value3)
	end

end

//[of]:lockRead
function lockRead (value: *PValue) :

	switch value code
	case 'memory
		self lockRead (value asMemory address)
	case 'index
		var base = value asIndex base
		if base notNil
			self lockRead (base)
		end
		var index = value asIndex index
		if index notNil
			self lockRead (index)
		end
	case 'variable
		var v = value asVariable
		var r = v register
		if r notNil
			self lockedRegisters |= r register mask
		end
	end

end
//[cf]
//[of]:lockWrite
function lockWrite (value: *PValue)

	switch value code
	case 'memory
		self lockRead (value asMemory address)
	case 'index
		var base = value asIndex base
		if base notNil
			self lockRead (base)
		end
		var index = value asIndex index
		if index notNil
			self lockRead (index)
		end
	end

end
//[cf]
//[cf]
//[of]:allocateUSE
//[c]Allocates a register in a read or read/write access
//[c]
function allocateUSE (instruction: *PInstruction)

	switch instruction code

	// load r, rmix
	case 'load, 'truncate, 'movsx, 'movzx

		var i = instruction asBinary
		i value2 = self allocateRM (i value2)
	
	// store rm, ri
	case 'store
	
		var i = instruction asBinary
		self allocateM (i value1)
		i value2 = self allocateR (i value2)
	
	// op r, rmi
	// op rm, ri
	case	'add, 'sub, 'and, 'or, 'xor, 'cmp
	
		var i = instruction asBinary
		if i value1 isR
			i value1 = self allocateR (i value1)
			i value2 = self allocateRM (i value2)
		else
			i value1 = self allocateRM (i value1)
			i value2 = self allocateR (i value2)
		end
	
	// op rm, rm
	case	'smul, 'umul, 'sdiv, 'udiv, 'smod, 'umod, 'shlc, 'sshrc, 'ushrc
	
		var i = instruction asBinary
		i value1 = self allocateRM (i value1)
		i value2 = self allocateRM (i value2)

	// smul r, rmi
	case	'smul2
	
		var i = instruction asBinary
		i value1 = self allocateR (i value1)
		i value2 = self allocateRM (i value2)

	// smul r, rm, i
	case	'smul3
	
		var i = instruction asTernary
		self allocateM (i value1)
		i value2 = self allocateRM (i value2)

	// test rm, ri
	case	'test
	
		var i = instruction asBinary
		i value1 = self allocateRM (i value1)
		i value2 = self allocateR (i value2)

	// op rm
	case	'not, 'neg, 
		'shli, 'sshri, 'ushri,
		'jumpi
	
		var i = instruction asUnary
		i value1 = self allocateRM (i value1)

	// set rm
	case	'set
	
		var i = instruction asUnary
		self allocateM (i value1)
	
	// call rmi, ri, ri, ... -> r, r, ...
	case 'call
		
		var instr = instruction asCall
		instr address = self allocateRM (instr address)
		
		var i = Index : 0
		var n = instr argumentCount
		var args = instr argumentValues
		while i < n
			args [i] = self allocateRM (args [i])
			i ++
		end
	
	case 'return
	
		var instr = instruction asReturn
		
		var i = Index : 0
		var n = instr count
		var args = instr values
		while i < n
			args [i] = self allocateRM (args [i])
			i ++
		end
		
	case 'lookup

		var i = instruction asBinary
		i value1 = self allocateRM (i value1)
		i value2 = self allocateR (i value2)

	end

end

//[of]:allocateR
function allocateR (value: *PValue) : *PValue

	switch value code
	case 'memory
		var m = value asMemory
		m address = self allocateR (m address)
	case 'index
		var i = value asIndex
		var base = i base
		if base notNil
			i base = self allocateR (base)
		end
		var index = i index
		if index notNil
			i index = self allocateR (index)
		end
	case 'variable
		var v = value asVariable
		
		// Allocate a register
		return self allocateRegister (v)
	end
	return value

end
//[cf]
//[of]:allocateRM
function allocateRM (value: *PValue)

	switch value code
	case 'memory
		var m = value asMemory
		m address = self allocateR (m address)
	case 'index
		var i = value asIndex
		var base = i base
		if base notNil
			i base = self allocateR (base)
		end
		var index = i index
		if index notNil
			i index = self allocateR (index)
		end
	case 'variable
		var v = value asVariable
		
		// Spilled and rm : we can skip allocation
		if v spilled
			return v
		end
			
		return self allocateRegister (v)
	end
	return value

end
//[cf]
//[of]:allocateM
function allocateM (value: *PValue)

	if value code == 'memory
		var m = value asMemory
		m address = self allocateR (m address)
	end

end
//[cf]
//[cf]
//[of]:allocateDEF
//[c]Allocates a register in a write access
//[c]
//[c]	The read and read/write have already been processed :
//[c]	- the source operand
//[c]	- the target operand when the target is also read (add, sub, ...)
//[c]	- the base and index value of the target operand (it is always a read access)
//[c]	
//[c]	Only the target operand of movs to a register are still concerned.
//[c]	
function allocateDEF (instruction: *PInstruction)

	self lockedRegisters = 'none
	
	switch instruction code
	// load	r, rmix
	// truncate	r, rm
	// movsx	r, rm
	// movzx	r, rm
	case 'load, 'truncate, 'movsx, 'movzx
	
		var i = instruction asBinary
		i value1 = self allocateWriteR (i value1)
	
	// store rm, ri
	case 'store
	
		var i = instruction asBinary
		i value1 = self allocateWriteRM (i value1)

	// smul r, rm, i
	case 'smul3
	
		var i = instruction asTernary
		i value1 = self allocateWriteR (i value1)

	// set rm
	case 'set
	
		var i = instruction asUnary
		i value1 = self allocateWriteRM (i value1)

	case 'call

		var instr = instruction asCall	
		var i = Integer : 0
		var n = instr returnCount
		var args = instr returnValues
		while i < n
			if i < registerReturnCount
				// Values returned as register can be stored directly on stack
				args [i] = self allocateWriteRM (args [i])
			else
				// Values return on stack needs a register
				args [i] = self allocateWriteR (args [i])
			end
			i ++
		end
	end

end

//[of]:allocateWriteR
function allocateWriteR (value: *PValue)

	if value code == 'variable
		var v = value asVariable
		return self allocateRegister (v)
	end
	return value

end
//[cf]
//[of]:allocateWriteRM
function allocateWriteRM (value: *PValue)

	if value code == 'variable
		var v = value asVariable
		// Spilled and rm : we can skip allocation and use the [esp + k] value instead
		if v spilled
			return v
		end
		return self allocateRegister (v)
	end
	return value

end
//[cf]
//[cf]
//[of]:allocateRegister
function allocateRegister (variable: *PVariable)

	// Use the existing register if any
	if variable register notNil
		return variable register
	end
	
	var rid = self getFreeRegister (variable)

	if rid == 'none
		// No free register found: the variable steals the register of the 
		// last active variable.
		// Scan all active variables (i.e. variables having a register)
		// from the last to die to the first
		var index = self activeSize
		var first = self activeFirst
		repeat
			if index == first
				// Internal error: there is not enough register
				assertFailure ("There is not enough register")
				return nil
			end
			index --
			var spill	= self actives [index]
			rid = spill register register
			// Never spill a locked register or a conflicting register
			if (rid mask & (self lockedRegisters | variable conflicts)) == 'none
				// Move 'spill' to stack
				spill spilled = true
				spill register = nil
				
				// Remove 'spill' from the list of actives
				var lastIndex = self activeSize - 1
				while index <> lastIndex
					self actives [index] = self actives [index + 1]
					index ++
				end
				self activeSize --
				break
			end
		end
	end
	
	return self createRegister (variable, rid)

end

//[of]:getFreeRegister
//[c]Finds a free register
//[c]
//[c]RETURN VALUES
//[c]	The register or 'none.
//[c]	
function getFreeRegister (variable: *PVariable) : Register

	// Free registers
	var r = not (self registers | variable conflicts)

	// 1. Test the preferred register
	var p = variable preferred
	if p <> 'none and (r & p mask) <> 'none
		return p
	
	// 2. Test scratch registers
	elsif (r & ('rax | 'rcx | 'rdx | 'rsi | 'rdi | 'r8 | 'r9 | 'r10 | 'r11)) <> 'none
		// Try scratch registers that are not used as parameters first: rax, r10 and r11
		if (r & 'rax) <> 'none
			return 'rax
		elsif (r & 'r10) <> 'none
			return 'r10
		elsif (r & 'r11) <> 'none
			return 'r11
		elsif (r & 'rcx) <> 'none
			return 'rcx
		elsif (r & 'rdx) <> 'none
			return 'rdx
		elsif (r & 'rsi) <> 'none
			return 'rsi
		elsif (r & 'rdi) <> 'none
			return 'rdi
		elsif (r & 'r8) <> 'none
			return 'r8
		else
			return 'r9
		end
	
	// 3. Test call savee registers
	elsif r & ('rbx | 'r12 | 'r13) <> 'none
		if (r & 'rbx) <> 'none
			return 'rbx
		elsif (r & 'r12) <> 'none
			return 'r12
		else
			return 'r13
		end
	elsif r & ('r14 | 'r15 | 'rbp) <> 'none
		if (r & 'r14) <> 'none
			return 'r14
		elsif (r & 'r15) <> 'none
			return 'r15
		else
			return 'rbp
		end
	else
		return 'none
	end

end
//[cf]
//[of]:createRegister
function createRegister (variable: *PVariable, rid: Register)

	var rv = self pool new (PRegisterValue, variable, rid)
	variable register = rv

	var mask = rid mask
	self lockedRegisters	|= mask	// This register is used by the current instruction
	self registers	|= mask	// This register is used by an active variable
	self usedRegisters	|= mask	// This register is used by the function
	
	self insertToActives (variable)

	return rv

end
//[cf]
//[cf]
//[cf]
//[of]:allocateSpilledVariables
//[c]Allocates spilled local variables on stack
//[c]
function allocateSpilledVariables (pf: *PFunction)

	pf variables each do v
		// For debugging purpose: force spilled
		//v spilled = true
		if v spilled
			var local = pf addLocal (self pool, v size toStackSize)
			v memory = PMemoryValue new (self pool, v size, local)
		end
	end

end
//[cf]
//[of]:insertToActives
function insertToActives (pvariable: *PVariable)

	var i = self activeSize
	var first = self activeFirst
	var actives = self actives
	while i > first
		var v = actives [i - 1]
		if pvariable lastIndex >= v lastIndex
			break
		end
		actives [i] = v
		i --
	end
	actives [i] = pvariable
	self activeSize ++

end
//[cf]
//[cf]
//[of]:debugging
//[of]:startDebugInfo
function startDebugInfo

	var section = self debugInfo
	var buffer = section buffer

	// Write compile unit
	buffer writeByte (Abbrev : 'compileUnit)
	self addString ("Copper")	// producer
	buffer writeWord (0xC0DE)	// language
	section writeReference64 (self textSymbol, 0)	// low_pc
	buffer writeQword (self textSize toQword)	// high_pc
	section writeReference32 (self debugLineSymbol, 0)	// stmt_list
	
end

function addString (str: String8)
	var off = self debugstr add (str)
	self debugInfo writeReference32 (self debugStringSymbol, off toInteger)
end
//[cf]
//[of]:startDebugLine
function startDebugLine

	var b = self debugline buffer
	b writeDword (self debugLineLength toDword)	// Size of section
	b writeWord (2)	// Version (4 is not working with gdb
	b writeDword (self headerLength toDword)	// Header length
	var headerStart = b pos	
	b writeByte (1)	// Minimum instruction length
	//b writeByte (1)	// Maximum operations per instruction (version 4)
	b writeByte (1)	// Default is_stmt
	b writeByte (0)	// ###  Line base
	b writeByte (10)	// ### Line range
	b writeByte (dwarfOpcodeBase cast (Byte))	// Opcode base
		
	b writeByte (0)	// Standard opcode lengths
	b writeByte (1)
	b writeByte (1)
	b writeByte (1)
	b writeByte (1)
	b writeByte (0)
	b writeByte (0)
	b writeByte (0)
	b writeByte (1)
	b writeByte (0)
	b writeByte (0)
	b writeByte (1)

	b writeByte (0)	// Include directories (empty)
	
	self program eachModule do m
		b writeString (m filename)	// file name
		b writeByte (0)	// include directory
		b writeByte (0)	// last modification
		b writeByte (0)	// file size
	end
	b writeByte (0)	// terminate the list
	
	self headerLength = b pos - headerStart

	// Initialize state
	self debugModule	= self program modules firstElement
	self debugAddress	= 0
	self debugLineNumber	= 1

	b writeByte (LineNumberOps : 'extended_op)
	b writeByte (8 + 1)
	b writeByte (LineNumberExtendedOps : 'set_address)
	self debugline writeReference64 (self textSymbol, 0)
	
end
//[cf]
//[of]:endDebugInfo
function endDebugInfo

	self textSize = self textSection buffer pos
	
	// Add an entry for all types
	// We don't use the regular iterator because
	// we must ensure that the nextSibling is read after processing
	// item as processing may add new items
	var section = self debugInfo
	var buffer = section buffer
	var dt = self types firstElement
	while dt notNil
		dt pos = buffer pos
		self addDwarfType (dt)
		dt = dt nextSibling
	end

end
//[cf]
//[of]:endDebugLine
function endDebugLine

	// end_sequence
	var b = self debugline buffer
	b writeByte (LineNumberOps : 'extended_op)
	b writeByte (1)
	b writeByte (LineNumberExtendedOps : 'end_sequence)
	
	// Save the size of the debug line section (not counting the size attribute)
	self debugLineLength = self debugline buffer pos - 4

end
//[cf]
//[of]:addDebugFunction
function addDebugFunction (df: *DwarfFunction, address: ObjectOffset, length: ObjectOffset)

	if not self debug
		return
	end

	var debuginfo = self debugInfo
	var buffer = debuginfo buffer
	buffer writeByte (Abbrev : 'subprogram)
	writeFunctionName (buffer, df func)	// name
	debuginfo writeReference64 (textSymbol, address toInt64)	// low_pc
	buffer writeQword (length toQword)	// high_pc
	buffer writeByte (1)	// size of frame base location
	buffer writeByte (LocationAtom : 'reg7)	// frame_base: rsp
	buffer writeDword (df sibling toDword)	// sibling

	// Write parameters
	var f = df func
	var pf = pfunction (f)
	var v = pf parameters firstElement // can't use generator: the binding is erased
	f eachParameter do p
		if not p type isMeta
			buffer writeByte (Abbrev : 'parameter)
			var name = p name
			buffer writeString8 (name isNil cond "_" else name string)
			buffer writeDword (self getDwarfType (p type))
			self addLocation (buffer, v)
			v = v nextSibling
		end
	end
	
	// Write local variables
	pf variables each do v
		if v name notNil
			buffer writeByte (Abbrev : 'variable)
			buffer writeString8 (v name)
			buffer writeDword (self getDwarfType (v type))
			self addLocation (buffer, v)
		end
	end

	buffer writeByte (0) // terminate 'subprogram entry
	df sibling = buffer pos

end

static const locationRegisters = *[]LocationAtom : {
	'reg0,	// 'rax
	'reg2,	// 'rcx
	'reg1,	// 'rdx
	'reg3,	// 'rbx
	'reg7,	// 'rsp
	'reg6,	// 'rbp
	'reg4,	// 'rsi
	'reg5,	// 'rdi
	'reg8,	// 'r8
	'reg9,	// 'r9
	'reg10,	// 'r10
	'reg11,	// 'r11
	'reg12,	// 'r12
	'reg13,	// 'r13
	'reg14,	// 'r14
	'reg15}	// 'r15

function addLocation (buffer: *VirtualBuffer, v: *PVariable)
	if v spilled
		var addr = v memory address downcast (*PIndexValue)
		assert (addr code == 'index, "The spilled variable is not an index")
		var off = addr offset
		off += self callStackSize
		off += self paddingStackSize
		if addr base code == 'base
			off += self localStackSize
			off += self saveRegisterStackSize
		end
		buffer writeByte (1 + getSLEB32Size (off))
		buffer writeByte (LocationAtom : 'fbreg)
		buffer writeSLEB32 (off)
	elsif v register notNil
		buffer writeByte (1) // size of location
		buffer writeByte (locationRegisters [v register register])
	else
		// The variable may be neither spilled nor register-attributed if it
		// is unused. In such a case, we put a random register
		buffer writeByte (1) // size of location
		buffer writeByte (LocationAtom : 'reg0)
	end
end

static function getSLEB32Size (value: Int32)
	var n = Byte : 0
	var v = value
	repeat
		n ++
		var sign = Int32 : ((v & 0x40) == 0 cond 0 else -1)
		v >>= 7
		if v == sign
			break
		end
	end
	return n
end
//[cf]
//[of]:getDwarfType
//[c]Returns the location in the .debug_info section where the type is declared.
//[c]
//[c]If the type is not registered yet, a DwarfType peer object is allocated.
//[c]The type will be written at the end of the pass, so it does not have
//[c]a location in the first pass.
//[c]
function getDwarfType (type: *Type)
	var dt = type generator downcast (*DwarfType)
	if dt isNil
		dt = self pool allocate (DwarfType)
		type generator = dt
		dt type = type
		dt pos = 'undefined
		dt sibling = 'undefined
		self types add (dt)
	end
	return dt pos toDword
end
//[cf]
//[of]:addDwarfType
//[c]Adds the type to the .debug_info section.
//[c]
function addDwarfType (dt: *DwarfType)

	var buffer = self debugInfo buffer

	var type = dt type
	switch type code
	case 'integer
		buffer writeByte (Abbrev : 'baseType)
		buffer writeByte (type size cast (Byte))	// size
		buffer writeByte (TypeKind : 'signed)	// kind
		buffer writeString8 (type asBuiltin name string)	// name

	case 'unsigned, 'boolean, 'size,
		'any, 'nil, 'void, 'composite
		buffer writeByte (Abbrev : 'baseType)
		buffer writeByte (type size cast (Byte))	// size
		buffer writeByte (TypeKind : 'unsigned)	// kind
		buffer writeString8 (type asBuiltin name string)	// name

	case 'pointer
		var target = type asPointer target
		// If target is an array: just skip.
		if target isArray
			target = target asArray cellType
		end
		buffer writeByte (Abbrev : 'pointerType)
		buffer writeByte (type size cast (Byte))	// size
		buffer writeDword (self getDwarfType (target))	// type
	
	case 'structure
		var s = type asStructure
		buffer writeByte (Abbrev : 'structureType)
		buffer writeString8 (s name string)	// name
		buffer writeDword (s size cast (Uinteger))	// size
		buffer writeDword (dt sibling toDword)	// sibling
		if s parentStructure notNil
			buffer writeByte (Abbrev : 'member)
			buffer writeString8 ("__parent")	// name
			buffer writeDword (self getDwarfType (s parentStructure))	// type
			buffer writeDword (0)	// offset
		end
		s eachAttribute do a
			buffer writeByte (Abbrev : 'member)
			buffer writeString8 (a name string)	// name
			buffer writeDword (self getDwarfType (a storageType))	// type
			buffer writeDword (a offset cast (Uint32))	// offset
		end
		buffer writeByte (0) // terminate 'structureType entry
		dt sibling = buffer pos
		
	case 'array
		var cell = type asArray cellType
		buffer writeByte (Abbrev : 'arrayType)
		buffer writeDword (type size cast (Uinteger))	// size
		buffer writeDword (self getDwarfType (cell))	// type
		
	case 'function
		var f = type asFunction
		buffer writeByte (Abbrev : 'subroutineType)
		buffer writeDword (dt sibling toDword)	// sibling
		f eachType do t
			buffer writeByte (Abbrev : 'parameterType)
			buffer writeDword (self getDwarfType (t))	// type
		end
		buffer writeByte (0) // terminate 'subroutineType entry
		dt sibling = buffer pos
	end

end
//[cf]
//[of]:emitLocation
function emitLocation (address: ObjectOffset, module: *Module, line: LineNumber)

	if not self debug
		return
	end
	
	var buffer = self debugline buffer

	if module <> self debugModule
		self debugModule = module
		buffer writeByte (LineNumberOps : 'set_file)
		buffer writeLEB32 (module generator cast (Size) cast (Uinteger))
	end
	
	var da = (address - self debugAddress) toInteger
	var dl = (line - self debugLineNumber) toInteger

	if da <> 0 or dl <> 0
		var opcode = (dl - dwarfLineBase) + (dwarfLineRange * da) + dwarfOpcodeBase
		if dl >= dwarfLineBase and dl < dwarfLineBase + dwarfLineRange and opcode < 256
			// Short opcode: use special extension
			buffer writeByte (opcode cast (Byte))
		else
			// Use longer instructions
			if dl <> 0
				buffer writeByte (LineNumberOps : 'advance_line)
				buffer writeSLEB32 (dl)
			end
			if da <> 0
				buffer writeByte (LineNumberOps : 'advance_pc)
				buffer writeLEB32 (da asUnsigned)
			end
			buffer writeByte (LineNumberOps : 'copy)
		end
		self debugAddress = address
		self debugLineNumber = line
	end

end
//[cf]

//[of]:writeFunctionName
static function writeFunctionName (buffer: *VirtualBuffer, f: *Function)
	if f context notNil
		writeTypeName (buffer, f context)
		buffer writeByte ($.)
	end
	addString (buffer, f name string)
	buffer writeByte (0)
end
//[cf]
//[of]:writeTypeName
static function writeTypeName (buffer: *VirtualBuffer, type: *Type) : 

	switch type code
	case 'array
		buffer writeByte( $[ )
		buffer writeByte( $] )
		writeTypeName (buffer, type asArray cellType)

	case 'pointer
		var pointer = type asPointer
		var target = pointer target
		if pointer name notNil
			addString (buffer, pointer name string)
		elsif target code == 'function
			writeTypeName (buffer, target asFunction)
		else
			//buffer writeByte ($*)
			writeTypeName (buffer, target)
		end
		
	case 'meta
		buffer writeByte( $@ )
		buffer writeByte( $( )
		writeTypeName (buffer, type asMeta type)
		buffer writeByte( $) )

	case 'structure
		var structure = type asStructure
		addString (buffer, structure name string)
		writeArguments (buffer, type)
		
	case 'any, 'nil, 'boolean, 'integer, 'unsigned, 'size, 'void, 'composite
		addString (buffer, type asBuiltin name string)
		writeArguments (buffer, type)
	end
	
end

static function writeArguments (buffer: *VirtualBuffer, type: *Type)

	if type hasArguments
		buffer writeByte( $( )
		var comma = false
		type eachArgument do a
			if comma
				buffer writeByte ($,)
			end
			comma = true
			writeExpression (buffer, a)
		end
		buffer writeByte( $) )
	end

end

static function writeExpression (buffer: *VirtualBuffer, e: *Expression) :

	switch e code
//[c]	case 'constantInteger
//[c]		e asConstantInteger
//[c]	case 'constantString8
//[c]		e asConstantString8
//[c]	case 'constantString16
//[c]		e asConstantString16
//[c]	case 'constantStructure
//[c]		e asConstantStructure
//[c]	case 'constantArray
//[c]		e asConstantArray
//[c]	case 'constantFunction
//[c]		e asConstantFunction
//[c]	case 'constantGlobal
//[c]		e asConstantGlobal
	case 'type
		writeTypeName (buffer, e asType type)
	else
		buffer writeByte( $? )
	end

end
//[cf]
//[of]:addString
static function addString (buffer: *VirtualBuffer, str: String8)
	buffer write (str, ObjectOffset fromSize (str size toByteSize))
end
//[cf]

//[of]:DwarfType
static struct DwarfType
	var nextSibling	: *DwarfType	// Next type to declare
	var type	: *Type	// The type
	var pos	: ObjectOffset	// The position of the type entry in the .debug_info section
	var sibling	: ObjectOffset	// The position of the next sibling if the type has children (structure)
end
//[cf]
//[of]:DwarfFunction
static struct DwarfFunction
	var func	: *Function
	var sibling	: ObjectOffset
	
	function initialize (f: *Function)
		self func = f
		self sibling = 0
	end

end
//[cf]
//[cf]
//[cf]
//[cf]
//[of]:	private
//[of]:Builtin
//[c]Builtin stores a builtin function. It is used only for the lookup builtin 
//[c]function for switch statements.
//[c]
static struct Builtin
	var name	: String8	// The name of the builtin. Unused.
	var data	: Bytes	// The bytes of the function
	var used	: Bool	// The function is used at least once
	
	// Assembler
	var symbol	: ObjectSymbol	// The symbol to the function
	var address	: ObjectOffset	// The address of the function
	var size	: ObjectOffset	// The size of the function

	function initialize (	object	: *ObjectFile,
		name	: String8,
		code	: Bytes, 
		size	: ObjectOffset)
	
		self name	= name
		self data	= code
		self used	= false
		self symbol	= 'undefined
		self address	= 'undefined
		self size	= size
	end

end
//[cf]
//[of]:PCodeGenerator
//[c]The function generator builds a PFunction from a Function.
//[c]
static struct PCodeGenerator

	var pool	: *MemoryPool	// The memory pool to store mc-instructions
	var lookupTables	: Collection (SwitchTable)	// Sparse switch tables
	var directTables	: Collection (SwitchTable)	// Dense switch tables
	var pfunction	: *PFunction	// The p-function to generate
	var module	: *Module	// The current module
	var line	: LineNumber	// The current line number
	var exitLabel	: *PLabel	// Return instructions jump to this label
	var inlineContext	: *InlineContext	// The current inline context
	var instructions	: *Collection (PInstruction)	// The current list of instruction to fill (if nil, we are starting a new list: a new one is created)
	var unwindItem	: *UnwindItem	// The top of the stacked unwind-items

	static const maxValues	= Size : 256
	static const oneValues	= *[4]*PValue : {oneValue8,	oneValue16,	oneValue32,	oneValue64}
	static const zeroValues	= *[4]*PValue : {zeroValue8,	zeroValue16,	zeroValue32,	zeroValue64}

//[of]:	initialize - release
//[of]:initialize
function initialize (pool: *MemoryPool)
	self pool = pool
	self lookupTables initialize
	self directTables initialize
end
//[cf]
//[cf]
//[of]:	generating
//[of]:generate
function generate (program: *Program, debug: Bool)

	// Assign a unique number for each module corresponding to
	// the file number in the .debug_line section
	var i = Size : 1
	program eachModule do m
		m generator = i cast (Pointer)
		i ++
	end
	
	program eachStructureConstant do c
		c generator = self newGlobal
	end
	program eachArrayConstant do c
		c generator = self newGlobal
	end
	program eachString8Constant do c
		c generator = self newGlobal
	end
	program eachString16Constant do c
		c generator = self newGlobal
	end
	program eachGlobalVariable do v
		v generator = self newGlobal
	end
	program eachExternFunction do f
		f generator = self newGlobal
	end
	program eachFunction do f
		f generator = self pool new (PFunction, f, debug)
	end
	// Assign p-value to each function reference. It must be done when all
	// functions have a p-function and all externs functions have a 
	// p-global-value.
	program eachFunctionConstant do c
		c generator = getFunctionReference (c)
	end

	// Generate p-code for each functions
	program eachFunction do f
		var pf = pfunction (f)
		self generateFunction (f, pf)
	end

end
//[cf]
//[cf]
//[of]:	private
//[of]:generating instructions
//[of]:generateFunction
function generateFunction (f: *Function, pf: *PFunction)

	// isMacro ?
	if pf ignore
		return
	end

	self pfunction	= pf
	self instructions	= pf instructions

	// Create a PVariable for each parameter of the function
	f eachParameter do p
		if not p type isMeta
			p generator = self newParameter (p name string, sizeCode (p type))
		end
	end

	// Reset the generator value for all composites of the function
	f prepareLocals
	
	// Create the exit label
	self exitLabel	= self newLabel
	
	// Set the initial location
	self module = f module
	self line = f line
	
	// Reset the inline context
	self inlineContext = nil
	
	// Reset the unwind stack pointer
	self unwindItem	= nil
	// Generate the main block
	self generateBlock (f body)
	
	// Add the exit label
	self emitLabel (self exitLabel)
	
end
//[cf]
//[of]:generateBlock
function generateBlock (block: *Block) :

	// Save the unwind pointer at the beginning of the block
	var startUnwind = self unwindItem
	
	block variables each do variable
		var storageType = variable storageType
		if storageType isSimple
			// Create the p-variable and attach it to the variable
			var size = sizeCode (storageType)
			var v = self newVariable (variable name string, size)
			v type = storageType
			variable generator = v
		else
			// Create a local on stack
			var local = self newLocal (Disp32 from (storageType size))
			// The code generator does not support direct evaluation of the 
			// local: we must store the address into a local variable
			// The local variable inherit the name and type of expression 
			// (the pointer) for debugging purpose. That's why we don't
			// use emitLoadAuto here.
			var t = self newVariable (variable name string, local size)
			t type = variable expression type
			self emitLoad (t, local)
			variable generator = t
		end
	end
	
	block instructions each do i
		self generateInstruction (i)
	end

	// Unwind
	if not block terminated
		self generateUnwindTo (startUnwind)
	end
	
	// Restore the unwind pointer
	self unwindItem = startUnwind
	
end
//[cf]
//[of]:generateInstruction
function generateInstruction (instruction: *Instruction)

	// Do not changes the line number if we are expanding
	// a function or an iterator call
	if self inlineContext isNil and instruction line <> 'none
		if self module <> instruction module
			self module = instruction module
			self emitModule (self module)
		end
		self line = instruction line
	end
	
	switch instruction code
	case 'evaluate
		self generateEvaluate (instruction asEvaluate)
	case 'variable
		self generateVariable (instruction asVariable)
	case 'assign
		self generateAssign (instruction asAssign)
	case 'if
		self generateIf (instruction asIf)
	case 'while
		self generateWhile (instruction asWhile)
	case 'break
		self generateBreak (instruction asBreak)
	case 'continue
		self generateContinue (instruction asBreak)
	case 'return
		self generateReturn (instruction asReturn)
	case 'leave
		self generateLeave (instruction asLeave)
	case 'switch
		self generateSwitch (instruction asSwitch)
	case 'block
		self generateBlock (instruction asBlock block)
	case 'defer
		self generateDefer (instruction asDefer)
	else
		assertFailure ("Generating unknown instruction")
	end

end
//[cf]
//[of]:generateEvaluate
function generateEvaluate (instruction: *EvaluateInstruction)

	instruction values each do e
		self generateExpression (e)
	end

end
//[cf]
//[of]:generateAssign
function generateAssign (instruction: *AssignInstruction)
	
	// All variables but the last must be copied to temporary values
	// because some lvalues may depends on previous assigned values.
	//	a1, a2, ..., an = v1, v2, ..., vn
	// becomes
	//	t1 = e1
	//	t2 = e2
	//	...
	//	an = en
	//	a1 = t1
	//	a2 = t2
	//
	var rvalues = instruction right
	var tvalues : [maxValues] *PValue
	var n = rvalues size - 1
	var i = Index : 0
	var iter = rvalues firstElement
	while i < n
		var e = iter object
 		tvalues [i] = self emitLoadAuto (self generateExpression (e))
		iter = iter nextSibling
		i ++
	end

	var lvalues = instruction left
	var rvalue = self generateExpression (rvalues last)
	var lvalue = self generateExpression (lvalues last)
	self emitAssign (lvalue, rvalue)

	i = 0
	iter = lvalues firstElement
	while i < n
		var e = iter object
		self emitAssign (self generateExpression (e), tvalues [i])
		iter = iter nextSibling
		i ++
	end

end
//[cf]
//[of]:generateVariable
function generateVariable (instruction: *VariableInstruction)

	var src = self generateExpression (instruction value)
	self emitAssign (pvalue (instruction variable), src)

end
//[cf]
//[of]:generateIf
function generateIf (instruction: *IfInstruction)
	
	// Pass 1 - Create the labels
	var lastLabel = PLabel nil
	instruction rules each do rule
		lastLabel	= self newLabel
		rule generator = lastLabel
	end
	if instruction elseBlock notNil
		lastLabel	= self newLabel
	end

	// Pass 2 - Generate code
	var needLastLabel = false
	instruction rules each do rule
		var condition	= rule condition
		var elseLabel	= plabel (rule)
		
		self line = rule line
		self generateJumpUnless (condition, elseLabel)
		
		// Generate the block
		self generateBlock (rule block)
			
		// Jump to the last block if the block is not terminated and
		// it is not the last block.
		if not rule block terminated and elseLabel <> lastLabel
			self emitJump (lastLabel)
			needLastLabel = true
		end

		// The current position is the label else of the rule
		self emitLabel (elseLabel)
	end

	if instruction elseBlock notNil
		self generateBlock (instruction elseBlock)
		if needLastLabel
			self emitLabel (lastLabel)
		end
	end

end
//[cf]
//[of]:generateWhile
function generateWhile (instruction: *WhileInstruction)

	var loopLabel	= self newLabel
	var exitLabel = self newLabel
	var continueLabel = instruction condition notNil cond self newLabel else loopLabel

	var info : PWhile
	info exitLabel = exitLabel
	info continueLabel = continueLabel
	info startUnwind = self unwindItem
	instruction generator = info
	
	if instruction condition notNil
		self emitJump (continueLabel)
		self emitLabel (loopLabel)
		self generateBlock (instruction block)
		self emitLabel (continueLabel)
		
		// Do not use the line of the test as COFF does not accept line
		// above the previous ones. Use the successor of the last line 
		// instead (it could the end or a blank line).
		//self line = instruction line
		self line ++	
		
		self generateJumpIf (instruction condition, loopLabel)
	else
		self emitLabel (loopLabel)
		self generateBlock (instruction block)
		self emitJump (loopLabel)
	end
	self emitLabel (exitLabel)

end
//[cf]
//[of]:generateBreak
function generateBreak (instruction: *BreakInstruction)

	var info = instruction instruction generator downcast (*PWhile)
	self generateUnwindTo (info startUnwind)
	self emitJump (info exitLabel)

end
//[cf]
//[of]:generateContinue
function generateContinue (instruction: *BreakInstruction)

	var info = instruction instruction generator downcast (*PWhile)
	self generateUnwindTo (info startUnwind)
	self emitJump (info continueLabel)

end
//[cf]
//[of]:generateReturn
function generateReturn (instruction: *ReturnInstruction)

	if self inlineContext notNil
		// Inline return
		var info = self inlineContext
		
		// Copy result to return values
		var i = Index : 0
		instruction expressions each do e
			var v = self generateExpression (e)
			if info singleReturn
				info returnValues [i] = v
			else
				self emitAssign (info returnValues [i], v)
			end
			i ++
		end
		
		// Unwind the stack up to the beginning of the function
		self generateUnwindTo (info startUnwind)
		
		if not info singleReturn
			self emitJump (info exitLabel)
		end
	
	else
		// Regular return
		
		// Evaluate all expressions first
		var values : [maxValues] *PValue
		var i = Index : 0
		instruction expressions each do e
			values [i] = self generateExpression (e)
			i ++
		end

		// Write values on stack for non-register return values
		var off = self pfunction argumentStackSize + 'sizeOfReturnAddress
		var n = i
		i = registerReturnCount
		while i < n
			var v = values [i]
			self emitAssign (self newBase (v size, off), v)
			off += v size toStackSize
			i ++
		end
			
		// Pass register values to the return statement
		var count = min (registerReturnCount, n)
		var returns = nil cast (*[]*PValue)
		if count > 0
			returns = self pool allocateArray (*PValue, count)
			var i = Index : 0
			while i < count
				var v = values [i]
				returns [i] = self forceRI (v)
				v setPreferred (registerReturns [i])
				i ++
			end
		end
		
		// Unwind the stack up to the beginning of the function
		self generateUnwindTo (nil)
		
		self emitReturn (count, returns)
	end

end
//[cf]
//[of]:generateLeave
function generateLeave (instruction: *LeaveInstruction)

	var block = instruction block
	var info = block generator downcast (*LeaveContext)

	// Copy result to return values
	var i = Index : 0
	instruction arguments each do e
		var v = self generateExpression (e)
		self emitAssign (info returnValues values [i], v)
		i ++
	end
	
	// Unwind the stack up to the beginning of the function
	self generateUnwindTo (info startUnwind)
	
	var exitLabel = info exitLabel
	if exitLabel isNil
		exitLabel = self newLabel
		info exitLabel = exitLabel
	end
	self emitJump (exitLabel)
	
end
	
//[cf]
//[of]:generateSwitch
function generateSwitch (instruction: *SwitchInstruction)

	// Evaluate the value
	var v = self generateExpression (instruction value)
	
	// Create the exit label if required
	var exitLabel = PLabel nil
	var defaultLabel = PLabel nil
	if not instruction terminated
		exitLabel = self newLabel
		defaultLabel = exitLabel
	end
	
	// Create a label for each case
	var caseCount = Uinteger : 0
	instruction eachChoice do choice
		var label = self newLabel
		choice generator = label
		caseCount += choice values size asUnsigned
	end
	if instruction elseBlock notNil
		defaultLabel = self newLabel
	end
	
	// Create the switch table
	var table = self newSwitchTable (caseCount, defaultLabel)
	var i = Index : 0
	instruction eachChoice do choice
		choice values each do e
			var constant = e asConstantInteger value asSigned
			table setCase (i, constant, plabel (choice))
			i ++
		end
	end

//[c]
//[c]	Create the switch instructions
//[c]
	// Compute density
	var range = (table high - table low + 1) asUnsigned
	
	if (table size * 2) cast (Uint64) >= range
	
		// The values are compact: use a direct table
		self directTables add (table)

		// Extend to 32 bits
		var tmp = self getResize (v, instruction value type, 'qword)

		// Sub min
		if table low <> 0
			var constant = self newInteger64 ('qword, table low asUnsigned)
			tmp = self buildSub (tmp, constant)
		end
		
		// The value must be a register because it is used as an index
		tmp = self forceR (tmp)
		
		// Compare to high - low (unsigned!)
		var cc = self emitCmp ('a, tmp, self newInteger64 ('qword, (table high - table low) asUnsigned))
			
		// Jump to default if above
		self emitJumpC (cc, defaultLabel)
		
		// Jump to table
		var table	= self emitLoadAuto (table value)
		var index	= self newIndex3 (table, tmp, 8, 0)
		var memory	= self newMemory ('qword, index)
		self emitJumpi (memory)
		
	else
		// The values are sparse: use a lookup table
		self lookupTables add (table)

		// Extend to 64 bits
		var v64 = self getResize (v, instruction value type, 'qword)
		v64 setPreferred ('rax)

		self emitLookup (v64, table value)
	end
	
//[c]	
//[c]	Build the blocks
//[c]	
	instruction eachChoice do choice
		var block = choice block
		var label = plabel (choice)
		
		self emitLabel (label)
		self generateBlock (block)
			
		// Jump to the last block if the block is not terminated
		if not block terminated
			self emitJump (exitLabel)
		end
	end
	if instruction elseBlock notNil
		self emitLabel (defaultLabel)
		self generateBlock (instruction elseBlock)
	end
	
	if not instruction terminated
		self emitLabel (exitLabel)
	end

end
//[cf]
//[of]:generateDefer
function generateDefer (i: *DeferInstruction)

	// Push an unwind-item
	var item = self pool allocate (UnwindItem)
	item next = self unwindItem
	item block = i block
	self unwindItem = item

end
//[cf]

//[of]:generateJumpIf
function generateJumpIf (c: *Expression, label: *PLabel) :

	switch c code
	case 'booleanNot
		self generateJumpUnless (c asUnary argument, label)
	case 'minimalAnd
		var b = c asBinary
		var elseLabel = self newLabel
		self generateJumpUnless (b argument1, elseLabel)
		self generateJumpIf (b argument2, label)
		self emitLabel (elseLabel)
	case 'minimalOr
		var b = c asBinary
		self generateJumpIf (b argument1, label)
		self generateJumpIf (b argument2, label)
	else
		var cc = self generateCondition (c)
		self emitJumpC (cc, label)
	end

end
//[cf]
//[of]:generateJumpUnless
function generateJumpUnless (c: *Expression, label: *PLabel) :

	switch c code
	case 'booleanNot
		self generateJumpIf (c asUnary argument, label)
	case 'minimalAnd
		var b = c asBinary
		self generateJumpUnless (b argument1, label)
		self generateJumpUnless (b argument2, label)
	case 'minimalOr
		var b = c asBinary
		var elseLabel = self newLabel
		self generateJumpIf (b argument1, elseLabel)
		self generateJumpUnless (b argument2, label)
		self emitLabel (elseLabel)
	else
		var cc = self generateCondition (c)
		self emitJumpC (cc invert, label)
	end

end
//[cf]
//[of]:generateUnwindTo
//[c]Emits the code to unwind up to the given item
//[c]
function generateUnwindTo (limit: *UnwindItem)

	var u = self unwindItem
	while u <> limit
		self generateUnwind (u)
		u = u next
	end

end
//[cf]
//[of]:generateUnwind
//[c]Emits the code to unwind the given item
//[c]
function generateUnwind (item: *UnwindItem)
	self generateBlock (item block)
end
//[cf]
//[cf]
//[of]:generating expressions
//[of]:generateExpression
function generateExpression (e: *Expression) : *PValue

	switch e code
//[of]:	select
	case 'select

		var select = e asSelect
		var c = select argument
		var pc = pcomposite (c)
		if pc isNil
			// Not generated yet, first access to this composite: generate now
			pc = self generateExpression (c) asComposite
			c generator = pc
		end
		return pc [select index]
//[cf]
//[of]:	constants
	case 'constantInteger
		return self newInteger64 (sizeCode (e type), e asConstantInteger value)
	
	case 'constantString8
		return pvalue (e)

	case 'constantString16
		return pvalue (e)

	case 'constantStructure
		return pvalue (e)
		
	case 'constantArray
		return pvalue (e)
		
	case 'constantGlobal
		return pvalue (e asConstantGlobal variable)

	case 'constantFunction
		return pvalue (e)
//[cf]
//[of]:	minimal and
	case 'minimalAnd
	
		var pair	= e asBinary
		var label	= self newLabel
		var t	= self newVariable (nil, 'byte)
		
		self emitLoad (t, self generateExpression (pair argument1))
		self emitTest (t, t)
		self emitJumpC ('z, label)
		self emitLoad (t, self generateExpression (pair argument2))
		self emitLabel (label)
		
		return t
//[cf]
//[of]:	minimal or
	case 'minimalOr
	
		var pair	= e asBinary
		var label	= self newLabel
		var t	= self newVariable (nil, 'byte)
		
		self emitLoad (t, self generateExpression (pair argument1))
		self emitTest (t, t)
		self emitJumpC ('nz, label)
		self emitLoad (t, self generateExpression (pair argument2))
		self emitLabel (label)
		
		return t
//[cf]
//[of]:	cond
	case 'cond
	
		var c	= e asCond
		var elseLabel	= self newLabel
		var commonLabel	= self newLabel

		self generateJumpUnless (c condition, elseLabel)

		// Assign first values to temporaries
		var t : [maxValues] *PValue
		var i = Index : 0
		c argument1 each do e
			t [i] = self emitLoadAuto (self generateExpression (e))
			i ++
		end

		self emitJump (commonLabel)
		self emitLabel (elseLabel)
		
		// Assign second values to temporaries
		i = 0
		c argument2 each do e
			self emitAssign (t [i], self generateExpression (e))
			i ++
		end

		self emitLabel (commonLabel)
		return self singleton (t, i)
//[cf]
//[of]:	function call
	case 'functionCall
	
		var call	= e asFunctionCall	
		var f	= call func
		var pf	= pfunction (f)
		
		if pf inline and not pf inlining
		
			// The function is inlinable: let's inline it instead of calling it
			pf inlining = true
			var value = self generateInlineCall (call)
			pf inlining = false
			return value

		else
			// Mark the function as called (the body must be generated)
			pf called = true
			
			return self generateCall (pf, call arguments, f returnTypes)
		end
//[cf]
//[of]:	extern function call
	case 'externFunctionCall

		var call	= e asExternFunctionCall
		var f	= call func
		var address	= pvalue (f)
		
		return self generateCall (address, call arguments, f returnTypes)
//[cf]
//[of]:	pointer call
	case 'pointerCall

		var call	= e asPointerCall
		var pointerType	= call func type asPointer
		var functionType	= pointerType target asFunction
		var returnTypes	= functionType returnTypes
		var address	= self generateExpression (call func)
		
		return self generateCall (address, call arguments, returnTypes)
//[cf]
//[of]:	function parameter
	case 'functionParameter
		var parameter = e asParameter parameter
		return pvariable (parameter)
//[cf]
//[of]:	local variable
	case 'localVariable
		return pvalue (e asLocalVariable variable)
//[cf]
//[of]:	global variable
	case 'globalVariable
		var v = e asGlobalVariable variable
		var size = sizeCode (v storageType)
		return self newMemory (size, pvalue (v))
//[cf]
//[of]:	attribute
	case 'attribute
	
		var ae	= e asAttribute
		var attribute	= ae attribute
		var type	= attribute storageType
		var offset	= Disp32 : 0
		var addr	: *Expression
		
		// Merge all offsets of nested structures
		repeat
			offset += Disp32 from (attribute offset)
			addr	= ae argument
			if addr code <> 'attribute
				break
			end
			ae = addr asAttribute
			attribute = ae attribute
			if attribute storageType isSimple
				break
			end
		end

		// Compute the effective address 
		var base	= self generateExpression (addr)
		var value	= self buildIndex (base, offset)
		
		if type isSimple
			value = self buildMemory (sizeCode (type), value)
		end

		return value
//[cf]
//[of]:	each extra
	case 'vargsEach
		self generateBlock (e asVargsEach block)
		return nil
//[cf]
//[of]:	cast
	case 'cast

		var c	= e asUnary
		var newType	= c type
		var oldType	= c argument type
		var arg	= self generateExpression (c argument)
		
		if arg isInteger
			var size = sizeCode (newType)
			return self newInteger64 (size, arg asInteger qword)
		elsif oldType isInteger and newType isInteger
			var size = sizeCode (newType)
			return self getResize (arg, oldType, size)
		else
			return arg
		end
//[cf]
//[of]:	macro call
	case 'macroCall

		var call = e asMacroCall

		// Create variables
		var n = call types size
		var composite = PCompositeValue nil
		if n <> 0
			composite = self newComposite (n)
			n each do i
				var size = sizeCode (call types [i])
				composite values [i] = self newVariable (nil, size)
			end
		end
		
		// Create a context with information and assign it to the block of the macro
		var info : LeaveContext
		info exitLabel = nil // exit label created on the first leave
		info startUnwind = self unwindItem
		info returnValues = composite
		call block generator = info
		
		// Generate the block
		self generateBlock (call block)
		
		// Insert the label
		if info exitLabel notNil
			self emitLabel (info exitLabel)
		end
		
		return n == 1 cond composite values [0] else composite
//[cf]
//[of]:	super
	case 'super
		var argument = e asUnary argument
		return self generateExpression (argument)
//[cf]

//[of]:	integer add
	case 'integerAdd
		return self buildAdd (self generatePair (e asBinary))
//[cf]
//[of]:	integer sub
	case 'integerSub
		return self buildSub (self generatePair (e asBinary))
//[cf]
//[of]:	integer smul
	case 'integerSmul
		return self buildMul (self generatePair (e asBinary))
//[cf]
//[of]:	integer umul
	case 'integerUmul
		return self buildMul (self generatePair (e asBinary))
//[cf]
//[of]:	integer sdiv
	case 'integerSdiv
		return self buildSdiv (self generatePair (e asBinary))
//[cf]
//[of]:	integer udiv
	case 'integerUdiv
		var v1, v2	= self generatePair (e asBinary)
		var t	= self newVariable (nil, v1 size)
		self emitUdiv (t, v1, v2)
		return t
//[cf]
//[of]:	integer smod
	case 'integerSmod
		var v1, v2	= self generatePair (e asBinary)
		var t	= self newVariable (nil, v1 size)
		self emitSmod (t, v1, v2)
		return t
//[cf]
//[of]:	integer umod
	case 'integerUmod
		var v1, v2	= self generatePair (e asBinary)
		var t	= self newVariable (nil, v1 size)
		self emitUmod (t, v1, v2)
		return t
//[cf]
//[of]:	integer shl
	case 'integerShl
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitShl (t, v2)
		return t
//[cf]
//[of]:	integer sshr
	case 'integerSshr
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitSshr (t, v2)
		return t
//[cf]
//[of]:	integer ushr
	case 'integerUshr
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitUshr (t, v2)
		return t
//[cf]
//[of]:	integer and
	case 'integerAnd
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitAnd (t, v2)
		return t
//[cf]
//[of]:	integer or
	case 'integerOr
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitOr (t, v2)
		return t
//[cf]
//[of]:	integer xor
	case 'integerXor
		var v1, v2	= self generatePair (e asBinary)
		var t	= self emitLoadAuto (v1)
		self emitXor (t, v2)
		return t
//[cf]

//[of]:	integer not
	case 'integerNot
		var v	= self generateExpression (e asUnary argument)
		var t	= self emitLoadAuto (v)
		self emitNot (t)
		return t
//[cf]
//[of]:	integer pos
	case 'integerPos
		return self generateExpression (e asUnary argument)
//[cf]
//[of]:	integer neg
	case 'integerNeg
		var v	= self generateExpression (e asUnary argument)
		var t	= self emitLoadAuto (v)
		self emitNeg (t)
		return t
//[cf]

//[of]:	integer assign add
	case 'integerAssignAdd
		self emitAdd (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign sub
	case 'integerAssignSub
		self emitSub (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign smul
	case 'integerAssignSmul
		var v1, v2 = self generatePair (e asBinary)
		self emitSmul (v1, v2)
		return nil
//[cf]
//[of]:	integer assign umul
	case 'integerAssignUmul
		var v1, v2 = self generatePair (e asBinary)
		self emitUmul (v1, v1, v2)
		return nil
//[cf]
//[of]:	integer assign sdiv
	case 'integerAssignSdiv
		var v1, v2 = self generatePair (e asBinary)
		self emitSdiv (v1, v1, v2)
		return nil
//[cf]
//[of]:	integer assign udiv
	case 'integerAssignUdiv
		var v1, v2 = self generatePair (e asBinary)
		self emitUdiv (v1, v1, v2)
		return nil
//[cf]
//[of]:	integer assign smod
	case 'integerAssignSmod
		var v1, v2 = self generatePair (e asBinary)
		self emitSmod (v1, v1, v2)
		return nil
//[cf]
//[of]:	integer assign umod
	case 'integerAssignUmod
		var v1, v2 = self generatePair (e asBinary)
		self emitUmod (v1, v1, v2)
		return nil
//[cf]
//[of]:	integer assign shl
	case 'integerAssignShl
		self emitShl (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign sshr
	case 'integerAssignSshr
		self emitSshr (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign ushr
	case 'integerAssignUshr
		self emitUshr (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign and
	case 'integerAssignAnd
		self emitAnd (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign or
	case 'integerAssignOr
		self emitOr (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign xor
	case 'integerAssignXor
		self emitXor (self generatePair (e asBinary))
		return nil
//[cf]
//[of]:	integer assign inc
	case 'integerAssignInc
		var v1 = self generateExpression (e asUnary argument)
		var v2 = oneValues [v1 size]
		self emitAdd (v1, v2)
		return nil
//[cf]
//[of]:	integer assign dec
	case 'integerAssignDec
		var v1 = self generateExpression (e asUnary argument)
		var v2 = oneValues [v1 size]
		self emitSub (v1, v2)
		return nil
//[cf]

//[of]:	integer eq
	case 'integerEq
		return self generateCompare ('z, e asBinary)
//[cf]
//[of]:	integer ne
	case 'integerNe
		return self generateCompare ('nz, e asBinary)
//[cf]
//[of]:	integer sle
	case 'integerSle
		return self generateCompare ('le, e asBinary)
//[cf]
//[of]:	integer ule
	case 'integerUle
		return self generateCompare ('be, e asBinary)
//[cf]
//[of]:	integer slt
	case 'integerSlt
		return self generateCompare ('lt, e asBinary)
//[cf]
//[of]:	integer ult
	case 'integerUlt
		return self generateCompare ('b, e asBinary)
//[cf]
//[of]:	integer sge
	case 'integerSge
		return self generateCompare ('ge, e asBinary)
//[cf]
//[of]:	integer uge
	case 'integerUge
		return self generateCompare ('ae, e asBinary)
//[cf]
//[of]:	integer sgt
	case 'integerSgt
		return self generateCompare ('gt, e asBinary)
//[cf]
//[of]:	integer ugt
	case 'integerUgt
		return self generateCompare ('a, e asBinary)
//[cf]

//[of]:	boolean not
	case 'booleanNot
		var v1 = self generateExpression (e asUnary argument)
		var t	= self emitLoadAuto (v1)
		self emitXor (t, oneValue8)
		return t
//[cf]
//[of]:	pointer deference
	case 'pointerDereference
		var argument = e asUnary argument
		var value = self generateExpression (argument)
		var type = argument type asPointer target
		var size = sizeCode (type)
		return self buildMemory (size, value)
//[cf]

//[of]:	array index
	case 'arrayIndex

		var b	= e asBinary
		var cellType	= self cellType (b)
		var index	= self generateExpression (b argument2)
		var offset	= self getScaled (b, index)
		var base	= self forceRI (self generateExpression (b argument1))
		var value	= self buildAdd (base, offset)
		
		// Simple type: load the value at given address
		// Complex type: just compute the address
		if cellType isSimple
			var size = sizeCode (cellType)
			return self newMemory (size, value)
		end
		return value
//[cf]
//[of]:	array add
	case 'arrayAdd

		var b	= e asBinary
		var cellType	= self cellType (b)
		var index	= self generateExpression (b argument2)
		var offset	= self getScaled (b, index)
		var base	= self forceRI (self generateExpression (b argument1))
		var value	= self buildAdd (base, offset)

		return value
//[cf]
//[of]:	array sub
	case 'arraySub
	
		var b	= e asBinary
		var cellType	= self cellType (b)
		var index	= self generateExpression (b argument2)
		var offset	= self getScaled (b, index)
		var base	= self forceRI (self generateExpression (b argument1))
		var value	= self buildSub (base, offset)
	
		return value
//[cf]
//[of]:	array distance
	case 'arrayDistance

		var b	= e asBinary
		var cellType	= self cellType (b)
		var dst	= self generateExpression (b argument1)
		var src	= self generateExpression (b argument2)
		var diff	= self buildSub (dst, src)
		var value	= self buildSdiv (diff, self newInteger ('dword, sizeToUnsigned(cellType size)))

		return value
//[cf]
//[of]:	array assign add
	case 'arrayAssignAdd
	
		var b	= e asBinary
		var index	= self generateExpression (b argument2)
		var offset	= self getScaled (b, index)
		var base	= self generateExpression (b argument1)
		
		self emitAdd (base, offset)
		return nil
//[cf]
//[of]:	array assign sub
	case 'arrayAssignSub

		var b	= e asBinary
		var index	= self generateExpression (b argument2)
		var offset	= self getScaled (b, index)
		var base	= self generateExpression (b argument1)
		
		self emitSub (base, offset)
		return nil
//[cf]
//[of]:	array assign inc
	case 'arrayAssignInc

		var b	= e asBinary
		var cellType	= self cellType (b)
		var base	= self generateExpression (b argument1)
		var offset	= self newInteger64 ('qword, sizeToUnsigned64 (cellType size))
		
		self emitAdd (base, offset)
		return nil
//[cf]
//[of]:	array assign dec
	case 'arrayAssignDec

		var b	= e asBinary
		var cellType	= self cellType (b)
		var base	= self generateExpression (b argument1)
		var offset	= self newInteger64 ('qword, sizeToUnsigned64 (cellType size))
		
		self emitSub (base, offset)
		return nil
//[cf]
	else
		assertFailure ("Unhandled expression")
		return nil
	end

end
//[cf]
//[of]:generateCompare
//[c]Generates a comparison and returns a boolean value
//[c]
function generateCompare (code: ConditionFlags, b: *BinaryExpression)
	return self newComparison (self generatePair (b), code)
end
//[cf]
//[of]:generateCondition
function generateCondition (c: *Expression)

	var v = self generateExpression (c)
	if v isC
		var c = v asComparison
		return self emitCmp (c flags, c value1, c value2)
	else
		return self emitCmp ('nz, v, zeroValues [v size])
	end

end
//[cf]
//[of]:generatePair
//[c]Generates a pair of expressions
//[c]
function generatePair (b: *BinaryExpression)
	var v1 = self generateExpression (b argument1)
	var v2 = self generateExpression (b argument2)
	return v1, v2
end
//[cf]

//[of]:generateCall
function generateCall (	address	: *PValue,
	arguments	: *ExpressionList,
	returnTypes	: *TypeSequence	)

	// callStackSize counts the bytes needed for this call to store arguments
	// and return values. It is also holds the current offset for arguments or 
	// return values.
	var callStackSize = Disp32 : 0

	// All return values
	var returnValues : [maxValues] *PValue
	
//[c]
//[c]	Create a list of arguments
//[c]

	// Evaluate all expressions first (function calls cannot be nested)
	var values : [maxValues] *PValue
	var i = Index : 0
	arguments eachWithoutType do e
		values [i] = self generateExpression (e)
		i ++
	end

	// Store all non-register arguments on stack
	var n = i
	i = registerArgumentCount
	while i < n
		var s = values [i]
		var d = PMemoryValue new (self pool, s size, PIndexValue new2 (self pool, rspValue, callStackSize))
		self emitAssign (d, s)
		callStackSize += s size toStackSize
		i ++
	end

	// Pass all register arguments	to the call
	var argCount = min (n, registerArgumentCount)
	var args = nil cast (*[]*PValue)
	if argCount > 0
		// Create the argument array
		args = self pool allocateArray (*PValue, argCount)
		
		// Evaluate arguments
		var i = Index : 0
		while i < argCount
			var v = self forceRI (values [i])
			args [i] = v
			// Assign the preferred register to the variable (if it is a variable)
			v setPreferred (registerArguments [i])
			i ++
		end
	end

//[c]
//[c]	Create the list of register return variables
//[c]
	var retCount = min (registerReturnCount, returnTypes size)
	var rets = nil cast (*[]*PValue)
	if retCount > 0
		// Create the return value array
		rets = self pool allocateArray (*PValue, retCount)
		
		// Create the variables
		var i = Index : 0
		while i < retCount
			var type = returnTypes [i]
			var size = sizeCode (type)
			var v = self newVariable (nil, size)
			v preferred = registerReturns [i]
			rets [i] = v
			returnValues [i] = v
			i ++
		end
	end
	
//[c]
//[c]	Call the function
//[c]
	self emitCall (address, argCount, args, retCount, rets)

//[c]
//[c]	Store non-register return variables
//[c]
	if returnTypes size > registerReturnCount
		var i = registerReturnCount
		var n = returnTypes size
		while i < n
			var type = returnTypes [i]
			var size = sizeCode (type)
			var d = self newVariable (nil, size)
			var s = PMemoryValue new (self pool, size, PIndexValue new2 (self pool, rspValue, callStackSize))
			self emitAssign (d, s)
			returnValues [i] = d
			callStackSize += size toStackSize
			i ++
		end
	end
	
//[c]
//[c]	Terminate
//[c]
	// Update the call stack size of the function
	var pf = self pfunction
	pf callStackSize = max (pf callStackSize, callStackSize)
	
	return self singleton (returnValues, returnTypes size)

end
//[cf]
//[of]:generateInlineCall
function generateInlineCall (call: *FunctionCallExpression)

	var returnValues : [maxValues] *PValue
	var f = call func
	var arguments = call arguments

	// Reset the generator value for all composites of the function
	f prepareLocals
	
	var info	: InlineContext
	info next	= self inlineContext
	info startUnwind = self unwindItem
	self inlineContext = info

	// Assign values to arguments
	zip (f parameters, arguments) do p, e
		if not p type isMeta
			var v = self generateExpression (e)
			// An immutable expression does not required to be copied into
			// a variable. A local variable cannot be considered immutable 
			// here as it can be modified in a block closure.
			if not e isConstant and not e isParameter
				v = self emitLoadAuto (v)
			end
			p generator = v
		end
	end
	
	var singleReturn	= f returnCount < 2
	
	// Create the return values
	if not singleReturn
		var i = Index : 0
		f returnTypes each do type
			var size = sizeCode (type)
			returnValues [i] = self newVariable (nil, size)
			i ++
		end
	end
	info returnValues	= returnValues
	info singleReturn	= singleReturn

	// The exit label is required only when there are multiple returns
	if singleReturn
		self generateBlock (f body)
	else
		var exitLabel = self newLabel
		info exitLabel	= exitLabel
		self generateBlock (f body)
		self emitLabel (exitLabel)
	end

	self inlineContext = info next
	
	// Retrieve the return values
	return self singleton (returnValues, f returnTypes size)

end
//[cf]
//[cf]
//[of]:creating instructions
//[of]:emitAssign
function emitAssign (	dst	: *PValue, 
	src	: *PValue )

	if src == dst
		// empty
	elsif src isI32 or src isR
		self emitStore (dst, src)
	elsif dst isR
		self emitLoad (dst, src)
	else
		var t = self emitLoadAuto (src)
		self emitStore (dst, t)
	end

end
//[cf]
//[of]:emitTruncate
function emitTruncate (value1: *PValue, value2: *PValue) :

	if value1 size == value2 size
		self emitAssign (value1, value2)
		return
	end
	
	var v1 = self forceR (value1)
	var v2 = self forceRM (value2)
	self emitBinary ('truncate, v1, v2)

end
//[cf]
//[of]:emitSext
function emitSext (value1: *PValue, value2: *PValue) :

	if value1 size == value2 size
		self emitAssign (value1, value2)
		return
	end
	
	var v1 = self forceR (value1)
	var v2 = self forceRM (value2)
	self emitBinary ('movsx, v1, v2)

end
//[cf]
//[of]:emitZext
function emitZext (value1: *PValue, value2: *PValue) :

	if value1 size == value2 size
		self emitAssign (value1, value2)
		return
	end
	
	var v1 = self forceR (value1)
	var v2 = self forceRM (value2)
	self emitBinary ('movzx, v1, v2)

end
//[cf]
//[of]:emitAdd
function emitAdd (v1: *PValue, v2: *PValue)
	self emitAddSub ('add, v1, v2)
end
//[cf]
//[of]:emitSub
function emitSub (v1: *PValue, v2: *PValue)
	self emitAddSub ('sub, v1, v2)
end
//[cf]
//[of]:emitSmul
function emitSmul (v1: *PValue, v2: *PValue)

	var size = v1 size

	if v2 isInteger
		var imm = v2 asInteger dword
		
		// Multiply by one
		if imm == 1
			return
		end
		
		// Multiply by power of two
		var pow = self shift (imm)
		if pow <> 0
			self emitShl (v1, self newInteger ('byte, pow))
			return
		end
	end
	
	// Byte size requires the use of the accumulator
	if size == 'byte
		var b = self forceRM (v2)
		self emitBinary ('smul, v1, b)
		return
	end

	var u = self forceRMI (v2)
	if v1 isR
		if v2 isI32
			self emitTernary ('smul3, v1, v1, v2)
		else
			self emitBinary ('smul2, v1, self forceRM (v2))
		end
	else
		var t = self emitLoadAuto (v1)
		if v2 isI32
			self emitTernary ('smul3, t, t, v2)
		else
			self emitBinary ('smul2, t, self forceRM (v2))
		end
		self emitStore (v1, t)
	end

end
//[cf]
//[of]:emitUmul
function emitUmul (t: *PValue, v1: *PValue, v2: *PValue)
	self emitScale ('umul, t, v1, v2)
end
//[cf]
//[of]:emitSdiv
function emitSdiv (t: *PValue, v1: *PValue, v2: *PValue)
	self emitScale ('sdiv, t, v1, v2)
end
//[cf]
//[of]:emitUdiv
function emitUdiv (t: *PValue, v1: *PValue, v2: *PValue)
	self emitScale ('udiv, t, v1, v2)
end
//[cf]
//[of]:emitSmod
function emitSmod (t: *PValue, v1: *PValue, v2: *PValue)
	self emitModulo ('smod, t, v1, v2)
end
//[cf]
//[of]:emitUmod
function emitUmod (t: *PValue, v1: *PValue, v2: *PValue)
	self emitModulo ('umod, t, v1, v2)
end
//[cf]
//[of]:emitShl
function emitShl (v1: *PValue, v2: *PValue)
	self emitShift ('shl, v1, v2)
end
//[cf]
//[of]:emitSshr
function emitSshr (v1: *PValue, v2: *PValue)
	self emitShift ('sshr, v1, v2)
end
//[cf]
//[of]:emitUshr
function emitUshr (v1: *PValue, v2: *PValue)
	self emitShift ('ushr, v1, v2)
end
//[cf]
//[of]:emitAnd
function emitAnd (v1: *PValue, v2: *PValue)
	self emitLogical ('and, v1, v2)
end
//[cf]
//[of]:emitOr
function emitOr (v1: *PValue, v2: *PValue)
	self emitLogical ('or, v1, v2)
end
//[cf]
//[of]:emitXor
function emitXor (v1: *PValue, v2: *PValue)
	self emitLogical ('xor, v1, v2)
end
//[cf]
//[of]:emitNot
function emitNot (v: *PValue)
	self emitUnary ('not, self forceRM (v))
end
//[cf]
//[of]:emitNeg
function emitNeg (v: *PValue)
	self emitUnary ('neg, self forceRM (v))
end
//[cf]
//[of]:emitCmp
//[c]Emit a comparison instruction to setup the flags
//[c]
//[c]PARAMETERS
//[c]	code	--	the kind of comparison
//[c]	v1	--	the first value
//[c]	v2	--	the second value
//[c]
//[c]RETURN VALUES
//[c]	The condition flags to check the result of the comparison
//[c]
function emitCmp (code: ConditionFlags, v1: *PValue, v2: *PValue)

	var left = v1
	var right = v2
	var swapped = false
	
	if left isI32
		left, right = right, left
		swapped = true
	end
	left = self forceRM (left)
	right = self forceRMI (right)

	// Comparing a register to zero can be optimized
	if left isR and right isInteger and right asInteger isZero and (code == 'z or code == 'nz)
		self emitTest (left, left)
	else
		if left isM and right isM
			right = self emitLoadAuto (right)
		end
		self emitBinary ('cmp, left, right)
	end
	return swapped cond code swap else code

end
//[cf]
//[of]:emitTest
function emitTest (v1: *PValue, v2: *PValue)

	var left = self forceRM (v1)
	var right = self forceRI (v2)
	self emitBinary ('test, left, right)

end
//[cf]

//[of]:emitAddSub
//[c]Emit add/sub 8/16/32/64
//[c]
function emitAddSub (code: PInstructionCode, v1: *PValue, v2: *PValue)

	if v1 isM and v2 isM
		self emitBinary (code, v1, self emitLoadAuto (v2))
	elsif v1 isR and v2 isX and v2 asIndex scale == 1
		self emitBinary (code, v1, v2 asIndex base)
		if v2 asIndex index notNil
			self emitBinary (code, v1, v2 asIndex index)
		end
		if v2 asIndex offset <> 0
			// Extend the offset to 64 bit with signed
			var n = v2 asIndex offset cast (Uint64)
			self emitBinary (code, v1, self newInteger64 ('qword, n))
		end
	else
		self emitBinary (code, v1, self forceRMI (v2))
	end

end
//[cf]
//[of]:emitLogical
//[c]Emit and/or/xor 8/16/32/64
//[c]
function emitLogical (code: PInstructionCode, v1: *PValue, v2: *PValue)
	
	if v1 isM and v2 isM
		self emitBinary (code, v1, self emitLoadAuto (v2))
	else
		self emitBinary (code, v1, self forceRMI (v2))
	end

end
//[cf]
//[of]:emitScale
function emitScale (table: *ScaleTable, t: *PValue, v1: *PValue, v2: *PValue)

	var size = t size

	if v2 isInteger
		var imm = v2 asInteger dword
		
		// Multiply/Divide by one
		if imm == 1
			self emitLoad (t, v1)
			return
		end
		
		// Multiply/Divide by power of two
		var pow = self shift (imm)
		if pow <> 0
			self emitLoad (t, v1)
			self emitShift (table shift, t, self newInteger ('byte, pow))
			return
		end
	end

	self emitAssign (t, v1)
	self emitBinary (table op, t, self forceRM (v2))

end
//[cf]
//[of]:emitModulo
function emitModulo (table: *ModuloTable, t: *PValue, v1: *PValue, v2: *PValue)

	var size = t size

	if v2 isInteger
		var imm = v2 asInteger dword
		
		// Multiply/Divide by power of two
		var pow = self shift (imm)
		if pow <> 0
			self emitLoad (t, v1)
			self emitAnd (t, self newInteger (size, imm - 1))
			return
		end
	end

	self emitAssign (t, v1)
	self emitBinary (table op, t, self forceRM (v2))

end
//[cf]
//[of]:emitShift
function emitShift (	table	: *ShiftTable, 
	v1	: *PValue, 
	v2	: *PValue )

	if v2 isInteger
		var i = self emitInstruction (PShiftInstruction)
		i code	= table imm
		i value1	= v1
		i shift	= v2 asInteger byte
	else
		self emitBinary (table cl, v1, self forceRM (v2))
	end

end
//[cf]

//[of]:emitSet
function emitSet (c: ConditionFlags, v: *PValue)

	var instr = self emitInstruction (PSetInstruction)
	instr code	= 'set
	instr condition	= c
	instr value1	= self forceRM (v)

end
//[cf]
//[of]:emitLoadAuto
//[c]load r, rmix
//[c]
function emitLoadAuto (src: *PValue)

	var t = self newVariable (nil, src size)
	self emitLoad (t, src)
	return t

end
//[cf]
//[of]:emitLoad
//[c]load r, rmix
//[c]
function emitLoad (dst: *PValue, src: *PValue) :

	if dst == src
		return
	end

	if src code == 'comparison
		var v = src asComparison
		var cc = self emitCmp (v flags, v value1, v value2)
		self emitSet (cc, dst)
		return
	end
	
	var instr = self emitInstruction (PBinaryInstruction)
	instr code	= 'load
	instr value1	= dst
	instr value2	= src

end
//[cf]
//[of]:emitStore
//[c]store rm, ri
//[c]
function emitStore (dst: *PValue, src: *PValue)

	var instr = self emitInstruction (PBinaryInstruction)
	instr code	= 'store
	instr value1	= dst
	instr value2	= src

end
//[cf]
//[of]:emitLookup
function emitLookup (value: *PValue, table: *PValue)

	var instr = self emitInstruction (PBinaryInstruction)
	instr code	= 'lookup
	instr value1	= value
	instr value2	= table

end
//[cf]
//[of]:emitCall
function emitCall (	address	: *PValue,
	argumentCount	: Integer,
	argumentValues	: *[]*PValue,
	returnCount	: Integer,
	returnValues	: *[]*PValue)

	var instr = self emitInstruction (PCallInstruction)
	instr code	= 'call
	instr address	= address
	instr argumentCount	= argumentCount
	instr argumentValues	= argumentValues
	instr returnCount	= returnCount
	instr returnValues	= returnValues

end
//[cf]
//[of]:emitJump
function emitJump (label: *PLabel)

	var instr = self emitInstruction (PJumpInstruction)
	instr code	= 'jump
	instr label	= label

end
//[cf]
//[of]:emitJumpC
function emitJumpC (	condition	: ConditionFlags, 
	label	: *PLabel )

	var instr = self emitInstruction (PJumpcInstruction)
	instr code	= 'jumpc
	instr condition	= condition
	instr label	= label

end
//[cf]
//[of]:emitJumpi
function emitJumpi (value: *PValue)

	var instr = self emitInstruction (PUnaryInstruction)
	instr code	= 'jumpi
	instr value1	= value

end
//[cf]
//[of]:emitLabel
function emitLabel (label: *PLabel)
	
	var instr = self emitInstruction (PLabelInstruction)
	instr code	= 'label
	instr label	= label

end
//[cf]
//[of]:emitReturn
function emitReturn (count: Integer, values: *[]*PValue)

	var instr = self emitInstruction (PReturnInstruction)
	instr code	= 'return
	instr label	= self exitLabel
	instr count	= count
	instr values	= values

end
//[cf]
//[of]:emitModule
function emitModule (module: *Module)

	var instr = self emitInstruction (PModuleInstruction)
	instr code = 'module
	instr module = module

end
//[cf]

//[of]:emitUnary
function emitUnary (op: PInstructionCode, value: *PValue )

	var instr = self emitInstruction (PUnaryInstruction)
	instr code	= op
	instr value1	= value

end
//[cf]
//[of]:emitBinary
function emitBinary (	op	: PInstructionCode,
	value1	: *PValue, 
	value2	: *PValue )

	var instr = self emitInstruction (PBinaryInstruction)
	instr code	= op
	instr value1	= value1
	instr value2	= value2

end
//[cf]
//[of]:emitTernary
function emitTernary (	op	: PInstructionCode,
	value1	: *PValue, 
	value2	: *PValue,
	value3	: *PValue )

	var instr = self emitInstruction (PTernaryInstruction)
	instr code	= op
	instr value1	= value1
	instr value2	= value2
	instr value3	= value3

end
//[cf]
//[of]:emitInstruction
function emitInstruction (T)

	var i = self pool allocate (T)
	i line = self line
	if self instructions isNil
		self instructions = self pool new (Collection (PInstruction))
	end
	self instructions add (i)
	return i

end
//[cf]
//[cf]
//[of]:creating values
//[of]:newParameter
function newParameter (name: String8, size: PValueSize)
	return self pfunction addParameter (self pool, name, size)
end
//[cf]
//[of]:newVariable
function newVariable (name: String8, size: PValueSize)
	return self pfunction addVariable (self pool, name, size)
end
//[cf]
//[of]:newLocal
function newLocal (size: Disp32)
	return self pfunction addLocal (self pool, size)
end
//[cf]
//[of]:newInteger
function newInteger (size: PValueSize, n: Uinteger)
	return PIntegerValue new (self pool, size, n cast (Uint64))
end
//[cf]
//[of]:newInteger64
function newInteger64 (size: PValueSize, n: Uint64)
	return PIntegerValue new (self pool, size, n)
end
//[cf]
//[of]:newBase
function newBase (size: PValueSize, offset: Disp32)
	return PValue newBase (self pool, size, offset)
end
//[cf]
//[of]:newIndex
function newIndex (base: *PValue)
	return PIndexValue new (self pool, base)
end

function newIndex2 (base: *PValue, offset: Disp32)
	return PIndexValue new2 (self pool, base, offset)
end

function newIndex3 (base: *PValue, index: *PValue, scale: Uinteger, offset: Disp32)
	return PIndexValue new3 (self pool, base, index, scale, offset)
end
//[cf]
//[of]:newGlobal
function newGlobal
	return PGlobalValue new (self pool)
end
//[cf]
//[of]:newMemory
//[c]We can't use the newMemory from the function as this function is also
//[c]used for global variables (outside function)
//[c]
function newMemory (size: PValueSize, address: *PValue)
	return PMemoryValue new (self pool, size, address)
end
//[cf]
//[of]:newComposite
function newComposite (size: Integer)
	return PCompositeValue new (self pool, size)
end
//[cf]
//[of]:newComparison
function newComparison (value1: *PValue, value2: *PValue, flags: ConditionFlags)
	return PComparisonValue new (self pool, value1, value2, flags)
end
//[cf]
//[cf]
//[of]:creating other
//[of]:newLabel
function newLabel
	return self pfunction addLabel (self pool)
end
//[cf]
//[of]:newSwitchTable
function newSwitchTable (size: Uinteger, defaultLabel: *PLabel)
	var table = self pool allocateBytes (size cast (Size) * SwitchItem size + SwitchTable size) cast (*SwitchTable)
	var value = self newGlobal
	table initialize (size, value, defaultLabel, self pfunction)
	return table
end
//[cf]
//[cf]
//[of]:utils
//[of]:cellType
function cellType (e: *BinaryExpression)

	var arrayValue	= e argument1
	var arrayType	= arrayValue type asPointer target asArray
	var cellType	= arrayType cellType
	return cellType

end
//[cf]
//[of]:shift
function shift (x: Uinteger) : Uinteger

	if x == 0
		return 0
	end
	
	var pow = Uint32 : 0
	var n = x
	while n <> 1
		if (n & 1) <> 0
			return 0
		end
		n >>= 1
		pow ++
	end
	return pow

end
//[cf]
//[of]:singleton
function singleton (values: *[] *PValue, n: Integer)

	if n == 0
		return nil
	elsif n == 1
		return values [0]
	else
		var composite = self newComposite (n)
		n each do i
			composite values [i] = values [i]
		end
		return composite
	end

end
//[cf]
//[of]:forceRMI
function forceRMI (v: *PValue)

	if v code <= 'memory
		return v
	elsif v isI32
		return v
	else
		return self emitLoadAuto (v)
	end

end
//[cf]
//[of]:forceRM
function forceRM (v: *PValue)

	if v code > 'memory
		return self emitLoadAuto (v)
	else
		return v
	end

end
//[cf]
//[of]:forceRI
function forceRI (v: *PValue)

	if v isX or v isC or v isM
		return self emitLoadAuto (v)
	else
		return v
	end

end
//[cf]
//[of]:forceR
function forceR (v: *PValue)

	if v isR
		return v
	else
		return self emitLoadAuto (v)
	end

end
//[cf]
//[of]:smartCopy
//[c]Generate code to get an immutable value of the expression:
//[c]	* if the expression is a constant, a local variable or a parameter, just evaluate it.
//[c]	* otherwise evaluate it and store it in a local variable
//[c]
function smartCopy (e: *Expression)

	var v = self generateExpression (e)
	if e isConstant or e isLocalVariable or e isParameter
		return v
	else
		return self emitLoadAuto (v)
	end

end
//[cf]

//[of]:buildAdd
function buildAdd (value1: *PValue, value2: *PValue)

	var v1	= value1
	var v2	= value2

	// Try to use the index value first (works only with 64 bit integers)
	if v1 size == 'qword
		if v1 isR and v2 isR
			return self newIndex3 (v1, v2, 1, 0)
		elsif v2 isI32
			if v1 isR
				return self newIndex2 (v1, v2 asInteger offset)
			elsif v1 isX
				var i = v1 asIndex
				return self newIndex3 (i base, i index, i scale, i offset + v2 asInteger offset)
			else
				var t = self emitLoadAuto (v1)
				return self newIndex2 (t, v2 asInteger offset)
			end
		elsif v1 isX and v2 isR
			var i = v1 asIndex
			if i index isNil
				return self newIndex3 (i base, v2, 1, i offset)
			elsif i base isNil
				return self newIndex3 (v2, i index, i scale, i offset)
			end
		
		elsif v1 isI32
			if v2 isR
				return self newIndex2 (v2, v1 asInteger offset)
			elsif v2 isX
				var i = v2 asIndex
				return self newIndex3 (i base, i index, i scale, i offset + v1 asInteger offset)
			else
				var t = self emitLoadAuto (v2)
				return self newIndex2 (t, v1 asInteger offset)
			end
		elsif v2 isX and v1 isR
			var i = v2 asIndex
			if i index isNil
				return self newIndex3 (i base, v1, 1, i offset)
			elsif i base isNil
				return self newIndex3 (v1, i index, i scale, i offset)
			end
		end
	end

	// t = v1
	// t += v2
	//
	// v1 and v2 are order following the criteria ('<' reads 'before'):
	// 	x < r < m < i
	// x first because we can load x but not add it (it will be loaded first, generating an extra load)
	// r next because if t use the same register, the instruction will be eliminated
	// i last because an add with a constant can be optimized.
	//
	if v1 addRank > v2 addRank
		v1, v2 = v2, v1
	end
		
	var t = self emitLoadAuto (v1)
	self emitAdd (t, v2)
	return t

end
//[cf]
//[of]:buildSub
function buildSub (v1: *PValue, v2: *PValue)

	// Try to use the index value first (works only with 64 bit integers)	
	if v1 size == 'qword
		if v1 isR and v2 isI32
			return self newIndex2 (v1, - (v2 asInteger offset))
		elsif v1 isX and v2 isI32
			var i = v1 asIndex
			return self newIndex3 (i base, i index, i scale, i offset - v2 asInteger offset)
		end
	end

	// t = v1
	// t -= v2
	//		
	var t = self emitLoadAuto (v1)
	self emitSub (t, v2)
	return t

end
//[cf]
//[of]:buildMul
function buildMul (value1: *PValue, value2: *PValue)

	var v1	= value1
	var v2	= value2
	var size	= v1 size

	if v1 isInteger
		v1, v2 = v2, v1
	end

	if v2 isInteger
		var imm = v2 asInteger dword

		// Multiply by zero
		if imm == 0
			return zeroValues [size]
		end
		
		// Multiply by one
		if imm == 1
			return v1
		end

		// If v1 is in the form index * scale then
		// replace v1 with index and imm with imm * scale
		if v1 isX
			var i = v1 asIndex
			if i base isNil and i offset == 0
				v1 = i index
				imm = i scale smul (imm)
			end
		end
		
		// Try to use the indexed addressing mode
		if size == 'qword and imm == 2 or imm == 4 or imm == 8
			return self newIndex3 (nil, self forceR (v1), imm, 0)
		end
		
		// Multiply by power of two
		var pow = self shift (imm)
		if pow <> 0
			var t = self emitLoadAuto (v1)
			self emitShl (t, self newInteger ('byte, pow))
			return t
		end
	end
	
	// Byte size requires the use of the accumulator
	if size == 'byte
		var t = self emitLoadAuto (v1)
		self emitBinary ('smul, t, self forceRM (v2))
		return t
	end

	if v2 isI32
		var t = self newVariable (nil, size)
		self emitTernary ('smul3, t, self forceRM (v1), v2)
		return t
	else
		var t = self emitLoadAuto (v1)
		self emitBinary ('smul2, t, self forceRM (v2))
		return t
	end

end
//[cf]
//[of]:buildSdiv
function buildSdiv (v1: *PValue, v2: *PValue)

	var t	= self newVariable (nil, v1 size)
	self emitSdiv (t, v1, v2)
	return t

end
//[cf]
//[of]:buildIndex
function buildIndex (value: *PValue, offset: Disp32)

	if offset == 0
		return value
	end
	
	if value isR
		return self newIndex2 (value, offset)
	end

	if value isX
		var src = value asIndex
		return self newIndex3 (src base, src index, src scale, src offset + offset)
	end
	
	var t = self emitLoadAuto (value)
	return self newIndex2 (t, offset)

end
//[cf]
//[of]:buildMemory
function buildMemory (size: PValueSize, address: *PValue)

	if address isI32 or address isX
		return self newMemory (size, address)
	end
	
	if address isR
		var index = self newIndex (address)
		return self newMemory (size, index)
	end
	
	// M
	var t = self emitLoadAuto (address)
	var index = self newIndex (t)
	return self newMemory (size, index)

end
//[cf]

//[of]:sizeCode
//[c]Converts a size in bytes into an enum PValueSize
//[c]
//[c]	The size is assumed to be the size of a variable, it shouldn't be
//[c]	over 8 bytes.
//[c]
static function sizeCode (type: *Type)
	return size_codes [type size]
end

static const size_codes = *[] PValueSize : {
	'byte,	// 0
	'byte,	// 1
	'word,	// 2
	'byte,	// 3
	'dword,	// 4
	'byte,	// 5
	'byte,	// 6
	'byte,	// 7
	'qword }	// 8
//[cf]

//[of]:getFunctionReference
static function getFunctionReference (c: *FunctionExpression)

	var proto = c value
	if proto code == 'function
		var pf = pfunction (proto)
		// Mark the function as referenced
		pf called = true
		return pf
	else
		return proto generator
	end

end
//[cf]
//[of]:getScaled
function getScaled (e: *BinaryExpression, index: *PValue)

	var indexType = e argument2 type
	var value = self getResize (index, indexType, 'qword)
	var factor = sizeToUnsigned64 (self cellType (e) size)

	if factor == 1
		return value
	end
	
	if value isI32
		return self newInteger64 ('qword, value asInteger qword smul (factor))
	end
	
	// Default: perform multiplication
	var cellSize	= self newInteger64 ('qword, factor)
	return self buildMul (value, cellSize)

end
//[cf]
//[of]:getResize
function getResize (value: *PValue, oldType: *Type, newSize: PValueSize)

	var oldSize = value size
	if newSize < oldSize
		var t = self newVariable (nil, newSize)
		self emitTruncate (t, value)
		return t
	elsif newSize > oldSize
		var t = self newVariable (nil, newSize)
		if oldType isSigned
			self emitSext (t, value)
		else
			self emitZext (t, value)
		end
		return t
	else
		return value
	end

end
//[cf]
//[cf]
//[of]:classes
//[of]:	InlineContext
//[c]When generating the code of an inline function, this context provides
//[c]information for returns
//[c]
static struct InlineContext

	var next	: *InlineContext	// The parent context : inline functions can be nested
	var exitLabel	: *PLabel	// Return will jump to this label
	var startUnwind	: *UnwindItem	// Return will unwind up to this label
	var returnValues	: *[] *PValue	// If single return: a pointer to an array to store the values of the unique return
			// otherwise: it contains the return variables: the return variables will be assign to them
	var singleReturn	: Bool	// The function being inlined has at most one return statement
			
end
//[cf]
//[of]:	LeaveContext
//[c]Information to exit from a block instruction ('leave)
//[c]
static struct LeaveContext

	var exitLabel	: *PLabel
	var startUnwind	: *UnwindItem	// Return will unwind up to this label
	var returnValues	: *PCompositeValue

end
//[cf]
//[of]:	PWhile
//[c]Extra information for a while statement, it provides information for breaks
//[c]
static struct PWhile

	var exitLabel	: *PLabel	// Break will jump to this label
	var continueLabel	: *PLabel	// Continue will jump to this label
	var startUnwind	: *UnwindItem	// Break & continue will unwind up to this label
			
end
//[cf]
//[of]:	ShiftTable
static struct ShiftTable

	var imm	: PInstructionCode	// The instruction code to use when shifting with an immediate value
	var cl	: PInstructionCode	// The instruction code to use when shifting with register cl

	'shl	= {'shli, 'shlc}
	'sshr	= {'sshri, 'sshrc}
	'ushr	= {'ushri, 'ushrc}

end
//[cf]
//[of]:	ScaleTable
static struct ScaleTable

	var op	: PInstructionCode	// The instruction code to use
	var shift	: *ShiftTable	// The shift table to use when scaling with a power of two

	'umul	= {'umul, 'shl}
	'sdiv	= {'sdiv, 'sshr}
	'udiv	= {'udiv, 'ushr}

end
//[cf]
//[of]:	ModuloTable
static struct ModuloTable

	var op	: PInstructionCode	// The instruction code to use

	'smod	= {'smod}
	'umod	= {'umod}

end
//[cf]
//[cf]
//[cf]

end
//[cf]
//[of]:P-Code
//[of]:PLabel
//[c]A label defines a position in the code of a function.
//[c]
//[c]It is possible to jump to a label in the same function but it is not
//[c]possible to jump to a label defined in another function.
//[c]
static struct PLabel

	var id	: Integer
	var index	: InstructionIndex
	
	// Assembler
	var address	: ObjectOffset

//[of]:	instance creation
//[of]:new
meta function new (pool: *MemoryPool, id: Integer)

	var label = pool allocate (self)
	label id = id
	label index = 'invalid
	label address = 'undefined
	return label

end
//[cf]
//[cf]
//[of]:	testing
//[of]:isDefined
function isDefined
	return self address <> 'undefined
end
//[cf]
//[cf]
//[of]:	output
//[of]:addToStringBuffer
function addToStringBuffer (sb: *StringBuffer)

	sb << CodeUnit : $L
	sb << self id

end
//[cf]
//[cf]

end
//[cf]
//[of]:SwitchItem
static struct SwitchItem
	var value	: Int64
	var label	: *PLabel
end
//[cf]
//[of]:SwitchTable
static struct SwitchTable : CollectionElement (SwitchTable)

	var size	: Uinteger	// Number of choices
	var low	: Int64	// The smallest constant
	var high	: Int64	// The biggest constant
	var value	: *PGlobalValue	// The address of the table
	var defaultLabel	: *PLabel	// The default case or nil
	var pfunction	: *PFunction	// The function using this table - labels are relative to the symbol of this function
	var choices	: [] SwitchItem	// The list of choices

//[of]:	initialize - release
//[of]:initialize
function initialize (size: Uinteger, value: *PGlobalValue, defaultLabel: *PLabel, pfunction: *PFunction)
	self size	= size
	self low	= Int64 : 0x7FFFFFFF // ### 7FFFFFFFFFFFFFFF
	self high	= Int64 : 0 - 0x7FFFFFFF
	self value	= value
	self defaultLabel	= defaultLabel
	self pfunction	= pfunction
end
//[cf]
//[cf]
//[of]:	accessing
//[of]:setCase
function setCase (	index	: Index, 
	value	: Int64, 
	label	: *PLabel)

	self choices [index] value	= value
	self choices [index] label	= label
	self low = min (self low, value)
	self high = max (self high, value)

end
//[cf]
//[cf]
//[of]:	enumerating
//[of]:each
function each

	self size each do i
		var item = self choices [i]
		yield item value, item label
	end

end
//[cf]
//[cf]

end
//[cf]

//[of]:Instructions
//[of]:PInstructionCode
static stype PInstructionCode

	'load	// load	r, rmix
	'store	// store	rm, ri
	'truncate	// truncate	r, rm
	'movsx	// movsx	r, rm
	'movzx	// movzx	r, rm
	'add	// add	r, rmi
		// add	rm, ri
	'sub	// sub	r, rmi
		// sub	rm, ri
	'smul	// smul	rm, rm	-- use the accumulator as intermediary
	'smul2	// smul	r, rm
	'smul3	// smul	r, rm, i
	'umul	// umul	rm, rm	-- use the accumulator as intermediary
	'sdiv	// sdiv	rm, rm	-- use the accumulator as intermediary
	'udiv	// udiv	rm, rm	-- use the accumulator as intermediary
	'smod	// smod	rm, rm	-- use the accumulator as intermediary
	'umod	// umod	rm, rm	-- use the accumulator as intermediary
	'shli	// shl	rm, i8
	'shlc	// shl	rm, rmi
	'sshri	// sshri	rm, i8
	'sshrc	// sshrc	rm, rmi
	'ushri	// ushri	rm, i8
	'ushrc	// ushrc	rm, rmi
	'and	// and	r, rmi
		// and	rm, ri
	'or	// or	r, rmi
		// or	rm, ri
	'xor	// xor	r, rmi
		// xor	rm, ri
	'cmp	// cmp	r, rmi
		// cmp	rm, ri
	'not	// not	rm
	'neg	// neg	rm
	'test	// test	rm, ri
	'set	// set	rm
	'call	// call	rmi, ri, ri, ... -> r, r, ...
	'return	// return	ri, ri, ...
	'jumpi	// jump	rmi
	'lookup	// lookup	rmi, r
	'label	// label	L
	'jump	// jump	L
	'jumpc	// jump	cc, L
	'module	// for debug info: notify a module-change

end
//[cf]
//[of]:PInstruction
static struct PInstruction : CollectionElement (PInstruction)

	var code	: PInstructionCode
	var line	: LineNumber

//[of]:	accessing
//[of]:hash
function hash

	switch self code
	case	'load,
		'store,
		'truncate,
		'movsx,
		'movzx,
		'add,
		'sub,
		'smul2,
		'and,
		'or,
		'xor,
		'cmp,
		'test,
		'lookup
	
		var i = self asBinary
		return i value1 hash + i value2 hash
		
	case	'smul,
		'umul,
		'sdiv,
		'udiv,
		'shlc,
		'sshrc,
		'ushrc,
		'not,
		'neg,
		'jumpi
	
		var i = self asUnary
		return i value1 hash
		
	else
		return self code cast (Size)
	end

end
//[cf]
//[of]:name
function name
	return self class name
end
//[cf]
//[of]:registers
function registers
	return self class registers
end
//[cf]
//[cf]
//[of]:	testing
//[of]:isFollowedByLabel
function isFollowedByLabel (label: *PLabel)

	var next = self nextSibling
	
	// No more instruction
	if next isNil
		return false
	end
	
	// Not a label
	if next code <> 'label
		return false
	end
	
	// Compare labels
	return next asLabel label == label

end
//[cf]
//[of]:isEqual
function isEqual (other: *PInstruction)

	if self code <> other code
		return false
	end
	return self class equalFunction call (self, other)

end
//[cf]
//[cf]
//[of]:	downcasting
//[of]:asLabel
function asLabel
	return self downcast (*PLabelInstruction)
end
//[cf]
//[of]:asUnary
function asUnary
	return self downcast (*PUnaryInstruction)
end
//[cf]
//[of]:asBinary
function asBinary
	return self downcast (*PBinaryInstruction)
end
//[cf]
//[of]:asTernary
function asTernary
	return self downcast (*PTernaryInstruction)
end
//[cf]
//[of]:asShift
function asShift
	return self downcast (*PShiftInstruction)
end
//[cf]
//[of]:asJump
function asJump
	return self downcast (*PJumpInstruction)
end
//[cf]
//[of]:asJumpc
function asJumpc
	return self downcast (*PJumpcInstruction)
end
//[cf]
//[of]:asSet
function asSet
	return self downcast (*PSetInstruction)
end
//[cf]
//[of]:asCall
function asCall
	return self downcast (*PCallInstruction)
end
//[cf]
//[of]:asReturn
function asReturn
	return self downcast (*PReturnInstruction)
end
//[cf]
//[of]:asModule
function asModule
	return self downcast (*PModuleInstruction)
end
//[cf]
//[cf]
//[of]:	operations
//[of]:markVariables
function markVariables (pf: *PFunction, index: InstructionIndex)
	self class markFunction call (self, pf, index)
end
//[cf]
//[cf]
//[of]:	output
//[of]:addToStringBuffer
function addToStringBuffer (sb: *StringBuffer) :
	self class writeFunction call (self, sb)
end
//[cf]
//[cf]
//[of]:	private
function class : *Class
	return classes [self code]
end

static struct Class
	var name	: String	// The name of the instruction
	var equalFunction	: & (*PInstruction, *PInstruction) -> (Bool)	// The comparison function
	var writeFunction	: & (*PInstruction, *StringBuffer)	// The write function
	var markFunction	: & (*PInstruction, *PFunction, InstructionIndex)	// The markVariables function
	var registers	: RegisterMask	// The modified registers
end

static const classes = *[] Class : {
	"load",	cmp_bin,	write_bin,	mark_bin,	'none,	// load	r, rmix
	"store",	cmp_bin,	write_bin,	mark_bin,	'none,	// store	rm, ri
	"trunc",	cmp_bin,	write_bin,	mark_bin,	'none,	// truncate	r, rm
	"movsx",	cmp_bin,	write_bin,	mark_bin,	'none,	// movsx	r, rm
	"movzx",	cmp_bin,	write_bin,	mark_bin,	'none,	// movzx	r, rm
	"add",	cmp_bin,	write_bin,	mark_bin,	'none,	// add	r, rmi
	"sub",	cmp_bin,	write_bin,	mark_bin,	'none,	// sub	r, rmi
	"smul",	cmp_bin,	write_bin,	mark_binx,	'rax | 'rdx,	// smul	rm, rm
	"smul",	cmp_bin,	write_bin,	mark_bin,	'none,	// smul	r, rmi
	"smul",	cmp_ter,	write_ter,	mark_ter,	'none,	// smul	r, rm, i
	"umul",	cmp_bin,	write_bin,	mark_binx,	'rax | 'rdx,	// umul	rm, rm
	"sdiv",	cmp_bin,	write_bin,	mark_binx,	'rax | 'rdx,	// sdiv	rm, rm
	"udiv",	cmp_bin,	write_bin,	mark_binx,	'rax | 'rdx,	// udiv	rm, rm
	"smod",	cmp_bin,	write_bin,	mark_binx,	'rax | 'rdx,	// smod	rm, rm
	"umod",	cmp_bin,	write_bin,	mark_binx,	'rax | 'rdx,	// umod	rm, rm
	"shl",	cmp_shift,	write_shift,	mark_un,	'none,	// shl	rm, i8
	"shl",	cmp_bin,	write_bin,	mark_bin,	'rcx,	// shl	rm, rmi
	"sshr",	cmp_shift,	write_shift,	mark_un,	'none,	// sshr	rm, i8
	"sshr",	cmp_bin,	write_bin,	mark_bin,	'rcx,	// sshr	rm, rmi
	"ushr",	cmp_shift,	write_shift,	mark_un,	'none,	// ushr	rm, i8
	"ushr",	cmp_bin,	write_bin,	mark_bin,	'rcx,	// ushr	rm, rmi
	"and",	cmp_bin,	write_bin,	mark_bin,	'none,	// and	r, rmi
	"or",	cmp_bin,	write_bin,	mark_bin,	'none,	// or	r, rmi
	"xor",	cmp_bin,	write_bin,	mark_bin,	'none,	// xor	r, rmi
	"cmp",	cmp_bin,	write_bin,	mark_bin,	'none,	// cmp	r, rmi
	"not",	cmp_un,	write_un,	mark_un,	'none,	// not	rm
	"neg",	cmp_un,	write_un,	mark_un,	'none,	// neg	rm
	"test",	cmp_bin,	write_bin,	mark_bin,	'none,	// test	rm, ri
	"set",	cmp_set,	write_set,	mark_un,	'none,	// set	rm
	"call",	cmp_call,	write_call,	mark_call,	scratchRegisters,	// call	rmi, rm, ... -> rm
	"return",	cmp_return,	write_return,	mark_return,	'none,	// return	ri, ri, ...
	"jump", 	cmp_un,	write_un,	mark_un,	'rax | 'rdx | 'rcx,	// jump	rmi
	"lookup",	cmp_bin,	write_bin,	mark_bin,	'rax | 'rdx | 'rcx,	// lookup	rmi, rmi
	"label",	cmp_label,	write_label,	mark_label,	'none,	// label	L
	"jump",	cmp_jump,	write_jump,	mark_jump,	'none,	// jump	L
	"jump",	cmp_jumpc,	write_jumpc,	mark_jump,	'none,	// jump	cc, L
	"module",	cmp_module,	write_module,	mark_module,	'none}	// module

// Scratch registers (standard ABI)
static const scratchRegisters = RegisterMask : 'rax | 'rcx | 'rdx | 'rsi | 'rdi | 'r8 | 'r9 | 'r10 | 'r11

static const cmp_un	= ref (*PUnaryInstruction)	equals (*PUnaryInstruction)
static const cmp_bin	= ref (*PBinaryInstruction)	equals (*PBinaryInstruction)
static const cmp_ter	= ref (*PTernaryInstruction)	equals (*PTernaryInstruction)
static const cmp_shift	= ref (*PShiftInstruction)	equals (*PShiftInstruction)
static const cmp_set	= ref (*PSetInstruction)	equals (*PSetInstruction)
static const cmp_call	= ref (*PCallInstruction)	equals (*PCallInstruction)
static const cmp_return	= ref (*PReturnInstruction)	equals (*PReturnInstruction)
static const cmp_label	= ref (*PLabelInstruction)	equals (*PLabelInstruction)
static const cmp_jump	= ref (*PJumpInstruction)	equals (*PJumpInstruction)
static const cmp_jumpc	= ref (*PJumpcInstruction)	equals (*PJumpcInstruction)
static const cmp_module	= ref (*PModuleInstruction)	equals (*PModuleInstruction)

static const write_un	= ref (*PUnaryInstruction)	write (*StringBuffer)
static const write_bin	= ref (*PBinaryInstruction)	write (*StringBuffer)
static const write_ter	= ref (*PTernaryInstruction)	write (*StringBuffer)
static const write_shift	= ref (*PShiftInstruction)	write (*StringBuffer)
static const write_set	= ref (*PSetInstruction)	write (*StringBuffer)
static const write_call	= ref (*PCallInstruction)	write (*StringBuffer)
static const write_return	= ref (*PReturnInstruction)	write (*StringBuffer)
static const write_label	= ref (*PLabelInstruction)	write (*StringBuffer)
static const write_jump	= ref (*PJumpInstruction)	write (*StringBuffer)
static const write_jumpc	= ref (*PJumpcInstruction)	write (*StringBuffer)
static const write_module	= ref (*PModuleInstruction)	write (*StringBuffer)

static const mark_un	= ref (*PUnaryInstruction)	mark (*PFunction, InstructionIndex)
static const mark_bin	= ref (*PBinaryInstruction)	mark (*PFunction, InstructionIndex)
static const mark_binx	= ref (*PBinaryInstruction)	markx (*PFunction, InstructionIndex)
static const mark_ter	= ref (*PTernaryInstruction)	mark (*PFunction, InstructionIndex)
static const mark_shift	= ref (*PShiftInstruction)	mark (*PFunction, InstructionIndex)
static const mark_call	= ref (*PCallInstruction)	mark (*PFunction, InstructionIndex)
static const mark_return	= ref (*PReturnInstruction)	mark (*PFunction, InstructionIndex)
static const mark_label	= ref (*PLabelInstruction)	mark (*PFunction, InstructionIndex)
static const mark_jump	= ref (*PJumpInstruction)	mark (*PFunction, InstructionIndex)
static const mark_module	= ref (*PModuleInstruction)	mark (*PFunction, InstructionIndex)
//[cf]

end
//[cf]

//[of]:PLabelInstruction
static struct PLabelInstruction : PInstruction

	var label	: *PLabel

	function write (sb: *StringBuffer)
		sb << self label
		sb << CodeUnit : $:
	end

	function equals (other: *PLabelInstruction)
		return self label id == other label id
	end

	function mark (pf: *PFunction, index: InstructionIndex)
		self label index = index
	end

end
//[cf]
//[of]:PUnaryInstruction
static struct PUnaryInstruction : PInstruction

	var value1	: *PValue

	function write (sb: *StringBuffer)
		var name = self name
		var v1 = self value1
		sb addFormat ("\t\a\t\a", name, v1)
	end

	function equals (other: *PUnaryInstruction)
		return self value1 isEqual (other value1)
	end

	function mark (pf: *PFunction, index: InstructionIndex)
		self value1 markVariables (index + 'load)
	end
	
end
//[cf]
//[of]:PBinaryInstruction
static struct PBinaryInstruction : PUnaryInstruction

	var value2	: *PValue

	function write (sb: *StringBuffer) :
		var name = self name
		var v1 = self value1
		var v2 = self value2
		sb addFormat ("\t\a\t\a, \a", name, v1, v2)
	end

	function equals (other: *PBinaryInstruction)
		return	self value1 isEqual (other value1) and
			self value2 isEqual (other value2)
	end

	function mark (pf: *PFunction, index: InstructionIndex)
		self value1 markVariables (index + 'store)
		self value2 markVariables (index + 'load)
	end

	// Same as mark but value2 is conflicting with the internal operations
	function markx (pf: *PFunction, index: InstructionIndex)
		self value1 markVariables (index + 'store)
		self value2 markVariables (index + 'internal)
	end

end
//[cf]
//[of]:PTernaryInstruction
static struct PTernaryInstruction : PBinaryInstruction

	var value3	: *PValue

	function write (sb: *StringBuffer)
		var name = self name
		var v1 = self value1
		var v2 = self value2
		var v3 = self value3
		sb addFormat ("\t\a\t\a, \a, \a", name, v1, v2, v3)
	end
	
	function equals (other: *PTernaryInstruction)
		return	self value1 isEqual (other value1) and 
			self value2 isEqual (other value2) and
			self value3 isEqual (other value3)
	end

	function mark (pf: *PFunction, index: InstructionIndex)
		self value1 markVariables (index + 'store)
		self value2 markVariables (index + 'load)
		self value3 markVariables (index + 'load)
	end
	
end
//[cf]
//[of]:PShiftInstruction
static struct PShiftInstruction : PUnaryInstruction

	var shift	: Byte

	function write (sb: *StringBuffer)
		var name = self name
		var v1 = self value1
		var v2 = self shift cast (Uinteger)
		sb addFormat ("\t\a\t\a, \a", name, v1, v2)
	end

	function equals (other: *PShiftInstruction)
		return	self value1 isEqual (other value1) and
			self shift == other shift
	end

end
//[cf]
//[of]:PJumpInstruction
static struct PJumpInstruction : PInstruction

	var label	: *PLabel

//[of]:	equals
function equals (other: *PJumpInstruction)
	return self label id == other label id
end
//[cf]
//[of]:	mark
//[c]Extends the range of all variables actives at the label targetted by the jump
//[c]to the index of the jump (the index argument).
//[c]
//[c]The algorithm works as is:
//[c]	When closing a loop (range [a, b]):
//[c]		For each active variables (range [x, y]):
//[c]			if x < a and y >= a then replace y by b
//[c]	
//[c]	a and b sont les bounds of the loop.
//[c]	* x is the first access to the variable
//[c]	* y is the last known access to the variable when closing the loop.
//[c]
//[c]	We're only interested in variables having at least one access in the loop.
//[c]	Otherwise, either there is an access after the loop, or the variable is inactive when the loop starts.
//[c]
function mark (pf: *PFunction, index: InstructionIndex)

	var labelIndex = self label index
	// We are only interested in backward jumps, forward jumps are
	// not set yet.
	if labelIndex <> 'invalid
		pf variables each do v
			// If the variable is active at the label: extend the range
			if v firstIndex <= labelIndex and v lastIndex >= labelIndex
				v lastIndex = index
			end
		end

		pf parameters each do p
			// If the parameter is active at the label: extend the range
			if p lastIndex >= labelIndex
				p lastIndex = index
			end
		end
	end

end
//[cf]
//[of]:	write
function write (sb: *StringBuffer)
	sb addFormat ("\tjump\t\a", self label)
end
//[cf]

end
//[cf]
//[of]:PJumpcInstruction
static struct PJumpcInstruction : PJumpInstruction

	var condition	: ConditionFlags	// The boolean value, must be a comparison or a simple value

	function write (sb: *StringBuffer)
		sb addFormat ("\tj\a\t\a", self condition, self label)
	end

	function equals (other: *PJumpcInstruction)
		return	self label id == other label id and
			self condition == other condition
	end

end
//[cf]
//[of]:PSetInstruction
static struct PSetInstruction : PUnaryInstruction

	var condition	: ConditionFlags

	function write (sb: *StringBuffer)
		sb addFormat ("\tset\a\t\a", self condition, self value1)
	end

	function equals (other: *PSetInstruction)
		return	self value1 isEqual (other value1) and
			self condition == other condition
	end

end
//[cf]
//[of]:PCallInstruction
static struct PCallInstruction : PInstruction

	var address	: *PValue
	var argumentCount	: Integer
	var returnCount	: Integer
	var argumentValues	: *[] *PValue
	var returnValues	: *[] *PValue

	function write (sb: *StringBuffer)
		sb << CodeUnit : 'tab
		sb << String : "call"
		sb << CodeUnit : 'tab
		sb << self address
		self eachArgument do v
			sb << String : ", "
			sb << v
		end
		sb << String : " -> "
		var comma = false
		self eachReturn do v
			if comma
				sb << String : ", "
			end
			comma = true
			sb << v
		end
	end

	function equals (other: *PCallInstruction)

		// Compare address	
		if self address notEqual (other address)
			return false
		end
		
		// Compare arguments
		var i = Integer : 0
		var n = self argumentCount
		if n <> other argumentCount
			return false
		end
		while i < n
			if self argumentValues [i] notEqual (other argumentValues [i])
				return false
			end
			i ++
		end
		
		// Compare return values
		i = 0
		n = self returnCount
		if n <> other returnCount
			return false
		end
		while i < n
			if self returnValues [i] notEqual (other returnValues [i])
				return false
			end
			i ++
		end
		
		return true
		
	end

	function mark (pf: *PFunction, index: InstructionIndex)
		// Order is important as a variable may appear in several locations,
		// so the last occurrence override previous ones.
		self eachArgument do a
			a markVariables (index + 'load)
		end
		self address markVariables (index + 'internal)
		self eachReturn do r
			r markVariables (index + 'store)
		end
	end
	
	function eachArgument
		var i = Index : 0
		var n = self argumentCount
		while i < n
			yield self argumentValues [i]
			i ++
		end
	end
	
	function eachReturn
		var i = Index : 0
		var n = self returnCount
		while i < n
			yield self returnValues [i]
			i ++
		end
	end
	
end
//[cf]
//[of]:PReturnInstruction
static struct PReturnInstruction : PInstruction

	var label	: *PLabel
	var count	: Integer
	var values	: *[] *PValue

	function write (sb: *StringBuffer)
		sb << CodeUnit : 'tab
		sb << String : "return"
		sb << CodeUnit : 'tab
		var comma = false
		self eachReturn do v
			if comma
				sb << String : ", "
			end
			comma = true
			sb << v
		end
	end

	function equals (other: *PReturnInstruction)
		var i = Integer : 0
		var n = self count
		if n <> other count
			return false
		end
		while i < n
			if self values [i] notEqual (other values [i])
				return false
			end
			i ++
		end
		return true
	end

	function mark (pf: *PFunction, index: InstructionIndex)
		self eachReturn do r
			r markVariables (index + 'load)
		end
	end

	function eachReturn
		var i = Index : 0
		var n = self count
		while i < n
			yield self values [i]
			i ++
		end
	end
	
end
//[cf]
//[of]:PModuleInstruction
//[c]This instruction is only used to mark a module-change for debugging information.
//[c]
static struct PModuleInstruction : PInstruction

	var module	: *Module

	function write (sb: *StringBuffer)
		sb << CodeUnit : 'tab
		sb << String : "module"
		sb << CodeUnit : 'tab
		sb << self module filename
	end

	function equals (other: *PModuleInstruction)
		return self module == other module
	end

	function mark (pf: *PFunction, index: InstructionIndex)
		// Nothing to mark
	end

end
//[cf]
//[cf]
//[of]:Scalars
//[of]:InstructionIndex
//[c]Unsigned integer type used to number instructions in a function.
//[c]Its main use is to define the live interval of variables.
//[c]
static stype InstructionIndex : Uinteger
	'invalid	= 0 - 1	// An invalid or undefined index
	'load	= 0	// Offset to load phase in instruction
	'internal	= 1	// Offset to internal phase in instruction -- use special registers here
	'store	= 2	// Offset to store result or load the effective address of the result
	'stepCount	= 3	// The number of steps per instruction
	'last	= 0xFFFFFFFF	// An index bigger than anything possible
end
//[cf]
//[of]:Disp32
//[c]An offset on the stack
//[c]
static stype Disp32 : Integer
	'sizeOfReturnAddress	= 8
	'stackAlignment	= 8

//[of]:	from
meta function from (n: Size)
	return n cast (Disp32)
end
//[cf]
//[of]:	align
//[c]Returns the given size aligned on the next 64-bit multiple.
//[c]
function align
	var alignedSize = self
	alignedSize += 'stackAlignment - 1
	alignedSize &= not ('stackAlignment - 1)
	return alignedSize
end
//[cf]

end
//[cf]
//[of]:Register
static stype Register : Byte
	'rax	// 0
	'rcx	// 1
	'rdx	// 2
	'rbx	// 3
	'rsp	// 4
	'rbp	// 5 
	'rsi	// 6
	'rdi	// 7
	'r8	// 8
	'r9	// 9
	'r10	// 10
	'r11	// 11
	'r12	// 12
	'r13	// 13
	'r14	// 14
	'r15	// 15
		
	'none = 0 - 1
	
//[of]:	mask
function mask

	const masks = *[]RegisterMask : {
		'rax, 'rcx,  'rdx, 'rbx, 0, 'rbp, 'rsi, 'rdi, 'r8, 'r9, 'r10, 'r11, 'r12, 'r13, 'r14, 'r15}
		
	return masks [self]
end
//[cf]
//[of]:	clearMask
function clearMask
	const clearMasks = *[]RegisterMask : {
		not 'rax, not 'rcx,  not 'rdx, not 'rbx, 0, not 'rbp, not 'rsi, not 'rdi, not 'r8, not 'r9, not 'r10, not 'r11, not 'r12, not 'r13, not 'r14, not 'r15}
	
	return clearMasks [self]
end
//[cf]
//[of]:	addToStringBuffer
function addToStringBuffer (sb: *StringBuffer)
	
	const names = *[]String : {
		"rax", "rcx", "rdx", "rbx", "rsp", "rbp", "rsi", "rdi", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"}

	var name = (self == 'none) cond String : "(none)" else names [self]
	sb << name
end
//[cf]

end
//[cf]
//[of]:RegisterMask
static stype RegisterMask : Uinteger

	'none	= 0x0000
		
	'rax	= 0x0001
	'rbx	= 0x0002
	'rcx	= 0x0004
	'rdx	= 0x0008
	'rsi	= 0x0010
	'rdi	= 0x0020
	'rbp	= 0x0040
	'r8	= 0x0080
	'r9	= 0x0100
	'r10	= 0x0200
	'r11	= 0x0400
	'r12	= 0x0800
	'r13	= 0x1000
	'r14	= 0x2000
	'r15	= 0x4000

//[of]:	addToStringBuffer
function addToStringBuffer (sb: *StringBuffer)

	var names = *[] String : {"rax", "rbx", "rcx", "rdx", "rsi", "rdi", "rbp", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"}
		var sep = false
	var m = self
	if m == 0
		sb << String : "none"
	end
	while m <> 0
		if (m & 1) <> 0
			if sep
				sb << CodeUnit : $|
			end
			sep = true
			sb << names []
		end
		m >>= 1
		names ++
	end

end
//[cf]
			
end
//[cf]
//[of]:ConditionFlags
static stype ConditionFlags

	'z	// ==
	'nz	// <>
	'le	// <=
	'be	// <= (unsigned)
	'lt	// <
	'b	// < (unsigned)
	'ge	// >=
	'ae	// >= (unsigned)
	'gt	// >
	'a	// > (unsigned)

	static const names	= *[]String	: {	"z",	"nz",	"le",	"be",	"lt",	"b",	"ge",	"ae",	"gt",	"a"	}
	static const swapTable	= *[]ConditionFlags	: {	'z,	'nz,	'ge,	'ae,	'gt,	'a,	'le,	'be,	'lt,	'b	}
	static const invertTable	= *[]ConditionFlags	: {	'nz,	'z,	'gt,	'a,	'ge,	'ae,	'lt,	'b,	'le,	'be	}
	static const condTable	= *[]Condition	: {	'z,	'nz,	'le,	'be,	'l,	'c,	'ge,	'nc,	'g,	'a	}

	function addToStringBuffer (sb: *StringBuffer)
		sb << names [self]
	end

	function swap
		return swapTable [self]
	end
	
	function invert
		return invertTable [self]
	end

	function code
		return condTable [self]
	end

	static stype Condition : Byte
		'o	= 0
		'c	= 2	// jc, jb (CF=1)
		'nc	= 3
		'z	= 4
		'nz	= 5
		'be	= 6
		'a	= 7
		'l	= 12
		'ge	= 13
		'le	= 14
		'g	= 15
	end

end
//[cf]
//[cf]
//[of]:Values
//[of]:Constants
// Important: These values must never be used in the generator attribute as 
// they can not be shared, they are read-only so the pred attribute can not 
// be modified.

static const zeroValue8	= *PIntegerValue : {'integer,	'byte,	0}
static const zeroValue16	= *PIntegerValue : {'integer,	'word,	0}
static const zeroValue32	= *PIntegerValue : {'integer,	'dword,	0}
static const zeroValue64	= *PIntegerValue : {'integer,	'qword,	0}
	
static const oneValue8	= *PIntegerValue : {'integer,	'byte,	1}
static const oneValue16	= *PIntegerValue : {'integer,	'word,	1}
static const oneValue32	= *PIntegerValue : {'integer,	'dword,	1}
static const oneValue64	= *PIntegerValue : {'integer,	'qword,	1}
	
static const baseValue	= *PValue : {'base, 'qword }	// Special variable pointing to the 'base' address in stack. Will be translated to 'rsp + n' by the assembler..
static const localValue	= *PValue : {'local, 'qword }	// Special variable pointing to the 'local' address in stack. Will be translated to 'rsp + n' by the assembler.
	
static const rspValue	= *PRegisterValue : {'register, 'qword, nil, 'rsp}
//[cf]
//[of]:PValueCode
static stype PValueCode : Byte

	// Order is important
	
	'variable	// r
	'register	// Replace all variables after register allocation
	'memory	// m
	'integer	// i
	'global	// i
	'function	// i
	'index	// x (r + r * s + i)
	'base	// Special value representing the address of the return address that will be replaced by rsp + n
	'local	// Special value representing the address of local variable on stack that will be replaced by rsp + n
	'comparison	// This one never appears in p-instructions
	'composite	// This one never appears in p-instructions

end
//[cf]
//[of]:PValueSize
static stype PValueSize : Byte
	'byte
	'word
	'dword
	'qword
	'undefined	// Unused, for composite only.
	
//[of]:	addToStringBuffer
function addToStringBuffer (sb: *StringBuffer)
	var s : String
	switch self
	case 'byte
		s = "byte"
	case 'word
		s = "word"
	case 'dword
		s = "dword"
	case 'qword
		s = "qword"
	else
		s = "*invalid*"
	end
	sb << s
end
//[cf]
//[of]:	toStackSize
function toStackSize : Disp32
	return 8 // always 64 bits
end
//[cf]

end
//[cf]
//[of]:PValue
static struct PValue

	var code	: PValueCode
	var size	: PValueSize

//[of]:	instance creation
//[of]:newBase
meta function newBase (pool: *MemoryPool, size: PValueSize, offset: Disp32)
	var index = PIndexValue new2 (pool, baseValue, offset)
	return PMemoryValue new (pool, size, index)
end
//[cf]
//[cf]
//[of]:	accessing
//[of]:hash
function hash : Size

	switch self code
	case 'memory
		return self asMemory address hash
	case 'integer
		return self asInteger value cast (Size)
	else
		return self code cast (Size)
	end

end
//[cf]
//[of]:markVariables
function markVariables (index: InstructionIndex) :
	self class markFunction call (self, index)
end
//[cf]
//[of]:addRank
//[c]x < r < m < i
//[c]
function addRank : Integer

	switch self code
	case 'index // x
		return 0
	case 'variable // r
		return 1
	case 'memory // m
		return 2
	else // i
		return 3
	end

end
//[cf]
//[of]:setPreferred
function setPreferred (register: Register)
	if self code == 'variable and self asVariable preferred == 'none
		self asVariable preferred = register
	end
end
//[cf]
//[cf]
//[of]:	converting
//[of]:reduce
//[c]A register referring to a spilled variable or a variable are replaced
//[c]by their memory value.
//[c]
function reduce
	if self isRegister
		if self asRegister isSpilled
			return self asRegister variable memory
		end
	elsif self isVariable
		return self asVariable memory
	end
	return self
end
//[cf]
//[cf]
//[of]:	downcasting
//[of]:asComparison
function asComparison
	return self downcast (*PComparisonValue)
end
//[cf]
//[of]:asComposite
function asComposite
	return self downcast (*PCompositeValue)
end
//[cf]
//[of]:asFunction
function asFunction
	return self downcast (*PFunction)
end
//[cf]
//[of]:asGlobal
function asGlobal
	return self downcast (*PGlobalValue)
end
//[cf]
//[of]:asIndex
function asIndex
	return self downcast (*PIndexValue)
end
//[cf]
//[of]:asInteger
function asInteger
	return self downcast (*PIntegerValue)
end
//[cf]
//[of]:asMemory
function asMemory
	return self downcast (*PMemoryValue)
end
//[cf]
//[of]:asRegister
function asRegister
	return self downcast (*PRegisterValue)
end
//[cf]
//[of]:asVariable
function asVariable
	return self downcast (*PVariable)
end
//[cf]
//[cf]
//[of]:	output
//[of]:addToStringBuffer
function addToStringBuffer (sb: *StringBuffer) :
	self class writeFunction call (self, sb)
end
	
function writeBase (sb: *StringBuffer)
	sb << String : "_base"
end

function writeLocal (sb: *StringBuffer)
	sb << String : "_local"
end
//[cf]
//[cf]
//[of]:	testing
//[of]:isConstant
function isConstant
	return self code in ('integer, 'global)
end
//[cf]
//[of]:isEqual
function isEqual (other: *PValue) : Bool

	if self isNil
		return other isNil
	elsif other isNil
		return false 
	elsif self code <> other code
		return false
	elsif self size <> other size
		return false 
	else
		return self class equalsFunction call (self, other)
	end

end
//[cf]
//[of]:isInteger
function isInteger
	return self code == 'integer
end
//[cf]
//[of]:isRegister
function isRegister
	return self code == 'register
end
//[cf]
//[of]:isVariable
function isVariable
	return self code == 'variable
end
//[cf]

//[of]:isR
function isR
	return	self code == 'variable or
		self code == 'register
end
//[cf]
//[of]:isI32
//[c]Returns true if the value is an integer that fit in a 32 bit value.
//[c]
function isI32

	if self code == 'integer
		// Don't care of the value if not qword
		if self size <> 'qword
			return true
		end
		// Qword: it's limited to imm32 that will be signed extended
		var i = self asInteger value cast (Int64)
		return i <= 0x7FFFFFFF and i >= -0x80000000
	end
	
	return false

end
//[cf]
//[of]:isX
function isX
	return self code == 'index
end
//[cf]
//[of]:isM
function isM
	return	self code == 'memory
end
//[cf]
//[of]:isC
function isC
	return self code == 'comparison
end
//[cf]
//[cf]
//[of]:	private
function class
	return classes [self code]
end

static struct Class
	var equalsFunction	: & (*PValue, *PValue) -> (Bool)
	var writeFunction	: & (*PValue, *StringBuffer)
	var markFunction	: & (*PValue, InstructionIndex)
end

static const classes = *[] Class : {
	// variable
	ref (*PVariable) equals (*PVariable),
	ref (*PVariable) write (*StringBuffer),
	ref (*PVariable) mark (InstructionIndex),
	
	// register
	ref (*PRegisterValue) equals (*PRegisterValue),
	ref (*PRegisterValue) write (*StringBuffer),
	ref (*PRegisterValue) ignore (InstructionIndex),
	
	// memory
	ref (*PMemoryValue) equals (*PMemoryValue),
	ref (*PMemoryValue) write (*StringBuffer),
	ref (*PMemoryValue) mark (InstructionIndex),
	
	// integer
	ref (*PIntegerValue) equals (*PIntegerValue),
	ref (*PIntegerValue) write (*StringBuffer),
	ref (*PIntegerValue) ignore (InstructionIndex),
	
	// global
	ref (*PGlobalValue) equals (*PGlobalValue),
	ref (*PGlobalValue) write (*StringBuffer),
	ref (*PGlobalValue) ignore (InstructionIndex),
	
	// function
	ref (*PFunction) equals (*PFunction),
	ref (*PFunction) write (*StringBuffer),
	ref ignore (*PFunction, InstructionIndex), // PFunction.ignore is an attribute :-(
	
	// index
	ref (*PIndexValue) equals (*PIndexValue),
	ref (*PIndexValue) write (*StringBuffer),
	ref (*PIndexValue) mark (InstructionIndex),
	
	// base
	ref (*PValue) yes (*PValue),
	ref (*PValue) writeBase (*StringBuffer),
	ref (*PValue) ignore (InstructionIndex),
	
	// local
	ref (*PValue) yes (*PValue),
	ref (*PValue) writeLocal (*StringBuffer),
	ref (*PValue) ignore (InstructionIndex),
	
	// comparison
	nil,
	nil,
	nil,
	
	// composite
	nil,
	nil,
	nil}
//[cf]

end
//[cf]

//[of]:PComparisonValue
static struct PComparisonValue : PValue

	var value1	: *PValue	// The left value of the comparison
	var value2	: *PValue	// The right value of the comparison
	var flags	: ConditionFlags	// The flags to check for positive comparison

//[of]:	new
meta function new (	pool	: *MemoryPool,
	value1	: *PValue, 
	value2	: *PValue, 
	flags	: ConditionFlags)

	var c = pool allocate (self)
	c code = 'comparison
	c size = 'byte
	c value1 = value1
	c value2 = value2
	c flags = flags
	return c
end
//[cf]

end
//[cf]
//[of]:PCompositeValue
static struct PCompositeValue : PValue

	var valueCount	: Integer	// The number of values.
	var values	: [] *PValue	// The list of values. It must be the last attribute (variable size)

//[of]:	new
meta function new (pool: *MemoryPool, size: Integer)
	var c = pool allocateWithArray (self, *PValue, size)
	c code = 'composite
	c size = 'undefined
	c valueCount = size
	return c
end
//[cf]
//[of]:	[]
function _at (index: Integer)
	return self values [index]
end
//[cf]
//[of]:	each
function each
	self valueCount each do i
		yield self [i]
	end
end
//[cf]

end
//[cf]
//[of]:PFunction
//[c]
//[c]Anatomy of the stack with a function
//[c]
//[c]	rsp	|--------
//[c]		|
//[c]		| Function arguments + returned values
//[c]		|
//[c]		|--------
//[c]		| Padding
//[c]	local	|--------
//[c]		|
//[c]		| Local variables
//[c]		|
//[c]		|--------
//[c]		|
//[c]		| Saved registers
//[c]		|
//[c]	rbp	|--------
//[c]		| Saved rbp
//[c]	base	|--------
//[c]		| Return address
//[c]	align16	|--------
//[c]		| 
//[c]		| Function arguments
//[c]		|
//[c]		|--------
//[c]		| Returned Values
//[c]		|--------
//[c]		v
//[c]	
//[c]	local
//[c]		local is a pseudo-register : it's a variable pointing to local 
//[c]		variables on stack. The assembler replaces it with 'rbp - n' or 
//[c]		'rsp + n'.
//[c]	base
//[c]		base is a pseudo-register: it's a variable pointing to the return
//[c]		address (the initial value of rsp when entering the function).
//[c]		The assembler replaces it with 'rsp + n'.
//[c]		It is used to access an argument on stack or a return value.
//[c]
static struct PFunction : PValue

	var name	: String8	// The name of the function
	var inlining	: Bool	// The function is being inlined
	var inline	: Bool	// The function should be inlined
	var called	: Bool	// The function is indirectly called, referenced or exported (we must generate the non-inline version of the function)
	var ignore	: Bool	// The function must not be generated in pass 2 as it is never called
	var equivalent	: *Function	// The function is a duplicate of this one (or nil)
	var parameters	: Collection (PVariable)	// The list of parameters
	var variables	: Collection (PVariable)	// The list of local variables
	var instructions	: Collection (PInstruction)	// The list of instructions
	var labelId	: Integer	// Id for the next label
	var comparing	: Bool	// Detect recursion when comparing functions
	
	// The size of different areas on the stack
	var callStackSize	: Disp32	// The number of bytes needed for function calls (to push arguments and collect extra return values)
	var argumentStackSize	: Disp32	// The number of bytes allocated on stack by the arguments
	var localStackSize	: Disp32	// The number of bytes allocated on stack by the locals and variables
	var returnStackSize	: Disp32	// The number of bytes to allocate on stack for return values (excluding the register return values)
	
	// Assembler
	var symbol	: ObjectSymbol	// The symbol attached to the function
	var address	: ObjectOffset	// The offset of the function in the code section (.text)
	var length	: ObjectOffset	// The number of bytes of the function
	var usedRegisters	: RegisterMask	// The registers used at least once.
	
	// Debug
	var debug	: DwarfFunction
	
//[of]:	initialize - release
//[of]:initialize
function initialize (f: *Function, debug: Bool)

	self code	= 'function
	self size	= 'dword
	self name	= f name string
	self inlining	= false
	self called	= f entry	// Force 'called' flag if the function is an entry point
	self ignore	= f isMacro	// Never attempt to generate the code of an iterator alone
	self inline	= canInline (f)
	self equivalent	= nil
	self comparing	= false
	self callStackSize	= 0
	self argumentStackSize	= 0
	self localStackSize	= 0
	self labelId	= 0
	self symbol	= 'undefined
	self address	= 'undefined
	self length	= 'undefined
	self usedRegisters	= 'none
	self parameters	initialize
	self variables	initialize
	self instructions	initialize
	self debug	initialize (f)

	// Compute the number of bytes to allocate on stack for return values
	var size = Disp32 : 0
	var i = Integer : 0
	f returnTypes each do type
		if i >= registerReturnCount
			size += Disp32 from (type size) align
		end
		i ++
	end
	self returnStackSize = size

end
//[cf]
//[cf]
//[of]:	accessing
//[of]:master
//[c]Returns the master
//[c]
//[c]If two functions are equivalents, return the first one
//[c]otherwise returns self
//[c]
function master
	return self equivalent notNil cond pfunction (self equivalent) else self
end
//[cf]
//[of]:hash
function hash

	var hash = Size : 0
	self instructions each do i
		hash *= 33
		hash += i hash
	end
	
	return hash

end
//[cf]
//[cf]
//[of]:	operations
//[of]:computeIntervals
function computeIntervals

	self variables each do v
		v firstIndex = 'invalid
	end
	
	self parameters each do p
		p firstIndex = 0
	end
	
	var index = InstructionIndex : 0
	self instructions each do instruction
		instruction markVariables (self, index)
		index += 'stepCount
	end

end
//[cf]
//[cf]
//[of]:	adding
//[of]:addParameter
function addParameter (	pool	: *MemoryPool, 
	name	: String8, 
	size	: PValueSize)

	// Number parameter variables with -1, -2, ... to avoid conflicting with
	// local variable ids (otherwise the duplicate removal could see different
	// functions as identical, it happened with min and max).
	var p = pool new (PVariable, name, - self parameters size - 1, size)
	
	// If the number of parameters exceeds the number of registers dedicated
	// to the arguments, we must increase the size of the 
	var n = self parameters size
	if n < registerArgumentCount
		p preferred = registerArguments [n]
	else
		p spilled = true
		self argumentStackSize += size toStackSize
	end
	
	self parameters add (p)
	return p

end
//[cf]
//[of]:addVariable
function addVariable (	pool	: *MemoryPool, 
	name	: String8, 
	size	: PValueSize)

	var p = pool new (PVariable, name, self variables size, size)
	self variables add (p)
	return p

end
//[cf]
//[of]:addLocal
function addLocal (pool: *MemoryPool, size: Disp32)

	// Get current position on stack
	var offset = self localStackSize
	
	// Allocate
	self localStackSize += size align

	// Create a value pointing to the allocated area
	return PIndexValue new2 (pool, localValue, offset)

end
//[cf]
//[of]:addLabel
function addLabel (pool: *MemoryPool)
	var label = PLabel new (pool, self labelId)
	self labelId ++
	return label
end
//[cf]
//[cf]
//[of]:	output
//[of]:addToStringBuffer
function addToStringBuffer (sb: *StringBuffer)

	sb << String : "Parameters:\n"
	self parameters each do v
		sb addFormat ("\t\a\t\a\t\a\t\a\t\a\t\a\t\a\t\a\n", v, v size, v firstIndex, v lastIndex, v spilled, v useCount, v preferred, v conflicts)
	end
	sb << CodeUnit : 'lf

	sb << String : "Variables:\n"
	self variables each do v
		sb addFormat ("\t\a\t\a\t\a\t\a\t\a\t\a\t\a\t\a\n", v, v size, v firstIndex, v lastIndex, v spilled, v useCount, v preferred, v conflicts)
	end
	sb << CodeUnit : 'lf
	
	sb << String : "Instructions:\n"
	var index = InstructionIndex : 0
	self instructions each do i
		sb addFormat ("\a\t\a\n", index, i)
		index += 'stepCount
	end

end
//[cf]
//[of]:write
function write (sb: *StringBuffer)
	sb << self name
	if self equivalent notNil
		sb << CodeUnit : $*
	end
end
//[cf]
//[cf]
//[of]:	testing
//[of]:isEqual
function isEqual (other: *PFunction) : Bool
	
	if self == other
		return true
	end
	
	// Can't compare recursive functions
	if self comparing
		return false
	end

	// Check the number of arguments
	// Instructions could be identical but the number
	// of arguments could differs requiring a different
	// code in stdcall
	if self parameters size <> other parameters size
		return false
	end
	
	self comparing = true
	var eq = isEqualInstructions (self instructions, other instructions)
	self comparing = false
	return eq

end

static function isEqualInstructions (	self	: *Collection (PInstruction), 
	other	: *Collection (PInstruction))

	var n = self size
	if n <> other size
		return false
	end

	zip (self, other) do i1, i2
		if not i1 isEqual (i2)
			return false
		end
	end

	return true

end
//[cf]
//[of]:equals
function equals (other: *PFunction)
	return self == other
end
//[cf]
//[cf]
	
//[of]:	private
//[of]:canInline
static function canInline (f: *Function)

	var instructions = f body instructions
	// Do not inline if more than one instruction
	if instructions size > 1
		return false
	end

	instructions each do i
		// Do not inline if instruction with inner block
		if i code <> 'return
			return false
		end
	end
	
	return true

end
//[cf]
//[cf]

end
//[cf]
//[of]:PGlobalValue
//[c]Address of a symbol
//[c]
static struct PGlobalValue : PValue

	var symbol	: ObjectSymbol
	var address	: ObjectOffset	// Address (relative to the beginning of the section). Set on first pass, read on second pass
	var length	: ObjectOffset	// Size. Set on first pass, read on second pass
	
//[of]:	new
meta function new (pool: *MemoryPool)
	var v = pool allocate (PGlobalValue)
	v code	= 'global
	v size	= 'qword
	v symbol	= 'undefined
	v address	= 'undefined
	v length	= 'undefined
	return v
end
//[cf]
//[of]:	equals
function equals (other: *PGlobalValue)
	return self == other
end
//[cf]
//[of]:	write
function write (sb: *StringBuffer)
	sb << CodeUnit : $G
	if self symbol <> 'undefined
		sb << self symbol
	else
		sb << CodeUnit : $?
	end
end
//[cf]

end
//[cf]
//[of]:PIndexValue
static struct PIndexValue : PValue

	var base	: *PValue	// The base
	var index	: *PValue	// The index or nil
	var scale	: Uinteger	// 1, 2, 4, 8
	var offset	: Disp32	// The offset

//[of]:	new
meta function new (pool: *MemoryPool, base: *PValue)
	var v = pool allocate (PIndexValue)
	v code	= 'index
	v size	= 'qword
	v base	= base
	v index	= nil
	v scale	= 1
	v offset	= 0
	return v
end
//[cf]
//[of]:	new2
meta function new2 (pool: *MemoryPool, base: *PValue, offset: Disp32)
	var v = pool allocate (PIndexValue)
	v code	= 'index
	v size	= 'qword
	v base	= base
	v index	= nil
	v scale	= 1
	v offset	= offset
	return v
end
//[cf]
//[of]:	new3
meta function new3 (pool: *MemoryPool, base: *PValue, index: *PValue, scale: Uinteger, offset: Disp32)
	var v = pool allocate (PIndexValue)
	v code	= 'index
	v size	= 'qword
	v base	= base
	v index	= index
	v scale	= scale
	v offset	= offset
	return v
end
//[cf]
//[of]:	equals
function equals (other: *PIndexValue)
	return	self base isEqual (other base) and
		self index isEqual (other index) and
		self scale == other scale and 
		self offset == other offset
end
//[cf]
//[of]:	mark
function mark (index: InstructionIndex)
	var base = self base
	if base notNil
	 	base markVariables (index)
	end
	var idx = self index
	if idx notNil
		idx markVariables (index)
	end
end
//[cf]
//[of]:	write
function write (sb: *StringBuffer) :
	if self base notNil
		sb << self base
	end
	if self index notNil
		if self base notNil
			sb << String : " + "
		end
		sb << self index
		if self scale <> 1
			sb << String : " * "
			sb << self scale
		end
	end
	if self offset asSigned > 0
		sb << String : " + "
		sb << self offset
	elsif self offset asSigned < 0
		sb << String : " - "
		sb << - self offset
	end

end
//[cf]

end
//[cf]
//[of]:PIntegerValue
static struct PIntegerValue : PValue

	var value	: Uint64

//[of]:	new
meta function new (pool: *MemoryPool, size: PValueSize, n: Uint64)
	var v = pool allocate (PIntegerValue)
	v code	= 'integer
	v size	= size
	v value	= n
	return v
end
//[cf]
//[of]:	byte
function byte
	return self value cast (Uint8)
end
//[cf]
//[of]:	dword
function dword
	return self value cast (Uinteger)
end
//[cf]
//[of]:	equals
function equals (other: *PIntegerValue)
	return self value == other value
end
//[cf]
//[of]:	isZero
function isZero
	return self value == 0
end
//[cf]
//[of]:	offset
function offset
	return self value cast (Disp32)
end
//[cf]
//[of]:	qword
function qword
	return self value cast (Uint64)
end
//[cf]
//[of]:	word
function word
	return self value cast (Uint16)
end
//[cf]
//[of]:	write
function write (sb: *StringBuffer)
	sb << self dword
end
//[cf]

end
//[cf]
//[of]:PMemoryValue
static struct PMemoryValue : PValue

	var address	: *PValue

//[of]:	new
meta function new (pool: *MemoryPool, size: PValueSize, address: *PValue)
	var v = pool allocate (PMemoryValue)
	v code = 'memory
	v size = size
	v address = address
	return v
end
//[cf]
//[of]:	equals
function equals (other: *PMemoryValue)
	return self address isEqual (other address)
end
//[cf]
//[of]:	mark
function mark (index: InstructionIndex)
	self address markVariables (index)
end
//[cf]
//[of]:	write
function write (sb: *StringBuffer) :
	sb addFormat ("\a [\a]", self size, self address)
end
//[cf]

end
//[cf]
//[of]:PRegisterValue
static struct PRegisterValue : PValue

	var variable	: *PVariable	// The originating variable
	var register	: Register	// The register used by the variable here

//[of]:	initialize
function initialize (variable: *PVariable, register: Register)
	self code	= 'register
	self size	= variable size
	self variable	= variable
	self register	= register
end
//[cf]
//[of]:	equals
function equals (other: *PRegisterValue)
	return self variable isEqual (other variable)
end
//[cf]
//[of]:	isSpilled
function isSpilled
	return self variable notNil and self variable spilled
end
//[cf]
//[of]:	write
function write (sb: *StringBuffer)
	if self variable isNil
		sb << self register
	else
		sb << self variable
		sb << CodeUnit : $(
		sb << self register
		sb << CodeUnit : $)
		if self variable spilled
			sb << CodeUnit : $*
		end
	end
end
//[cf]

end
//[cf]
//[of]:PVariable
//[c]A value that represent a local variable
//[c]
static struct PVariable : PValue

	var nextSibling	: *PVariable	// The next variable in the functions's collection
	var name	: String8	// The name of the variable or nil for anonymous variables
	var id	: Integer	// Number if no name
	var firstIndex	: InstructionIndex	// First index where the variable is referenced
	var lastIndex	: InstructionIndex	// Last index where the variable is referenced
	var useCount	: Uinteger	// Number of access to this variable
	var spilled	: Bool	// The variable is spilled (the register holds a register for a single instruction)
	var register	: *PRegisterValue	// The current register to use with the variable
	var memory	: *PMemoryValue	// The value to access the variable on stack when spilled
	var conflicts	: RegisterMask	// Hard registers used when the variable is active
	var preferred	: Register	// The preferred register to use with this variable, or 'none if no preferred register
	var type	: *Type	// The original type for debugging purpose
	
//[of]:	initialize
function initialize (	name	: String8,
	id	: Integer,
	size	: PValueSize)

	self code	= 'variable	
	self size	= size
	self name	= name
	self id	= id
	self useCount	= 0
	self spilled	= false
	self register	= nil
	self conflicts	= 'none
	self preferred	= 'none
	self type	= nil

end
//[cf]
//[of]:	<
function _lt (other: *PVariable)
	return self firstIndex < other firstIndex
end
//[cf]
//[of]:	compare
function compare (other: *PVariable) : Integer
	return (
		self firstIndex < other firstIndex cond -1 else
		self firstIndex > other firstIndex cond 1 else 0)
end
//[cf]
//[of]:	equals
function equals (other: *PVariable)
	return self id == other id
end
//[cf]
//[of]:	incUseCount
function incUseCount
	self useCount ++
end
//[cf]
//[of]:	mark
function mark (index: InstructionIndex)
	self incUseCount
	if self firstIndex == 'invalid
		self firstIndex	= index
		self lastIndex	= index
	else
		self lastIndex	= index
	end
end
//[cf]
//[of]:	write
function write (sb: *StringBuffer)
	if self name notNil
		sb << self name << self id
	else
		sb << CodeUnit : $V
		sb << self id
	end
end
//[cf]
			
end
//[cf]
//[cf]
//[of]:UnwindItem
static struct UnwindItem
	var next	: *UnwindItem	// The next item to unwind
	var block	: *Block	// The block to evaluate
end
//[cf]
//[cf]
//[of]:ABI Constants
//[c]
//[c]	Unix
//[c]
static const registerReturnCount	= Integer : 1	// Number of values returned as register (rax, rdx) -- currently, only rax supported
static const registerArgumentCount	= Integer : 6	// Number of values passed as register (rdi, rsi, rdx, rcx, r8, r9)
static const registerArguments	= *[] Register : {'rdi, 'rsi, 'rdx, 'rcx, 'r8, 'r9}	// The registers for register parameters
static const registerReturns	= *[] Register : {'rax, 'rdx}	// The registers for returned registers
static const savedRegisterCount	= Integer : 6	// Number of saved registers
static const savedRegisters	= *[] Register : {'rbp, 'rbx, 'r12, 'r13, 'r14, 'r15}	// The list of saved registers

// Reverse index Register -> Argument index
static const argumentRegisters = *[] Index : {
	-1,	// 'rax
	3,	// 'rcx
	2,	// 'rdx
	-1,	// 'rbx
	-1,	// 'rsp
	-1,	// 'rbp
	1,	// 'rsi
	0,	// 'rdi
	4,	// 'r8
	5,	// 'r9
	-1,	// 'r10
	-1,	// 'r11
	-1,	// 'r12
	-1,	// 'r13
	-1,	// 'r14
	-1}	// 'r15
//[cf]
//[of]:Program Extensions
static function pfunction (x)
	return x generator downcast (*PFunction)
end

static function pvariable (x)
	return x generator downcast (*PVariable)
end

static function pvalue (x)
	return x generator downcast (*PValue)
end

static function pglobal (x)
	return x generator downcast (*PGlobalValue)
end

static function pcomposite (x)
	return x generator downcast (*PCompositeValue)
end

static function plabel (x)
	return x generator downcast (*PLabel)
end
//[cf]
//[cf]

end
//[cf]

.private
import "elf/dwarf"
import "data/object-file-\(backend)"
import "data/program"
import "commons"
import "std"
